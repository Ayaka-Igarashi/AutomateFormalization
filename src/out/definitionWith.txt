name: Data_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
==>
If Equal(EVal(reconsume_flag),EVal(False)) :
 then  If Equal(EVal(input_index),ELength(EVal(input))) :
  then   LVar(current_input_character) = EVal(eof)
  else   LVar(current_input_character) = EIdxof(EVal(input),EVal(input_index))
  LVar(input_index) = EPlus(EVal(input_index),ELength(EVal(next_input_character)))
 else  LVar(reconsume_flag) = EVal(False)
trans:
char: [38, 38] (U+0026 AMPERSAND (&amp;))
Set the return state to the Data_state
 =>  set_to ( return_state [_] , Data_state [_] ) 
==>
LVar(return_state) = EVal(Data_state)
Switch to the Character_reference_state
 =>  switch_to ( Character_reference_state [_] ) 
==>
LVar(state) = EVal(Character_reference_state)
char: [60, 60] (U+003C LESS-THAN SIGN (&lt;))
Switch to the Tag_open_state
 =>  switch_to ( Tag_open_state [_] ) 
==>
LVar(state) = EVal(Tag_open_state)
char: [0, 0] (U+0000 NULL)
This is an unexpected-null-character parse error
 =>  this_is_parse_error ( unexpected-null-character_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(unexpected-null-character_parse_error))
Emit the current input character as a character token
 =>  emit ( current_input_character [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(current_input_character))
char: [-1, -1] (EOF)
Emit an end-of-file token
 =>  emit ( end-of-file_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(end-of-file_token))
char: [-1, 65535] (Anything else)
Emit the current input character as a character token
 =>  emit ( current_input_character [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(current_input_character))


name: RCDATA_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
==>
If Equal(EVal(reconsume_flag),EVal(False)) :
 then  If Equal(EVal(input_index),ELength(EVal(input))) :
  then   LVar(current_input_character) = EVal(eof)
  else   LVar(current_input_character) = EIdxof(EVal(input),EVal(input_index))
  LVar(input_index) = EPlus(EVal(input_index),ELength(EVal(next_input_character)))
 else  LVar(reconsume_flag) = EVal(False)
trans:
char: [38, 38] (U+0026 AMPERSAND (&amp;))
Set the return state to the RCDATA_state
 =>  set_to ( return_state [_] , RCDATA_state [_] ) 
==>
LVar(return_state) = EVal(RCDATA_state)
Switch to the Character_reference_state
 =>  switch_to ( Character_reference_state [_] ) 
==>
LVar(state) = EVal(Character_reference_state)
char: [60, 60] (U+003C LESS-THAN SIGN (&lt;))
Switch to the RCDATA_less_than_sign_state
 =>  switch_to ( RCDATA_less_than_sign_state [_] ) 
==>
LVar(state) = EVal(RCDATA_less_than_sign_state)
char: [0, 0] (U+0000 NULL)
This is an unexpected-null-character parse error
 =>  this_is_parse_error ( unexpected-null-character_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(unexpected-null-character_parse_error))
Emit a U+FFFD REPLACEMENT CHARACTER character token
 =>  emit ( U+FFFD_REPLACEMENT_CHARACTER_character_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(U+FFFD_REPLACEMENT_CHARACTER_character_token))
char: [-1, -1] (EOF)
Emit an end-of-file token
 =>  emit ( end-of-file_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(end-of-file_token))
char: [-1, 65535] (Anything else)
Emit the current input character as a character token
 =>  emit ( current_input_character [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(current_input_character))


name: RAWTEXT_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
==>
If Equal(EVal(reconsume_flag),EVal(False)) :
 then  If Equal(EVal(input_index),ELength(EVal(input))) :
  then   LVar(current_input_character) = EVal(eof)
  else   LVar(current_input_character) = EIdxof(EVal(input),EVal(input_index))
  LVar(input_index) = EPlus(EVal(input_index),ELength(EVal(next_input_character)))
 else  LVar(reconsume_flag) = EVal(False)
trans:
char: [60, 60] (U+003C LESS-THAN SIGN (&lt;))
Switch to the RAWTEXT_less_than_sign_state
 =>  switch_to ( RAWTEXT_less_than_sign_state [_] ) 
==>
LVar(state) = EVal(RAWTEXT_less_than_sign_state)
char: [0, 0] (U+0000 NULL)
This is an unexpected-null-character parse error
 =>  this_is_parse_error ( unexpected-null-character_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(unexpected-null-character_parse_error))
Emit a U+FFFD REPLACEMENT CHARACTER character token
 =>  emit ( U+FFFD_REPLACEMENT_CHARACTER_character_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(U+FFFD_REPLACEMENT_CHARACTER_character_token))
char: [-1, -1] (EOF)
Emit an end-of-file token
 =>  emit ( end-of-file_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(end-of-file_token))
char: [-1, 65535] (Anything else)
Emit the current input character as a character token
 =>  emit ( current_input_character [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(current_input_character))


name: Script_data_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
==>
If Equal(EVal(reconsume_flag),EVal(False)) :
 then  If Equal(EVal(input_index),ELength(EVal(input))) :
  then   LVar(current_input_character) = EVal(eof)
  else   LVar(current_input_character) = EIdxof(EVal(input),EVal(input_index))
  LVar(input_index) = EPlus(EVal(input_index),ELength(EVal(next_input_character)))
 else  LVar(reconsume_flag) = EVal(False)
trans:
char: [60, 60] (U+003C LESS-THAN SIGN (&lt;))
Switch to the Script_data_less_than_sign_state
 =>  switch_to ( Script_data_less_than_sign_state [_] ) 
==>
LVar(state) = EVal(Script_data_less_than_sign_state)
char: [0, 0] (U+0000 NULL)
This is an unexpected-null-character parse error
 =>  this_is_parse_error ( unexpected-null-character_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(unexpected-null-character_parse_error))
Emit a U+FFFD REPLACEMENT CHARACTER character token
 =>  emit ( U+FFFD_REPLACEMENT_CHARACTER_character_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(U+FFFD_REPLACEMENT_CHARACTER_character_token))
char: [-1, -1] (EOF)
Emit an end-of-file token
 =>  emit ( end-of-file_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(end-of-file_token))
char: [-1, 65535] (Anything else)
Emit the current input character as a character token
 =>  emit ( current_input_character [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(current_input_character))


name: PLAINTEXT_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
==>
If Equal(EVal(reconsume_flag),EVal(False)) :
 then  If Equal(EVal(input_index),ELength(EVal(input))) :
  then   LVar(current_input_character) = EVal(eof)
  else   LVar(current_input_character) = EIdxof(EVal(input),EVal(input_index))
  LVar(input_index) = EPlus(EVal(input_index),ELength(EVal(next_input_character)))
 else  LVar(reconsume_flag) = EVal(False)
trans:
char: [0, 0] (U+0000 NULL)
This is an unexpected-null-character parse error
 =>  this_is_parse_error ( unexpected-null-character_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(unexpected-null-character_parse_error))
Emit a U+FFFD REPLACEMENT CHARACTER character token
 =>  emit ( U+FFFD_REPLACEMENT_CHARACTER_character_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(U+FFFD_REPLACEMENT_CHARACTER_character_token))
char: [-1, -1] (EOF)
Emit an end-of-file token
 =>  emit ( end-of-file_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(end-of-file_token))
char: [-1, 65535] (Anything else)
Emit the current input character as a character token
 =>  emit ( current_input_character [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(current_input_character))


name: Tag_open_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
==>
If Equal(EVal(reconsume_flag),EVal(False)) :
 then  If Equal(EVal(input_index),ELength(EVal(input))) :
  then   LVar(current_input_character) = EVal(eof)
  else   LVar(current_input_character) = EIdxof(EVal(input),EVal(input_index))
  LVar(input_index) = EPlus(EVal(input_index),ELength(EVal(next_input_character)))
 else  LVar(reconsume_flag) = EVal(False)
trans:
char: [33, 33] (U+0021 EXCLAMATION MARK (!))
Switch to the Markup_declaration_open_state
 =>  switch_to ( Markup_declaration_open_state [_] ) 
==>
LVar(state) = EVal(Markup_declaration_open_state)
char: [47, 47] (U+002F SOLIDUS (/))
Switch to the End_tag_open_state
 =>  switch_to ( End_tag_open_state [_] ) 
==>
LVar(state) = EVal(End_tag_open_state)
char: [65, 90], [97, 122] (ASCII alpha)
Create a new start tag token [0] and set a new start tag token [0] tag name to the empty string
 =>  create ( start_tag_token [0] ) | set_to ( start_tag_token [0] . name , empty_string [_] ) 
==>
LVar(x0) = create EVal(start_tag_token)
LVar(current_token) <- EVal(x0)
LVar(last_start_tag_token) <- EVal(x0)
LAtt(LVar(x0),Att1(A1Var(name),ANone)) = EVal(empty_string)
Reconsume in the Tag_name_state
 =>  reconsume_in ( Tag_name_state [_] ) 
==>
LVar(state) = EVal(Tag_name_state)
LVar(reconsume_flag) = EVal(True)
char: [63, 63] (U+003F QUESTION MARK (?))
This is an unexpected-question-mark-instead-of-tag-name parse error
 =>  this_is_parse_error ( unexpected-question-mark-instead-of-tag-name_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(unexpected-question-mark-instead-of-tag-name_parse_error))
Create a comment token whose data is the empty string
 =>  create ( comment_token [0] ) | set_to ( comment_token [0] . data , empty_string [_] )
==>
LVar(x0) = create EVal(comment_token)
LVar(current_token) <- EVal(x0)
LAtt(LVar(x0),Att1(A1Var(data),ANone)) = EVal(empty_string)
Reconsume in the Bogus_comment_state
 =>  reconsume_in ( Bogus_comment_state [_] ) 
==>
LVar(state) = EVal(Bogus_comment_state)
LVar(reconsume_flag) = EVal(True)
char: [-1, -1] (EOF)
This is an eof-before-tag-name parse error
 =>  this_is_parse_error ( eof-before-tag-name_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(eof-before-tag-name_parse_error))
Emit a U+003C LESS-THAN SIGN character token and an end-of-file token
 =>  emit ( U+003C_LESS-THAN_SIGN_character_token [_] ) | emit ( end-of-file_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(U+003C_LESS-THAN_SIGN_character_token))
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(end-of-file_token))
char: [-1, 65535] (Anything else)
This is an invalid-first-character-of-tag-name parse error
 =>  this_is_parse_error ( invalid-first-character-of-tag-name_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(invalid-first-character-of-tag-name_parse_error))
Emit a U+003C LESS-THAN SIGN character token
 =>  emit ( U+003C_LESS-THAN_SIGN_character_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(U+003C_LESS-THAN_SIGN_character_token))
Reconsume in the Data_state
 =>  reconsume_in ( Data_state [_] ) 
==>
LVar(state) = EVal(Data_state)
LVar(reconsume_flag) = EVal(True)


name: End_tag_open_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
==>
If Equal(EVal(reconsume_flag),EVal(False)) :
 then  If Equal(EVal(input_index),ELength(EVal(input))) :
  then   LVar(current_input_character) = EVal(eof)
  else   LVar(current_input_character) = EIdxof(EVal(input),EVal(input_index))
  LVar(input_index) = EPlus(EVal(input_index),ELength(EVal(next_input_character)))
 else  LVar(reconsume_flag) = EVal(False)
trans:
char: [65, 90], [97, 122] (ASCII alpha)
Create a new end tag token [0] , set a new end tag token [0] tag name to the empty string
 =>  create ( end_tag_token [0] ) | set_to ( end_tag_token [0] . name , empty_string [_] ) 
==>
LVar(x0) = create EVal(end_tag_token)
LVar(current_token) <- EVal(x0)
LAtt(LVar(x0),Att1(A1Var(name),ANone)) = EVal(empty_string)
Reconsume in the Tag_name_state
 =>  reconsume_in ( Tag_name_state [_] ) 
==>
LVar(state) = EVal(Tag_name_state)
LVar(reconsume_flag) = EVal(True)
char: [62, 62] (U+003E GREATER-THAN SIGN (&gt;))
This is a missing-end-tag-name parse error
 =>  this_is_parse_error ( missing-end-tag-name_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(missing-end-tag-name_parse_error))
Switch to the Data_state
 =>  switch_to ( Data_state [_] ) 
==>
LVar(state) = EVal(Data_state)
char: [-1, -1] (EOF)
This is an eof-before-tag-name parse error
 =>  this_is_parse_error ( eof-before-tag-name_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(eof-before-tag-name_parse_error))
Emit a U+003C LESS-THAN SIGN character token , a U+002F SOLIDUS character token and an end-of-file token
 =>  emit ( U+003C_LESS-THAN_SIGN_character_token [_] ) | emit ( U+002F_SOLIDUS_character_token [_] ) | emit ( end-of-file_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(U+003C_LESS-THAN_SIGN_character_token))
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(U+002F_SOLIDUS_character_token))
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(end-of-file_token))
char: [-1, 65535] (Anything else)
This is an invalid-first-character-of-tag-name parse error
 =>  this_is_parse_error ( invalid-first-character-of-tag-name_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(invalid-first-character-of-tag-name_parse_error))
Create a comment token whose data is the empty string
 =>  create ( comment_token [0] ) | set_to ( comment_token [0] . data , empty_string [_] )
==>
LVar(x0) = create EVal(comment_token)
LVar(current_token) <- EVal(x0)
LAtt(LVar(x0),Att1(A1Var(data),ANone)) = EVal(empty_string)
Reconsume in the Bogus_comment_state
 =>  reconsume_in ( Bogus_comment_state [_] ) 
==>
LVar(state) = EVal(Bogus_comment_state)
LVar(reconsume_flag) = EVal(True)


name: Tag_name_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
==>
If Equal(EVal(reconsume_flag),EVal(False)) :
 then  If Equal(EVal(input_index),ELength(EVal(input))) :
  then   LVar(current_input_character) = EVal(eof)
  else   LVar(current_input_character) = EIdxof(EVal(input),EVal(input_index))
  LVar(input_index) = EPlus(EVal(input_index),ELength(EVal(next_input_character)))
 else  LVar(reconsume_flag) = EVal(False)
trans:
char: [9, 9] (U+0009 CHARACTER TABULATION (tab))
Switch to the Before_attribute_name_state
 =>  switch_to ( Before_attribute_name_state [_] ) 
==>
LVar(state) = EVal(Before_attribute_name_state)
char: [10, 10] (U+000A LINE FEED (LF))
Switch to the Before_attribute_name_state
 =>  switch_to ( Before_attribute_name_state [_] ) 
==>
LVar(state) = EVal(Before_attribute_name_state)
char: [12, 12] (U+000C FORM FEED (FF))
Switch to the Before_attribute_name_state
 =>  switch_to ( Before_attribute_name_state [_] ) 
==>
LVar(state) = EVal(Before_attribute_name_state)
char: [32, 32] (U+0020 SPACE)
Switch to the Before_attribute_name_state
 =>  switch_to ( Before_attribute_name_state [_] ) 
==>
LVar(state) = EVal(Before_attribute_name_state)
char: [47, 47] (U+002F SOLIDUS (/))
Switch to the Self_closing_start_tag_state
 =>  switch_to ( Self_closing_start_tag_state [_] ) 
==>
LVar(state) = EVal(Self_closing_start_tag_state)
char: [62, 62] (U+003E GREATER-THAN SIGN (&gt;))
Switch to the Data_state
 =>  switch_to ( Data_state [_] ) 
==>
LVar(state) = EVal(Data_state)
Emit the current tag token
 =>  emit ( current_tag_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(current_token))
char: [65, 90] (ASCII upper alpha)
Append the lowercase version of the current input character [0] ( add 0x0020 to the current input character [0] code point ) to the current tag token 's tag name
 =>  append_to ( current_input_character [_] . lowercase_version , current_tag_token [_] . name ) 
==>
LAtt(LVar(current_token),Att1(A1Var(name),ANone)) = ECons(EAtt1(EVal(current_token),Att1(A1Var(name),ANone)),EAtt2(EVal(current_input_character),A2Var(lowercase_version)))
char: [0, 0] (U+0000 NULL)
This is an unexpected-null-character parse error
 =>  this_is_parse_error ( unexpected-null-character_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(unexpected-null-character_parse_error))
Append a U+FFFD REPLACEMENT CHARACTER character to the current tag token 's tag name
 =>  append_to ( U+FFFD_REPLACEMENT_CHARACTER_character_token [_] , current_tag_token [_] . name ) 
==>
LAtt(LVar(current_token),Att1(A1Var(name),ANone)) = ECons(EAtt1(EVal(current_token),Att1(A1Var(name),ANone)),EVal(U+FFFD_REPLACEMENT_CHARACTER_character_token))
char: [-1, -1] (EOF)
This is an eof-in-tag parse error
 =>  this_is_parse_error ( eof-in-tag_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(eof-in-tag_parse_error))
Emit an end-of-file token
 =>  emit ( end-of-file_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(end-of-file_token))
char: [-1, 65535] (Anything else)
Append the current input character to the current tag token 's tag name
 =>  append_to ( current_input_character [_] , current_tag_token [_] . name ) 
==>
LAtt(LVar(current_token),Att1(A1Var(name),ANone)) = ECons(EAtt1(EVal(current_token),Att1(A1Var(name),ANone)),EVal(current_input_character))


name: RCDATA_less_than_sign_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
==>
If Equal(EVal(reconsume_flag),EVal(False)) :
 then  If Equal(EVal(input_index),ELength(EVal(input))) :
  then   LVar(current_input_character) = EVal(eof)
  else   LVar(current_input_character) = EIdxof(EVal(input),EVal(input_index))
  LVar(input_index) = EPlus(EVal(input_index),ELength(EVal(next_input_character)))
 else  LVar(reconsume_flag) = EVal(False)
trans:
char: [47, 47] (U+002F SOLIDUS (/))
Set the temporary buffer to the empty string
 =>  set_to ( temporary_buffer [_] , empty_string [_] ) 
==>
LVar(temporary_buffer) = EVal(empty_string)
Switch to the RCDATA_end_tag_open_state
 =>  switch_to ( RCDATA_end_tag_open_state [_] ) 
==>
LVar(state) = EVal(RCDATA_end_tag_open_state)
char: [-1, 65535] (Anything else)
Emit a U+003C LESS-THAN SIGN character token
 =>  emit ( U+003C_LESS-THAN_SIGN_character_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(U+003C_LESS-THAN_SIGN_character_token))
Reconsume in the RCDATA_state
 =>  reconsume_in ( RCDATA_state [_] ) 
==>
LVar(state) = EVal(RCDATA_state)
LVar(reconsume_flag) = EVal(True)


name: RCDATA_end_tag_open_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
==>
If Equal(EVal(reconsume_flag),EVal(False)) :
 then  If Equal(EVal(input_index),ELength(EVal(input))) :
  then   LVar(current_input_character) = EVal(eof)
  else   LVar(current_input_character) = EIdxof(EVal(input),EVal(input_index))
  LVar(input_index) = EPlus(EVal(input_index),ELength(EVal(next_input_character)))
 else  LVar(reconsume_flag) = EVal(False)
trans:
char: [65, 90], [97, 122] (ASCII alpha)
Create a new end tag token [0] , set a new end tag token [0] tag name to the empty string
 =>  create ( end_tag_token [0] ) | set_to ( end_tag_token [0] . name , empty_string [_] ) 
==>
LVar(x0) = create EVal(end_tag_token)
LVar(current_token) <- EVal(x0)
LAtt(LVar(x0),Att1(A1Var(name),ANone)) = EVal(empty_string)
Reconsume in the RCDATA_end_tag_name_state
 =>  reconsume_in ( RCDATA_end_tag_name_state [_] ) 
==>
LVar(state) = EVal(RCDATA_end_tag_name_state)
LVar(reconsume_flag) = EVal(True)
char: [-1, 65535] (Anything else)
Emit a U+003C LESS-THAN SIGN character token and a U+002F SOLIDUS character token
 =>  emit ( U+003C_LESS-THAN_SIGN_character_token [_] ) | emit ( U+002F_SOLIDUS_character_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(U+003C_LESS-THAN_SIGN_character_token))
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(U+002F_SOLIDUS_character_token))
Reconsume in the RCDATA_state
 =>  reconsume_in ( RCDATA_state [_] ) 
==>
LVar(state) = EVal(RCDATA_state)
LVar(reconsume_flag) = EVal(True)


name: RCDATA_end_tag_name_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
==>
If Equal(EVal(reconsume_flag),EVal(False)) :
 then  If Equal(EVal(input_index),ELength(EVal(input))) :
  then   LVar(current_input_character) = EVal(eof)
  else   LVar(current_input_character) = EIdxof(EVal(input),EVal(input_index))
  LVar(input_index) = EPlus(EVal(input_index),ELength(EVal(next_input_character)))
 else  LVar(reconsume_flag) = EVal(False)
trans:
char: [9, 9] (U+0009 CHARACTER TABULATION (tab))
If the current end tag token is an appropriate end tag token , then switch to the Before_attribute_name_state . Otherwise , treat it as per the anything else entry below
 =>  if_then ( the_current_end_tag_token_is_an_appropriate_end_tag_token , switch_to ( Before_attribute_name_state [_] ) )  | otherwise ( treat_it_as_per_the_"_anything_else_"_entry_below ) 
==>
If And(Exist(EVal(last_start_tag_token)),Equal(EAtt1(EVal(current_token),Att1(A1Var(name),ANone)),EAtt1(EVal(last_start_tag_token),Att1(A1Var(name),ANone)))) :
 then  LVar(state) = EVal(Before_attribute_name_state)
 else  LVar(treat_flag) = EVal(True)
char: [10, 10] (U+000A LINE FEED (LF))
If the current end tag token is an appropriate end tag token , then switch to the Before_attribute_name_state . Otherwise , treat it as per the anything else entry below
 =>  if_then ( the_current_end_tag_token_is_an_appropriate_end_tag_token , switch_to ( Before_attribute_name_state [_] ) )  | otherwise ( treat_it_as_per_the_"_anything_else_"_entry_below ) 
==>
If And(Exist(EVal(last_start_tag_token)),Equal(EAtt1(EVal(current_token),Att1(A1Var(name),ANone)),EAtt1(EVal(last_start_tag_token),Att1(A1Var(name),ANone)))) :
 then  LVar(state) = EVal(Before_attribute_name_state)
 else  LVar(treat_flag) = EVal(True)
char: [12, 12] (U+000C FORM FEED (FF))
If the current end tag token is an appropriate end tag token , then switch to the Before_attribute_name_state . Otherwise , treat it as per the anything else entry below
 =>  if_then ( the_current_end_tag_token_is_an_appropriate_end_tag_token , switch_to ( Before_attribute_name_state [_] ) )  | otherwise ( treat_it_as_per_the_"_anything_else_"_entry_below ) 
==>
If And(Exist(EVal(last_start_tag_token)),Equal(EAtt1(EVal(current_token),Att1(A1Var(name),ANone)),EAtt1(EVal(last_start_tag_token),Att1(A1Var(name),ANone)))) :
 then  LVar(state) = EVal(Before_attribute_name_state)
 else  LVar(treat_flag) = EVal(True)
char: [32, 32] (U+0020 SPACE)
If the current end tag token is an appropriate end tag token , then switch to the Before_attribute_name_state . Otherwise , treat it as per the anything else entry below
 =>  if_then ( the_current_end_tag_token_is_an_appropriate_end_tag_token , switch_to ( Before_attribute_name_state [_] ) )  | otherwise ( treat_it_as_per_the_"_anything_else_"_entry_below ) 
==>
If And(Exist(EVal(last_start_tag_token)),Equal(EAtt1(EVal(current_token),Att1(A1Var(name),ANone)),EAtt1(EVal(last_start_tag_token),Att1(A1Var(name),ANone)))) :
 then  LVar(state) = EVal(Before_attribute_name_state)
 else  LVar(treat_flag) = EVal(True)
char: [47, 47] (U+002F SOLIDUS (/))
If the current end tag token is an appropriate end tag token , then switch to the Self_closing_start_tag_state . Otherwise , treat it as per the anything else entry below
 =>  if_then ( the_current_end_tag_token_is_an_appropriate_end_tag_token , switch_to ( Self_closing_start_tag_state [_] ) )  | otherwise ( treat_it_as_per_the_"_anything_else_"_entry_below ) 
==>
If And(Exist(EVal(last_start_tag_token)),Equal(EAtt1(EVal(current_token),Att1(A1Var(name),ANone)),EAtt1(EVal(last_start_tag_token),Att1(A1Var(name),ANone)))) :
 then  LVar(state) = EVal(Self_closing_start_tag_state)
 else  LVar(treat_flag) = EVal(True)
char: [62, 62] (U+003E GREATER-THAN SIGN (&gt;))
If the current end tag token [0] is an appropriate end tag token , then switch to the Data_state and emit the current end tag token [0] . Otherwise , treat it as per the anything else entry below
 =>  if_then ( the_current_end_tag_token_is_an_appropriate_end_tag_token , switch_to ( Data_state [_] ) , emit ( current_tag_token [_] ) )  | otherwise ( treat_it_as_per_the_"_anything_else_"_entry_below ) 
==>
If And(Exist(EVal(last_start_tag_token)),Equal(EAtt1(EVal(current_token),Att1(A1Var(name),ANone)),EAtt1(EVal(last_start_tag_token),Att1(A1Var(name),ANone)))) :
 then  LVar(state) = EVal(Data_state)
 LVar(output_tokens) = ECons(EVal(output_tokens),EVal(current_token))
 else  LVar(treat_flag) = EVal(True)
char: [65, 90] (ASCII upper alpha)
Append the lowercase version of the current input character [0] ( add 0x0020 to the current input character [0] code point ) to the current tag token 's tag name
 =>  append_to ( current_input_character [_] . lowercase_version , current_tag_token [_] . name ) 
==>
LAtt(LVar(current_token),Att1(A1Var(name),ANone)) = ECons(EAtt1(EVal(current_token),Att1(A1Var(name),ANone)),EAtt2(EVal(current_input_character),A2Var(lowercase_version)))
Append the current input character [0] to the temporary buffer
 =>  append_to ( current_input_character [0] , temporary_buffer [_] ) 
==>
LVar(temporary_buffer) = ECons(EVal(temporary_buffer),EVal(current_input_character))
char: [97, 122] (ASCII lower alpha)
Append the current input character [0] to the current tag token 's tag name
 =>  append_to ( current_input_character [0] , current_tag_token [_] . name ) 
==>
LAtt(LVar(current_token),Att1(A1Var(name),ANone)) = ECons(EAtt1(EVal(current_token),Att1(A1Var(name),ANone)),EVal(current_input_character))
Append the current input character [0] to the temporary buffer
 =>  append_to ( current_input_character [0] , temporary_buffer [_] ) 
==>
LVar(temporary_buffer) = ECons(EVal(temporary_buffer),EVal(current_input_character))
char: [-1, 65535] (Anything else)
Emit a U+003C LESS-THAN SIGN character token , a U+002F SOLIDUS character token , and a character token for each of the characters in the temporary buffer [0] ( in the order the characters in the temporary buffer [0] were added to the temporary buffer [1] 
 =>  emit ( U+003C_LESS-THAN_SIGN_character_token [_] ) | emit ( U+002F_SOLIDUS_character_token [_] ) | emit ( temporary_buffer [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(U+003C_LESS-THAN_SIGN_character_token))
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(U+002F_SOLIDUS_character_token))
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(temporary_buffer))
Reconsume in the RCDATA_state
 =>  reconsume_in ( RCDATA_state [_] ) 
==>
LVar(state) = EVal(RCDATA_state)
LVar(reconsume_flag) = EVal(True)


name: RAWTEXT_less_than_sign_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
==>
If Equal(EVal(reconsume_flag),EVal(False)) :
 then  If Equal(EVal(input_index),ELength(EVal(input))) :
  then   LVar(current_input_character) = EVal(eof)
  else   LVar(current_input_character) = EIdxof(EVal(input),EVal(input_index))
  LVar(input_index) = EPlus(EVal(input_index),ELength(EVal(next_input_character)))
 else  LVar(reconsume_flag) = EVal(False)
trans:
char: [47, 47] (U+002F SOLIDUS (/))
Set the temporary buffer to the empty string
 =>  set_to ( temporary_buffer [_] , empty_string [_] ) 
==>
LVar(temporary_buffer) = EVal(empty_string)
Switch to the RAWTEXT_end_tag_open_state
 =>  switch_to ( RAWTEXT_end_tag_open_state [_] ) 
==>
LVar(state) = EVal(RAWTEXT_end_tag_open_state)
char: [-1, 65535] (Anything else)
Emit a U+003C LESS-THAN SIGN character token
 =>  emit ( U+003C_LESS-THAN_SIGN_character_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(U+003C_LESS-THAN_SIGN_character_token))
Reconsume in the RAWTEXT_state
 =>  reconsume_in ( RAWTEXT_state [_] ) 
==>
LVar(state) = EVal(RAWTEXT_state)
LVar(reconsume_flag) = EVal(True)


name: RAWTEXT_end_tag_open_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
==>
If Equal(EVal(reconsume_flag),EVal(False)) :
 then  If Equal(EVal(input_index),ELength(EVal(input))) :
  then   LVar(current_input_character) = EVal(eof)
  else   LVar(current_input_character) = EIdxof(EVal(input),EVal(input_index))
  LVar(input_index) = EPlus(EVal(input_index),ELength(EVal(next_input_character)))
 else  LVar(reconsume_flag) = EVal(False)
trans:
char: [65, 90], [97, 122] (ASCII alpha)
Create a new end tag token [0] , set a new end tag token [0] tag name to the empty string
 =>  create ( end_tag_token [0] ) | set_to ( end_tag_token [0] . name , empty_string [_] ) 
==>
LVar(x0) = create EVal(end_tag_token)
LVar(current_token) <- EVal(x0)
LAtt(LVar(x0),Att1(A1Var(name),ANone)) = EVal(empty_string)
Reconsume in the RAWTEXT_end_tag_name_state
 =>  reconsume_in ( RAWTEXT_end_tag_name_state [_] ) 
==>
LVar(state) = EVal(RAWTEXT_end_tag_name_state)
LVar(reconsume_flag) = EVal(True)
char: [-1, 65535] (Anything else)
Emit a U+003C LESS-THAN SIGN character token and a U+002F SOLIDUS character token
 =>  emit ( U+003C_LESS-THAN_SIGN_character_token [_] ) | emit ( U+002F_SOLIDUS_character_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(U+003C_LESS-THAN_SIGN_character_token))
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(U+002F_SOLIDUS_character_token))
Reconsume in the RAWTEXT_state
 =>  reconsume_in ( RAWTEXT_state [_] ) 
==>
LVar(state) = EVal(RAWTEXT_state)
LVar(reconsume_flag) = EVal(True)


name: RAWTEXT_end_tag_name_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
==>
If Equal(EVal(reconsume_flag),EVal(False)) :
 then  If Equal(EVal(input_index),ELength(EVal(input))) :
  then   LVar(current_input_character) = EVal(eof)
  else   LVar(current_input_character) = EIdxof(EVal(input),EVal(input_index))
  LVar(input_index) = EPlus(EVal(input_index),ELength(EVal(next_input_character)))
 else  LVar(reconsume_flag) = EVal(False)
trans:
char: [9, 9] (U+0009 CHARACTER TABULATION (tab))
If the current end tag token is an appropriate end tag token , then switch to the Before_attribute_name_state . Otherwise , treat it as per the anything else entry below
 =>  if_then ( the_current_end_tag_token_is_an_appropriate_end_tag_token , switch_to ( Before_attribute_name_state [_] ) )  | otherwise ( treat_it_as_per_the_"_anything_else_"_entry_below ) 
==>
If And(Exist(EVal(last_start_tag_token)),Equal(EAtt1(EVal(current_token),Att1(A1Var(name),ANone)),EAtt1(EVal(last_start_tag_token),Att1(A1Var(name),ANone)))) :
 then  LVar(state) = EVal(Before_attribute_name_state)
 else  LVar(treat_flag) = EVal(True)
char: [10, 10] (U+000A LINE FEED (LF))
If the current end tag token is an appropriate end tag token , then switch to the Before_attribute_name_state . Otherwise , treat it as per the anything else entry below
 =>  if_then ( the_current_end_tag_token_is_an_appropriate_end_tag_token , switch_to ( Before_attribute_name_state [_] ) )  | otherwise ( treat_it_as_per_the_"_anything_else_"_entry_below ) 
==>
If And(Exist(EVal(last_start_tag_token)),Equal(EAtt1(EVal(current_token),Att1(A1Var(name),ANone)),EAtt1(EVal(last_start_tag_token),Att1(A1Var(name),ANone)))) :
 then  LVar(state) = EVal(Before_attribute_name_state)
 else  LVar(treat_flag) = EVal(True)
char: [12, 12] (U+000C FORM FEED (FF))
If the current end tag token is an appropriate end tag token , then switch to the Before_attribute_name_state . Otherwise , treat it as per the anything else entry below
 =>  if_then ( the_current_end_tag_token_is_an_appropriate_end_tag_token , switch_to ( Before_attribute_name_state [_] ) )  | otherwise ( treat_it_as_per_the_"_anything_else_"_entry_below ) 
==>
If And(Exist(EVal(last_start_tag_token)),Equal(EAtt1(EVal(current_token),Att1(A1Var(name),ANone)),EAtt1(EVal(last_start_tag_token),Att1(A1Var(name),ANone)))) :
 then  LVar(state) = EVal(Before_attribute_name_state)
 else  LVar(treat_flag) = EVal(True)
char: [32, 32] (U+0020 SPACE)
If the current end tag token is an appropriate end tag token , then switch to the Before_attribute_name_state . Otherwise , treat it as per the anything else entry below
 =>  if_then ( the_current_end_tag_token_is_an_appropriate_end_tag_token , switch_to ( Before_attribute_name_state [_] ) )  | otherwise ( treat_it_as_per_the_"_anything_else_"_entry_below ) 
==>
If And(Exist(EVal(last_start_tag_token)),Equal(EAtt1(EVal(current_token),Att1(A1Var(name),ANone)),EAtt1(EVal(last_start_tag_token),Att1(A1Var(name),ANone)))) :
 then  LVar(state) = EVal(Before_attribute_name_state)
 else  LVar(treat_flag) = EVal(True)
char: [47, 47] (U+002F SOLIDUS (/))
If the current end tag token is an appropriate end tag token , then switch to the Self_closing_start_tag_state . Otherwise , treat it as per the anything else entry below
 =>  if_then ( the_current_end_tag_token_is_an_appropriate_end_tag_token , switch_to ( Self_closing_start_tag_state [_] ) )  | otherwise ( treat_it_as_per_the_"_anything_else_"_entry_below ) 
==>
If And(Exist(EVal(last_start_tag_token)),Equal(EAtt1(EVal(current_token),Att1(A1Var(name),ANone)),EAtt1(EVal(last_start_tag_token),Att1(A1Var(name),ANone)))) :
 then  LVar(state) = EVal(Self_closing_start_tag_state)
 else  LVar(treat_flag) = EVal(True)
char: [62, 62] (U+003E GREATER-THAN SIGN (&gt;))
If the current end tag token [0] is an appropriate end tag token , then switch to the Data_state and emit the current end tag token [0] . Otherwise , treat it as per the anything else entry below
 =>  if_then ( the_current_end_tag_token_is_an_appropriate_end_tag_token , switch_to ( Data_state [_] ) , emit ( current_tag_token [_] ) )  | otherwise ( treat_it_as_per_the_"_anything_else_"_entry_below ) 
==>
If And(Exist(EVal(last_start_tag_token)),Equal(EAtt1(EVal(current_token),Att1(A1Var(name),ANone)),EAtt1(EVal(last_start_tag_token),Att1(A1Var(name),ANone)))) :
 then  LVar(state) = EVal(Data_state)
 LVar(output_tokens) = ECons(EVal(output_tokens),EVal(current_token))
 else  LVar(treat_flag) = EVal(True)
char: [65, 90] (ASCII upper alpha)
Append the lowercase version of the current input character [0] ( add 0x0020 to the current input character [0] code point ) to the current tag token 's tag name
 =>  append_to ( current_input_character [_] . lowercase_version , current_tag_token [_] . name ) 
==>
LAtt(LVar(current_token),Att1(A1Var(name),ANone)) = ECons(EAtt1(EVal(current_token),Att1(A1Var(name),ANone)),EAtt2(EVal(current_input_character),A2Var(lowercase_version)))
Append the current input character [0] to the temporary buffer
 =>  append_to ( current_input_character [0] , temporary_buffer [_] ) 
==>
LVar(temporary_buffer) = ECons(EVal(temporary_buffer),EVal(current_input_character))
char: [97, 122] (ASCII lower alpha)
Append the current input character [0] to the current tag token 's tag name
 =>  append_to ( current_input_character [0] , current_tag_token [_] . name ) 
==>
LAtt(LVar(current_token),Att1(A1Var(name),ANone)) = ECons(EAtt1(EVal(current_token),Att1(A1Var(name),ANone)),EVal(current_input_character))
Append the current input character [0] to the temporary buffer
 =>  append_to ( current_input_character [0] , temporary_buffer [_] ) 
==>
LVar(temporary_buffer) = ECons(EVal(temporary_buffer),EVal(current_input_character))
char: [-1, 65535] (Anything else)
Emit a U+003C LESS-THAN SIGN character token , a U+002F SOLIDUS character token , and a character token for each of the characters in the temporary buffer [0] ( in the order the characters in the temporary buffer [0] were added to the temporary buffer [1] 
 =>  emit ( U+003C_LESS-THAN_SIGN_character_token [_] ) | emit ( U+002F_SOLIDUS_character_token [_] ) | emit ( temporary_buffer [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(U+003C_LESS-THAN_SIGN_character_token))
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(U+002F_SOLIDUS_character_token))
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(temporary_buffer))
Reconsume in the RAWTEXT_state
 =>  reconsume_in ( RAWTEXT_state [_] ) 
==>
LVar(state) = EVal(RAWTEXT_state)
LVar(reconsume_flag) = EVal(True)


name: Script_data_less_than_sign_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
==>
If Equal(EVal(reconsume_flag),EVal(False)) :
 then  If Equal(EVal(input_index),ELength(EVal(input))) :
  then   LVar(current_input_character) = EVal(eof)
  else   LVar(current_input_character) = EIdxof(EVal(input),EVal(input_index))
  LVar(input_index) = EPlus(EVal(input_index),ELength(EVal(next_input_character)))
 else  LVar(reconsume_flag) = EVal(False)
trans:
char: [47, 47] (U+002F SOLIDUS (/))
Set the temporary buffer to the empty string
 =>  set_to ( temporary_buffer [_] , empty_string [_] ) 
==>
LVar(temporary_buffer) = EVal(empty_string)
Switch to the Script_data_end_tag_open_state
 =>  switch_to ( Script_data_end_tag_open_state [_] ) 
==>
LVar(state) = EVal(Script_data_end_tag_open_state)
char: [33, 33] (U+0021 EXCLAMATION MARK (!))
Switch to the Script_data_escape_start_state
 =>  switch_to ( Script_data_escape_start_state [_] ) 
==>
LVar(state) = EVal(Script_data_escape_start_state)
Emit a U+003C LESS-THAN SIGN character token and a U+0021 EXCLAMATION MARK character token
 =>  emit ( U+003C_LESS-THAN_SIGN_character_token [_] ) | emit ( U+0021_EXCLAMATION_MARK_character_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(U+003C_LESS-THAN_SIGN_character_token))
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(U+0021_EXCLAMATION_MARK_character_token))
char: [-1, 65535] (Anything else)
Emit a U+003C LESS-THAN SIGN character token
 =>  emit ( U+003C_LESS-THAN_SIGN_character_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(U+003C_LESS-THAN_SIGN_character_token))
Reconsume in the Script_data_state
 =>  reconsume_in ( Script_data_state [_] ) 
==>
LVar(state) = EVal(Script_data_state)
LVar(reconsume_flag) = EVal(True)


name: Script_data_end_tag_open_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
==>
If Equal(EVal(reconsume_flag),EVal(False)) :
 then  If Equal(EVal(input_index),ELength(EVal(input))) :
  then   LVar(current_input_character) = EVal(eof)
  else   LVar(current_input_character) = EIdxof(EVal(input),EVal(input_index))
  LVar(input_index) = EPlus(EVal(input_index),ELength(EVal(next_input_character)))
 else  LVar(reconsume_flag) = EVal(False)
trans:
char: [65, 90], [97, 122] (ASCII alpha)
Create a new end tag token [0] , set a new end tag token [0] tag name to the empty string
 =>  create ( end_tag_token [0] ) | set_to ( end_tag_token [0] . name , empty_string [_] ) 
==>
LVar(x0) = create EVal(end_tag_token)
LVar(current_token) <- EVal(x0)
LAtt(LVar(x0),Att1(A1Var(name),ANone)) = EVal(empty_string)
Reconsume in the Script_data_end_tag_name_state
 =>  reconsume_in ( Script_data_end_tag_name_state [_] ) 
==>
LVar(state) = EVal(Script_data_end_tag_name_state)
LVar(reconsume_flag) = EVal(True)
char: [-1, 65535] (Anything else)
Emit a U+003C LESS-THAN SIGN character token and a U+002F SOLIDUS character token
 =>  emit ( U+003C_LESS-THAN_SIGN_character_token [_] ) | emit ( U+002F_SOLIDUS_character_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(U+003C_LESS-THAN_SIGN_character_token))
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(U+002F_SOLIDUS_character_token))
Reconsume in the Script_data_state
 =>  reconsume_in ( Script_data_state [_] ) 
==>
LVar(state) = EVal(Script_data_state)
LVar(reconsume_flag) = EVal(True)


name: Script_data_end_tag_name_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
==>
If Equal(EVal(reconsume_flag),EVal(False)) :
 then  If Equal(EVal(input_index),ELength(EVal(input))) :
  then   LVar(current_input_character) = EVal(eof)
  else   LVar(current_input_character) = EIdxof(EVal(input),EVal(input_index))
  LVar(input_index) = EPlus(EVal(input_index),ELength(EVal(next_input_character)))
 else  LVar(reconsume_flag) = EVal(False)
trans:
char: [9, 9] (U+0009 CHARACTER TABULATION (tab))
If the current end tag token is an appropriate end tag token , then switch to the Before_attribute_name_state . Otherwise , treat it as per the anything else entry below
 =>  if_then ( the_current_end_tag_token_is_an_appropriate_end_tag_token , switch_to ( Before_attribute_name_state [_] ) )  | otherwise ( treat_it_as_per_the_"_anything_else_"_entry_below ) 
==>
If And(Exist(EVal(last_start_tag_token)),Equal(EAtt1(EVal(current_token),Att1(A1Var(name),ANone)),EAtt1(EVal(last_start_tag_token),Att1(A1Var(name),ANone)))) :
 then  LVar(state) = EVal(Before_attribute_name_state)
 else  LVar(treat_flag) = EVal(True)
char: [10, 10] (U+000A LINE FEED (LF))
If the current end tag token is an appropriate end tag token , then switch to the Before_attribute_name_state . Otherwise , treat it as per the anything else entry below
 =>  if_then ( the_current_end_tag_token_is_an_appropriate_end_tag_token , switch_to ( Before_attribute_name_state [_] ) )  | otherwise ( treat_it_as_per_the_"_anything_else_"_entry_below ) 
==>
If And(Exist(EVal(last_start_tag_token)),Equal(EAtt1(EVal(current_token),Att1(A1Var(name),ANone)),EAtt1(EVal(last_start_tag_token),Att1(A1Var(name),ANone)))) :
 then  LVar(state) = EVal(Before_attribute_name_state)
 else  LVar(treat_flag) = EVal(True)
char: [12, 12] (U+000C FORM FEED (FF))
If the current end tag token is an appropriate end tag token , then switch to the Before_attribute_name_state . Otherwise , treat it as per the anything else entry below
 =>  if_then ( the_current_end_tag_token_is_an_appropriate_end_tag_token , switch_to ( Before_attribute_name_state [_] ) )  | otherwise ( treat_it_as_per_the_"_anything_else_"_entry_below ) 
==>
If And(Exist(EVal(last_start_tag_token)),Equal(EAtt1(EVal(current_token),Att1(A1Var(name),ANone)),EAtt1(EVal(last_start_tag_token),Att1(A1Var(name),ANone)))) :
 then  LVar(state) = EVal(Before_attribute_name_state)
 else  LVar(treat_flag) = EVal(True)
char: [32, 32] (U+0020 SPACE)
If the current end tag token is an appropriate end tag token , then switch to the Before_attribute_name_state . Otherwise , treat it as per the anything else entry below
 =>  if_then ( the_current_end_tag_token_is_an_appropriate_end_tag_token , switch_to ( Before_attribute_name_state [_] ) )  | otherwise ( treat_it_as_per_the_"_anything_else_"_entry_below ) 
==>
If And(Exist(EVal(last_start_tag_token)),Equal(EAtt1(EVal(current_token),Att1(A1Var(name),ANone)),EAtt1(EVal(last_start_tag_token),Att1(A1Var(name),ANone)))) :
 then  LVar(state) = EVal(Before_attribute_name_state)
 else  LVar(treat_flag) = EVal(True)
char: [47, 47] (U+002F SOLIDUS (/))
If the current end tag token is an appropriate end tag token , then switch to the Self_closing_start_tag_state . Otherwise , treat it as per the anything else entry below
 =>  if_then ( the_current_end_tag_token_is_an_appropriate_end_tag_token , switch_to ( Self_closing_start_tag_state [_] ) )  | otherwise ( treat_it_as_per_the_"_anything_else_"_entry_below ) 
==>
If And(Exist(EVal(last_start_tag_token)),Equal(EAtt1(EVal(current_token),Att1(A1Var(name),ANone)),EAtt1(EVal(last_start_tag_token),Att1(A1Var(name),ANone)))) :
 then  LVar(state) = EVal(Self_closing_start_tag_state)
 else  LVar(treat_flag) = EVal(True)
char: [62, 62] (U+003E GREATER-THAN SIGN (&gt;))
If the current end tag token [0] is an appropriate end tag token , then switch to the Data_state and emit the current end tag token [0] . Otherwise , treat it as per the anything else entry below
 =>  if_then ( the_current_end_tag_token_is_an_appropriate_end_tag_token , switch_to ( Data_state [_] ) , emit ( current_tag_token [_] ) )  | otherwise ( treat_it_as_per_the_"_anything_else_"_entry_below ) 
==>
If And(Exist(EVal(last_start_tag_token)),Equal(EAtt1(EVal(current_token),Att1(A1Var(name),ANone)),EAtt1(EVal(last_start_tag_token),Att1(A1Var(name),ANone)))) :
 then  LVar(state) = EVal(Data_state)
 LVar(output_tokens) = ECons(EVal(output_tokens),EVal(current_token))
 else  LVar(treat_flag) = EVal(True)
char: [65, 90] (ASCII upper alpha)
Append the lowercase version of the current input character [0] ( add 0x0020 to the current input character [0] code point ) to the current tag token 's tag name
 =>  append_to ( current_input_character [_] . lowercase_version , current_tag_token [_] . name ) 
==>
LAtt(LVar(current_token),Att1(A1Var(name),ANone)) = ECons(EAtt1(EVal(current_token),Att1(A1Var(name),ANone)),EAtt2(EVal(current_input_character),A2Var(lowercase_version)))
Append the current input character [0] to the temporary buffer
 =>  append_to ( current_input_character [0] , temporary_buffer [_] ) 
==>
LVar(temporary_buffer) = ECons(EVal(temporary_buffer),EVal(current_input_character))
char: [97, 122] (ASCII lower alpha)
Append the current input character [0] to the current tag token 's tag name
 =>  append_to ( current_input_character [0] , current_tag_token [_] . name ) 
==>
LAtt(LVar(current_token),Att1(A1Var(name),ANone)) = ECons(EAtt1(EVal(current_token),Att1(A1Var(name),ANone)),EVal(current_input_character))
Append the current input character [0] to the temporary buffer
 =>  append_to ( current_input_character [0] , temporary_buffer [_] ) 
==>
LVar(temporary_buffer) = ECons(EVal(temporary_buffer),EVal(current_input_character))
char: [-1, 65535] (Anything else)
Emit a U+003C LESS-THAN SIGN character token , a U+002F SOLIDUS character token , and a character token for each of the characters in the temporary buffer [0] ( in the order the characters in the temporary buffer [0] were added to the temporary buffer [1] 
 =>  emit ( U+003C_LESS-THAN_SIGN_character_token [_] ) | emit ( U+002F_SOLIDUS_character_token [_] ) | emit ( temporary_buffer [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(U+003C_LESS-THAN_SIGN_character_token))
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(U+002F_SOLIDUS_character_token))
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(temporary_buffer))
Reconsume in the Script_data_state
 =>  reconsume_in ( Script_data_state [_] ) 
==>
LVar(state) = EVal(Script_data_state)
LVar(reconsume_flag) = EVal(True)


name: Script_data_escape_start_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
==>
If Equal(EVal(reconsume_flag),EVal(False)) :
 then  If Equal(EVal(input_index),ELength(EVal(input))) :
  then   LVar(current_input_character) = EVal(eof)
  else   LVar(current_input_character) = EIdxof(EVal(input),EVal(input_index))
  LVar(input_index) = EPlus(EVal(input_index),ELength(EVal(next_input_character)))
 else  LVar(reconsume_flag) = EVal(False)
trans:
char: [45, 45] (U+002D HYPHEN-MINUS (-))
Switch to the Script_data_escape_start_dash_state
 =>  switch_to ( Script_data_escape_start_dash_state [_] ) 
==>
LVar(state) = EVal(Script_data_escape_start_dash_state)
Emit a U+002D HYPHEN-MINUS character token
 =>  emit ( U+002D_HYPHEN-MINUS_character_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(U+002D_HYPHEN-MINUS_character_token))
char: [-1, 65535] (Anything else)
Reconsume in the Script_data_state
 =>  reconsume_in ( Script_data_state [_] ) 
==>
LVar(state) = EVal(Script_data_state)
LVar(reconsume_flag) = EVal(True)


name: Script_data_escape_start_dash_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
==>
If Equal(EVal(reconsume_flag),EVal(False)) :
 then  If Equal(EVal(input_index),ELength(EVal(input))) :
  then   LVar(current_input_character) = EVal(eof)
  else   LVar(current_input_character) = EIdxof(EVal(input),EVal(input_index))
  LVar(input_index) = EPlus(EVal(input_index),ELength(EVal(next_input_character)))
 else  LVar(reconsume_flag) = EVal(False)
trans:
char: [45, 45] (U+002D HYPHEN-MINUS (-))
Switch to the Script_data_escaped_dash_dash_state
 =>  switch_to ( Script_data_escaped_dash_dash_state [_] ) 
==>
LVar(state) = EVal(Script_data_escaped_dash_dash_state)
Emit a U+002D HYPHEN-MINUS character token
 =>  emit ( U+002D_HYPHEN-MINUS_character_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(U+002D_HYPHEN-MINUS_character_token))
char: [-1, 65535] (Anything else)
Reconsume in the Script_data_state
 =>  reconsume_in ( Script_data_state [_] ) 
==>
LVar(state) = EVal(Script_data_state)
LVar(reconsume_flag) = EVal(True)


name: Script_data_escaped_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
==>
If Equal(EVal(reconsume_flag),EVal(False)) :
 then  If Equal(EVal(input_index),ELength(EVal(input))) :
  then   LVar(current_input_character) = EVal(eof)
  else   LVar(current_input_character) = EIdxof(EVal(input),EVal(input_index))
  LVar(input_index) = EPlus(EVal(input_index),ELength(EVal(next_input_character)))
 else  LVar(reconsume_flag) = EVal(False)
trans:
char: [45, 45] (U+002D HYPHEN-MINUS (-))
Switch to the Script_data_escaped_dash_state
 =>  switch_to ( Script_data_escaped_dash_state [_] ) 
==>
LVar(state) = EVal(Script_data_escaped_dash_state)
Emit a U+002D HYPHEN-MINUS character token
 =>  emit ( U+002D_HYPHEN-MINUS_character_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(U+002D_HYPHEN-MINUS_character_token))
char: [60, 60] (U+003C LESS-THAN SIGN (&lt;))
Switch to the Script_data_escaped_less_than_sign_state
 =>  switch_to ( Script_data_escaped_less_than_sign_state [_] ) 
==>
LVar(state) = EVal(Script_data_escaped_less_than_sign_state)
char: [0, 0] (U+0000 NULL)
This is an unexpected-null-character parse error
 =>  this_is_parse_error ( unexpected-null-character_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(unexpected-null-character_parse_error))
Emit a U+FFFD REPLACEMENT CHARACTER character token
 =>  emit ( U+FFFD_REPLACEMENT_CHARACTER_character_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(U+FFFD_REPLACEMENT_CHARACTER_character_token))
char: [-1, -1] (EOF)
This is an eof-in-script-html-comment-like-text parse error
 =>  this_is_parse_error ( eof-in-script-html-comment-like-text_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(eof-in-script-html-comment-like-text_parse_error))
Emit an end-of-file token
 =>  emit ( end-of-file_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(end-of-file_token))
char: [-1, 65535] (Anything else)
Emit the current input character as a character token
 =>  emit ( current_input_character [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(current_input_character))


name: Script_data_escaped_dash_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
==>
If Equal(EVal(reconsume_flag),EVal(False)) :
 then  If Equal(EVal(input_index),ELength(EVal(input))) :
  then   LVar(current_input_character) = EVal(eof)
  else   LVar(current_input_character) = EIdxof(EVal(input),EVal(input_index))
  LVar(input_index) = EPlus(EVal(input_index),ELength(EVal(next_input_character)))
 else  LVar(reconsume_flag) = EVal(False)
trans:
char: [45, 45] (U+002D HYPHEN-MINUS (-))
Switch to the Script_data_escaped_dash_dash_state
 =>  switch_to ( Script_data_escaped_dash_dash_state [_] ) 
==>
LVar(state) = EVal(Script_data_escaped_dash_dash_state)
Emit a U+002D HYPHEN-MINUS character token
 =>  emit ( U+002D_HYPHEN-MINUS_character_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(U+002D_HYPHEN-MINUS_character_token))
char: [60, 60] (U+003C LESS-THAN SIGN (&lt;))
Switch to the Script_data_escaped_less_than_sign_state
 =>  switch_to ( Script_data_escaped_less_than_sign_state [_] ) 
==>
LVar(state) = EVal(Script_data_escaped_less_than_sign_state)
char: [0, 0] (U+0000 NULL)
This is an unexpected-null-character parse error
 =>  this_is_parse_error ( unexpected-null-character_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(unexpected-null-character_parse_error))
Switch to the Script_data_escaped_state
 =>  switch_to ( Script_data_escaped_state [_] ) 
==>
LVar(state) = EVal(Script_data_escaped_state)
Emit a U+FFFD REPLACEMENT CHARACTER character token
 =>  emit ( U+FFFD_REPLACEMENT_CHARACTER_character_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(U+FFFD_REPLACEMENT_CHARACTER_character_token))
char: [-1, -1] (EOF)
This is an eof-in-script-html-comment-like-text parse error
 =>  this_is_parse_error ( eof-in-script-html-comment-like-text_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(eof-in-script-html-comment-like-text_parse_error))
Emit an end-of-file token
 =>  emit ( end-of-file_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(end-of-file_token))
char: [-1, 65535] (Anything else)
Switch to the Script_data_escaped_state
 =>  switch_to ( Script_data_escaped_state [_] ) 
==>
LVar(state) = EVal(Script_data_escaped_state)
Emit the current input character as a character token
 =>  emit ( current_input_character [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(current_input_character))


name: Script_data_escaped_dash_dash_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
==>
If Equal(EVal(reconsume_flag),EVal(False)) :
 then  If Equal(EVal(input_index),ELength(EVal(input))) :
  then   LVar(current_input_character) = EVal(eof)
  else   LVar(current_input_character) = EIdxof(EVal(input),EVal(input_index))
  LVar(input_index) = EPlus(EVal(input_index),ELength(EVal(next_input_character)))
 else  LVar(reconsume_flag) = EVal(False)
trans:
char: [45, 45] (U+002D HYPHEN-MINUS (-))
Emit a U+002D HYPHEN-MINUS character token
 =>  emit ( U+002D_HYPHEN-MINUS_character_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(U+002D_HYPHEN-MINUS_character_token))
char: [60, 60] (U+003C LESS-THAN SIGN (&lt;))
Switch to the Script_data_escaped_less_than_sign_state
 =>  switch_to ( Script_data_escaped_less_than_sign_state [_] ) 
==>
LVar(state) = EVal(Script_data_escaped_less_than_sign_state)
char: [62, 62] (U+003E GREATER-THAN SIGN (&gt;))
Switch to the Script_data_state
 =>  switch_to ( Script_data_state [_] ) 
==>
LVar(state) = EVal(Script_data_state)
Emit a U+003E GREATER-THAN SIGN character token
 =>  emit ( U+003E_GREATER-THAN_SIGN_character_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(U+003E_GREATER-THAN_SIGN_character_token))
char: [0, 0] (U+0000 NULL)
This is an unexpected-null-character parse error
 =>  this_is_parse_error ( unexpected-null-character_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(unexpected-null-character_parse_error))
Switch to the Script_data_escaped_state
 =>  switch_to ( Script_data_escaped_state [_] ) 
==>
LVar(state) = EVal(Script_data_escaped_state)
Emit a U+FFFD REPLACEMENT CHARACTER character token
 =>  emit ( U+FFFD_REPLACEMENT_CHARACTER_character_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(U+FFFD_REPLACEMENT_CHARACTER_character_token))
char: [-1, -1] (EOF)
This is an eof-in-script-html-comment-like-text parse error
 =>  this_is_parse_error ( eof-in-script-html-comment-like-text_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(eof-in-script-html-comment-like-text_parse_error))
Emit an end-of-file token
 =>  emit ( end-of-file_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(end-of-file_token))
char: [-1, 65535] (Anything else)
Switch to the Script_data_escaped_state
 =>  switch_to ( Script_data_escaped_state [_] ) 
==>
LVar(state) = EVal(Script_data_escaped_state)
Emit the current input character as a character token
 =>  emit ( current_input_character [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(current_input_character))


name: Script_data_escaped_less_than_sign_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
==>
If Equal(EVal(reconsume_flag),EVal(False)) :
 then  If Equal(EVal(input_index),ELength(EVal(input))) :
  then   LVar(current_input_character) = EVal(eof)
  else   LVar(current_input_character) = EIdxof(EVal(input),EVal(input_index))
  LVar(input_index) = EPlus(EVal(input_index),ELength(EVal(next_input_character)))
 else  LVar(reconsume_flag) = EVal(False)
trans:
char: [47, 47] (U+002F SOLIDUS (/))
Set the temporary buffer to the empty string
 =>  set_to ( temporary_buffer [_] , empty_string [_] ) 
==>
LVar(temporary_buffer) = EVal(empty_string)
Switch to the Script_data_escaped_end_tag_open_state
 =>  switch_to ( Script_data_escaped_end_tag_open_state [_] ) 
==>
LVar(state) = EVal(Script_data_escaped_end_tag_open_state)
char: [65, 90], [97, 122] (ASCII alpha)
Set the temporary buffer to the empty string
 =>  set_to ( temporary_buffer [_] , empty_string [_] ) 
==>
LVar(temporary_buffer) = EVal(empty_string)
Emit a U+003C LESS-THAN SIGN character token
 =>  emit ( U+003C_LESS-THAN_SIGN_character_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(U+003C_LESS-THAN_SIGN_character_token))
Reconsume in the Script_data_double_escape_start_state
 =>  reconsume_in ( Script_data_double_escape_start_state [_] ) 
==>
LVar(state) = EVal(Script_data_double_escape_start_state)
LVar(reconsume_flag) = EVal(True)
char: [-1, 65535] (Anything else)
Emit a U+003C LESS-THAN SIGN character token
 =>  emit ( U+003C_LESS-THAN_SIGN_character_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(U+003C_LESS-THAN_SIGN_character_token))
Reconsume in the Script_data_escaped_state
 =>  reconsume_in ( Script_data_escaped_state [_] ) 
==>
LVar(state) = EVal(Script_data_escaped_state)
LVar(reconsume_flag) = EVal(True)


name: Script_data_escaped_end_tag_open_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
==>
If Equal(EVal(reconsume_flag),EVal(False)) :
 then  If Equal(EVal(input_index),ELength(EVal(input))) :
  then   LVar(current_input_character) = EVal(eof)
  else   LVar(current_input_character) = EIdxof(EVal(input),EVal(input_index))
  LVar(input_index) = EPlus(EVal(input_index),ELength(EVal(next_input_character)))
 else  LVar(reconsume_flag) = EVal(False)
trans:
char: [65, 90], [97, 122] (ASCII alpha)
Create a new end tag token [0] , set a new end tag token [0] tag name to the empty string
 =>  create ( end_tag_token [0] ) | set_to ( end_tag_token [0] . name , empty_string [_] ) 
==>
LVar(x0) = create EVal(end_tag_token)
LVar(current_token) <- EVal(x0)
LAtt(LVar(x0),Att1(A1Var(name),ANone)) = EVal(empty_string)
Reconsume in the Script_data_escaped_end_tag_name_state
 =>  reconsume_in ( Script_data_escaped_end_tag_name_state [_] ) 
==>
LVar(state) = EVal(Script_data_escaped_end_tag_name_state)
LVar(reconsume_flag) = EVal(True)
char: [-1, 65535] (Anything else)
Emit a U+003C LESS-THAN SIGN character token and a U+002F SOLIDUS character token
 =>  emit ( U+003C_LESS-THAN_SIGN_character_token [_] ) | emit ( U+002F_SOLIDUS_character_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(U+003C_LESS-THAN_SIGN_character_token))
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(U+002F_SOLIDUS_character_token))
Reconsume in the Script_data_escaped_state
 =>  reconsume_in ( Script_data_escaped_state [_] ) 
==>
LVar(state) = EVal(Script_data_escaped_state)
LVar(reconsume_flag) = EVal(True)


name: Script_data_escaped_end_tag_name_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
==>
If Equal(EVal(reconsume_flag),EVal(False)) :
 then  If Equal(EVal(input_index),ELength(EVal(input))) :
  then   LVar(current_input_character) = EVal(eof)
  else   LVar(current_input_character) = EIdxof(EVal(input),EVal(input_index))
  LVar(input_index) = EPlus(EVal(input_index),ELength(EVal(next_input_character)))
 else  LVar(reconsume_flag) = EVal(False)
trans:
char: [9, 9] (U+0009 CHARACTER TABULATION (tab))
If the current end tag token is an appropriate end tag token , then switch to the Before_attribute_name_state . Otherwise , treat it as per the anything else entry below
 =>  if_then ( the_current_end_tag_token_is_an_appropriate_end_tag_token , switch_to ( Before_attribute_name_state [_] ) )  | otherwise ( treat_it_as_per_the_"_anything_else_"_entry_below ) 
==>
If And(Exist(EVal(last_start_tag_token)),Equal(EAtt1(EVal(current_token),Att1(A1Var(name),ANone)),EAtt1(EVal(last_start_tag_token),Att1(A1Var(name),ANone)))) :
 then  LVar(state) = EVal(Before_attribute_name_state)
 else  LVar(treat_flag) = EVal(True)
char: [10, 10] (U+000A LINE FEED (LF))
If the current end tag token is an appropriate end tag token , then switch to the Before_attribute_name_state . Otherwise , treat it as per the anything else entry below
 =>  if_then ( the_current_end_tag_token_is_an_appropriate_end_tag_token , switch_to ( Before_attribute_name_state [_] ) )  | otherwise ( treat_it_as_per_the_"_anything_else_"_entry_below ) 
==>
If And(Exist(EVal(last_start_tag_token)),Equal(EAtt1(EVal(current_token),Att1(A1Var(name),ANone)),EAtt1(EVal(last_start_tag_token),Att1(A1Var(name),ANone)))) :
 then  LVar(state) = EVal(Before_attribute_name_state)
 else  LVar(treat_flag) = EVal(True)
char: [12, 12] (U+000C FORM FEED (FF))
If the current end tag token is an appropriate end tag token , then switch to the Before_attribute_name_state . Otherwise , treat it as per the anything else entry below
 =>  if_then ( the_current_end_tag_token_is_an_appropriate_end_tag_token , switch_to ( Before_attribute_name_state [_] ) )  | otherwise ( treat_it_as_per_the_"_anything_else_"_entry_below ) 
==>
If And(Exist(EVal(last_start_tag_token)),Equal(EAtt1(EVal(current_token),Att1(A1Var(name),ANone)),EAtt1(EVal(last_start_tag_token),Att1(A1Var(name),ANone)))) :
 then  LVar(state) = EVal(Before_attribute_name_state)
 else  LVar(treat_flag) = EVal(True)
char: [32, 32] (U+0020 SPACE)
If the current end tag token is an appropriate end tag token , then switch to the Before_attribute_name_state . Otherwise , treat it as per the anything else entry below
 =>  if_then ( the_current_end_tag_token_is_an_appropriate_end_tag_token , switch_to ( Before_attribute_name_state [_] ) )  | otherwise ( treat_it_as_per_the_"_anything_else_"_entry_below ) 
==>
If And(Exist(EVal(last_start_tag_token)),Equal(EAtt1(EVal(current_token),Att1(A1Var(name),ANone)),EAtt1(EVal(last_start_tag_token),Att1(A1Var(name),ANone)))) :
 then  LVar(state) = EVal(Before_attribute_name_state)
 else  LVar(treat_flag) = EVal(True)
char: [47, 47] (U+002F SOLIDUS (/))
If the current end tag token is an appropriate end tag token , then switch to the Self_closing_start_tag_state . Otherwise , treat it as per the anything else entry below
 =>  if_then ( the_current_end_tag_token_is_an_appropriate_end_tag_token , switch_to ( Self_closing_start_tag_state [_] ) )  | otherwise ( treat_it_as_per_the_"_anything_else_"_entry_below ) 
==>
If And(Exist(EVal(last_start_tag_token)),Equal(EAtt1(EVal(current_token),Att1(A1Var(name),ANone)),EAtt1(EVal(last_start_tag_token),Att1(A1Var(name),ANone)))) :
 then  LVar(state) = EVal(Self_closing_start_tag_state)
 else  LVar(treat_flag) = EVal(True)
char: [62, 62] (U+003E GREATER-THAN SIGN (&gt;))
If the current end tag token [0] is an appropriate end tag token , then switch to the Data_state and emit the current end tag token [0] . Otherwise , treat it as per the anything else entry below
 =>  if_then ( the_current_end_tag_token_is_an_appropriate_end_tag_token , switch_to ( Data_state [_] ) , emit ( current_tag_token [_] ) )  | otherwise ( treat_it_as_per_the_"_anything_else_"_entry_below ) 
==>
If And(Exist(EVal(last_start_tag_token)),Equal(EAtt1(EVal(current_token),Att1(A1Var(name),ANone)),EAtt1(EVal(last_start_tag_token),Att1(A1Var(name),ANone)))) :
 then  LVar(state) = EVal(Data_state)
 LVar(output_tokens) = ECons(EVal(output_tokens),EVal(current_token))
 else  LVar(treat_flag) = EVal(True)
char: [65, 90] (ASCII upper alpha)
Append the lowercase version of the current input character [0] ( add 0x0020 to the current input character [0] code point ) to the current tag token 's tag name
 =>  append_to ( current_input_character [_] . lowercase_version , current_tag_token [_] . name ) 
==>
LAtt(LVar(current_token),Att1(A1Var(name),ANone)) = ECons(EAtt1(EVal(current_token),Att1(A1Var(name),ANone)),EAtt2(EVal(current_input_character),A2Var(lowercase_version)))
Append the current input character [0] to the temporary buffer
 =>  append_to ( current_input_character [0] , temporary_buffer [_] ) 
==>
LVar(temporary_buffer) = ECons(EVal(temporary_buffer),EVal(current_input_character))
char: [97, 122] (ASCII lower alpha)
Append the current input character [0] to the current tag token 's tag name
 =>  append_to ( current_input_character [0] , current_tag_token [_] . name ) 
==>
LAtt(LVar(current_token),Att1(A1Var(name),ANone)) = ECons(EAtt1(EVal(current_token),Att1(A1Var(name),ANone)),EVal(current_input_character))
Append the current input character [0] to the temporary buffer
 =>  append_to ( current_input_character [0] , temporary_buffer [_] ) 
==>
LVar(temporary_buffer) = ECons(EVal(temporary_buffer),EVal(current_input_character))
char: [-1, 65535] (Anything else)
Emit a U+003C LESS-THAN SIGN character token , a U+002F SOLIDUS character token , and a character token for each of the characters in the temporary buffer [0]   ( in the order the characters in the temporary buffer [0] were added to the temporary buffer [1] 
 =>  emit ( U+003C_LESS-THAN_SIGN_character_token [_] ) | emit ( U+002F_SOLIDUS_character_token [_] ) | emit ( temporary_buffer [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(U+003C_LESS-THAN_SIGN_character_token))
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(U+002F_SOLIDUS_character_token))
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(temporary_buffer))
Reconsume in the Script_data_escaped_state
 =>  reconsume_in ( Script_data_escaped_state [_] ) 
==>
LVar(state) = EVal(Script_data_escaped_state)
LVar(reconsume_flag) = EVal(True)


name: Script_data_double_escape_start_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
==>
If Equal(EVal(reconsume_flag),EVal(False)) :
 then  If Equal(EVal(input_index),ELength(EVal(input))) :
  then   LVar(current_input_character) = EVal(eof)
  else   LVar(current_input_character) = EIdxof(EVal(input),EVal(input_index))
  LVar(input_index) = EPlus(EVal(input_index),ELength(EVal(next_input_character)))
 else  LVar(reconsume_flag) = EVal(False)
trans:
char: [9, 9] (U+0009 CHARACTER TABULATION (tab))
If the temporary buffer is the string script , then switch to the Script_data_double_escaped_state . Otherwise , switch to the Script_data_escaped_state
 =>  if_then ( is ( temporary_buffer [_] , string_"script" [_] ) , switch_to ( Script_data_double_escaped_state [_] ) )  | otherwise ( switch_to ( Script_data_escaped_state [_] ) ) 
==>
If Equal(EVal(temporary_buffer),EVal(string_"script")) :
 then  LVar(state) = EVal(Script_data_double_escaped_state)
 else  LVar(state) = EVal(Script_data_escaped_state)
Emit the current input character as a character token
 =>  emit ( current_input_character [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(current_input_character))
char: [10, 10] (U+000A LINE FEED (LF))
If the temporary buffer is the string script , then switch to the Script_data_double_escaped_state . Otherwise , switch to the Script_data_escaped_state
 =>  if_then ( is ( temporary_buffer [_] , string_"script" [_] ) , switch_to ( Script_data_double_escaped_state [_] ) )  | otherwise ( switch_to ( Script_data_escaped_state [_] ) ) 
==>
If Equal(EVal(temporary_buffer),EVal(string_"script")) :
 then  LVar(state) = EVal(Script_data_double_escaped_state)
 else  LVar(state) = EVal(Script_data_escaped_state)
Emit the current input character as a character token
 =>  emit ( current_input_character [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(current_input_character))
char: [12, 12] (U+000C FORM FEED (FF))
If the temporary buffer is the string script , then switch to the Script_data_double_escaped_state . Otherwise , switch to the Script_data_escaped_state
 =>  if_then ( is ( temporary_buffer [_] , string_"script" [_] ) , switch_to ( Script_data_double_escaped_state [_] ) )  | otherwise ( switch_to ( Script_data_escaped_state [_] ) ) 
==>
If Equal(EVal(temporary_buffer),EVal(string_"script")) :
 then  LVar(state) = EVal(Script_data_double_escaped_state)
 else  LVar(state) = EVal(Script_data_escaped_state)
Emit the current input character as a character token
 =>  emit ( current_input_character [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(current_input_character))
char: [32, 32] (U+0020 SPACE)
If the temporary buffer is the string script , then switch to the Script_data_double_escaped_state . Otherwise , switch to the Script_data_escaped_state
 =>  if_then ( is ( temporary_buffer [_] , string_"script" [_] ) , switch_to ( Script_data_double_escaped_state [_] ) )  | otherwise ( switch_to ( Script_data_escaped_state [_] ) ) 
==>
If Equal(EVal(temporary_buffer),EVal(string_"script")) :
 then  LVar(state) = EVal(Script_data_double_escaped_state)
 else  LVar(state) = EVal(Script_data_escaped_state)
Emit the current input character as a character token
 =>  emit ( current_input_character [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(current_input_character))
char: [47, 47] (U+002F SOLIDUS (/))
If the temporary buffer is the string script , then switch to the Script_data_double_escaped_state . Otherwise , switch to the Script_data_escaped_state
 =>  if_then ( is ( temporary_buffer [_] , string_"script" [_] ) , switch_to ( Script_data_double_escaped_state [_] ) )  | otherwise ( switch_to ( Script_data_escaped_state [_] ) ) 
==>
If Equal(EVal(temporary_buffer),EVal(string_"script")) :
 then  LVar(state) = EVal(Script_data_double_escaped_state)
 else  LVar(state) = EVal(Script_data_escaped_state)
Emit the current input character as a character token
 =>  emit ( current_input_character [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(current_input_character))
char: [62, 62] (U+003E GREATER-THAN SIGN (&gt;))
If the temporary buffer is the string script , then switch to the Script_data_double_escaped_state . Otherwise , switch to the Script_data_escaped_state
 =>  if_then ( is ( temporary_buffer [_] , string_"script" [_] ) , switch_to ( Script_data_double_escaped_state [_] ) )  | otherwise ( switch_to ( Script_data_escaped_state [_] ) ) 
==>
If Equal(EVal(temporary_buffer),EVal(string_"script")) :
 then  LVar(state) = EVal(Script_data_double_escaped_state)
 else  LVar(state) = EVal(Script_data_escaped_state)
Emit the current input character as a character token
 =>  emit ( current_input_character [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(current_input_character))
char: [65, 90] (ASCII upper alpha)
Append the lowercase version of the current input character [0] ( add 0x0020 to the current input character [0] code point ) to the temporary buffer
 =>  append_to ( lowercase_version [0] , temporary_buffer [_] ) 
==>
LVar(temporary_buffer) = ECons(EVal(temporary_buffer),EVal(x0))
Emit the current input character [0] as a character token
 =>  emit ( current_input_character [0] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(current_input_character))
char: [97, 122] (ASCII lower alpha)
Append the current input character [0] to the temporary buffer
 =>  append_to ( current_input_character [0] , temporary_buffer [_] ) 
==>
LVar(temporary_buffer) = ECons(EVal(temporary_buffer),EVal(current_input_character))
Emit the current input character [0] as a character token
 =>  emit ( current_input_character [0] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(current_input_character))
char: [-1, 65535] (Anything else)
Reconsume in the Script_data_escaped_state
 =>  reconsume_in ( Script_data_escaped_state [_] ) 
==>
LVar(state) = EVal(Script_data_escaped_state)
LVar(reconsume_flag) = EVal(True)


name: Script_data_double_escaped_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
==>
If Equal(EVal(reconsume_flag),EVal(False)) :
 then  If Equal(EVal(input_index),ELength(EVal(input))) :
  then   LVar(current_input_character) = EVal(eof)
  else   LVar(current_input_character) = EIdxof(EVal(input),EVal(input_index))
  LVar(input_index) = EPlus(EVal(input_index),ELength(EVal(next_input_character)))
 else  LVar(reconsume_flag) = EVal(False)
trans:
char: [45, 45] (U+002D HYPHEN-MINUS (-))
Switch to the Script_data_double_escaped_dash_state
 =>  switch_to ( Script_data_double_escaped_dash_state [_] ) 
==>
LVar(state) = EVal(Script_data_double_escaped_dash_state)
Emit a U+002D HYPHEN-MINUS character token
 =>  emit ( U+002D_HYPHEN-MINUS_character_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(U+002D_HYPHEN-MINUS_character_token))
char: [60, 60] (U+003C LESS-THAN SIGN (&lt;))
Switch to the Script_data_double_escaped_less_than_sign_state
 =>  switch_to ( Script_data_double_escaped_less_than_sign_state [_] ) 
==>
LVar(state) = EVal(Script_data_double_escaped_less_than_sign_state)
Emit a U+003C LESS-THAN SIGN character token
 =>  emit ( U+003C_LESS-THAN_SIGN_character_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(U+003C_LESS-THAN_SIGN_character_token))
char: [0, 0] (U+0000 NULL)
This is an unexpected-null-character parse error
 =>  this_is_parse_error ( unexpected-null-character_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(unexpected-null-character_parse_error))
Emit a U+FFFD REPLACEMENT CHARACTER character token
 =>  emit ( U+FFFD_REPLACEMENT_CHARACTER_character_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(U+FFFD_REPLACEMENT_CHARACTER_character_token))
char: [-1, -1] (EOF)
This is an eof-in-script-html-comment-like-text parse error
 =>  this_is_parse_error ( eof-in-script-html-comment-like-text_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(eof-in-script-html-comment-like-text_parse_error))
Emit an end-of-file token
 =>  emit ( end-of-file_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(end-of-file_token))
char: [-1, 65535] (Anything else)
Emit the current input character as a character token
 =>  emit ( current_input_character [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(current_input_character))


name: Script_data_double_escaped_dash_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
==>
If Equal(EVal(reconsume_flag),EVal(False)) :
 then  If Equal(EVal(input_index),ELength(EVal(input))) :
  then   LVar(current_input_character) = EVal(eof)
  else   LVar(current_input_character) = EIdxof(EVal(input),EVal(input_index))
  LVar(input_index) = EPlus(EVal(input_index),ELength(EVal(next_input_character)))
 else  LVar(reconsume_flag) = EVal(False)
trans:
char: [45, 45] (U+002D HYPHEN-MINUS (-))
Switch to the Script_data_double_escaped_dash_dash_state
 =>  switch_to ( Script_data_double_escaped_dash_dash_state [_] ) 
==>
LVar(state) = EVal(Script_data_double_escaped_dash_dash_state)
Emit a U+002D HYPHEN-MINUS character token
 =>  emit ( U+002D_HYPHEN-MINUS_character_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(U+002D_HYPHEN-MINUS_character_token))
char: [60, 60] (U+003C LESS-THAN SIGN (&lt;))
Switch to the Script_data_double_escaped_less_than_sign_state
 =>  switch_to ( Script_data_double_escaped_less_than_sign_state [_] ) 
==>
LVar(state) = EVal(Script_data_double_escaped_less_than_sign_state)
Emit a U+003C LESS-THAN SIGN character token
 =>  emit ( U+003C_LESS-THAN_SIGN_character_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(U+003C_LESS-THAN_SIGN_character_token))
char: [0, 0] (U+0000 NULL)
This is an unexpected-null-character parse error
 =>  this_is_parse_error ( unexpected-null-character_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(unexpected-null-character_parse_error))
Switch to the Script_data_double_escaped_state
 =>  switch_to ( Script_data_double_escaped_state [_] ) 
==>
LVar(state) = EVal(Script_data_double_escaped_state)
Emit a U+FFFD REPLACEMENT CHARACTER character token
 =>  emit ( U+FFFD_REPLACEMENT_CHARACTER_character_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(U+FFFD_REPLACEMENT_CHARACTER_character_token))
char: [-1, -1] (EOF)
This is an eof-in-script-html-comment-like-text parse error
 =>  this_is_parse_error ( eof-in-script-html-comment-like-text_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(eof-in-script-html-comment-like-text_parse_error))
Emit an end-of-file token
 =>  emit ( end-of-file_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(end-of-file_token))
char: [-1, 65535] (Anything else)
Switch to the Script_data_double_escaped_state
 =>  switch_to ( Script_data_double_escaped_state [_] ) 
==>
LVar(state) = EVal(Script_data_double_escaped_state)
Emit the current input character as a character token
 =>  emit ( current_input_character [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(current_input_character))


name: Script_data_double_escaped_dash_dash_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
==>
If Equal(EVal(reconsume_flag),EVal(False)) :
 then  If Equal(EVal(input_index),ELength(EVal(input))) :
  then   LVar(current_input_character) = EVal(eof)
  else   LVar(current_input_character) = EIdxof(EVal(input),EVal(input_index))
  LVar(input_index) = EPlus(EVal(input_index),ELength(EVal(next_input_character)))
 else  LVar(reconsume_flag) = EVal(False)
trans:
char: [45, 45] (U+002D HYPHEN-MINUS (-))
Emit a U+002D HYPHEN-MINUS character token
 =>  emit ( U+002D_HYPHEN-MINUS_character_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(U+002D_HYPHEN-MINUS_character_token))
char: [60, 60] (U+003C LESS-THAN SIGN (&lt;))
Switch to the Script_data_double_escaped_less_than_sign_state
 =>  switch_to ( Script_data_double_escaped_less_than_sign_state [_] ) 
==>
LVar(state) = EVal(Script_data_double_escaped_less_than_sign_state)
Emit a U+003C LESS-THAN SIGN character token
 =>  emit ( U+003C_LESS-THAN_SIGN_character_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(U+003C_LESS-THAN_SIGN_character_token))
char: [62, 62] (U+003E GREATER-THAN SIGN (&gt;))
Switch to the Script_data_state
 =>  switch_to ( Script_data_state [_] ) 
==>
LVar(state) = EVal(Script_data_state)
Emit a U+003E GREATER-THAN SIGN character token
 =>  emit ( U+003E_GREATER-THAN_SIGN_character_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(U+003E_GREATER-THAN_SIGN_character_token))
char: [0, 0] (U+0000 NULL)
This is an unexpected-null-character parse error
 =>  this_is_parse_error ( unexpected-null-character_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(unexpected-null-character_parse_error))
Switch to the Script_data_double_escaped_state
 =>  switch_to ( Script_data_double_escaped_state [_] ) 
==>
LVar(state) = EVal(Script_data_double_escaped_state)
Emit a U+FFFD REPLACEMENT CHARACTER character token
 =>  emit ( U+FFFD_REPLACEMENT_CHARACTER_character_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(U+FFFD_REPLACEMENT_CHARACTER_character_token))
char: [-1, -1] (EOF)
This is an eof-in-script-html-comment-like-text parse error
 =>  this_is_parse_error ( eof-in-script-html-comment-like-text_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(eof-in-script-html-comment-like-text_parse_error))
Emit an end-of-file token
 =>  emit ( end-of-file_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(end-of-file_token))
char: [-1, 65535] (Anything else)
Switch to the Script_data_double_escaped_state
 =>  switch_to ( Script_data_double_escaped_state [_] ) 
==>
LVar(state) = EVal(Script_data_double_escaped_state)
Emit the current input character as a character token
 =>  emit ( current_input_character [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(current_input_character))


name: Script_data_double_escaped_less_than_sign_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
==>
If Equal(EVal(reconsume_flag),EVal(False)) :
 then  If Equal(EVal(input_index),ELength(EVal(input))) :
  then   LVar(current_input_character) = EVal(eof)
  else   LVar(current_input_character) = EIdxof(EVal(input),EVal(input_index))
  LVar(input_index) = EPlus(EVal(input_index),ELength(EVal(next_input_character)))
 else  LVar(reconsume_flag) = EVal(False)
trans:
char: [47, 47] (U+002F SOLIDUS (/))
Set the temporary buffer to the empty string
 =>  set_to ( temporary_buffer [_] , empty_string [_] ) 
==>
LVar(temporary_buffer) = EVal(empty_string)
Switch to the Script_data_double_escape_end_state
 =>  switch_to ( Script_data_double_escape_end_state [_] ) 
==>
LVar(state) = EVal(Script_data_double_escape_end_state)
Emit a U+002F SOLIDUS character token
 =>  emit ( U+002F_SOLIDUS_character_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(U+002F_SOLIDUS_character_token))
char: [-1, 65535] (Anything else)
Reconsume in the Script_data_double_escaped_state
 =>  reconsume_in ( Script_data_double_escaped_state [_] ) 
==>
LVar(state) = EVal(Script_data_double_escaped_state)
LVar(reconsume_flag) = EVal(True)


name: Script_data_double_escape_end_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
==>
If Equal(EVal(reconsume_flag),EVal(False)) :
 then  If Equal(EVal(input_index),ELength(EVal(input))) :
  then   LVar(current_input_character) = EVal(eof)
  else   LVar(current_input_character) = EIdxof(EVal(input),EVal(input_index))
  LVar(input_index) = EPlus(EVal(input_index),ELength(EVal(next_input_character)))
 else  LVar(reconsume_flag) = EVal(False)
trans:
char: [9, 9] (U+0009 CHARACTER TABULATION (tab))
If the temporary buffer is the string script , then switch to the Script_data_escaped_state . Otherwise , switch to the Script_data_double_escaped_state
 =>  if_then ( is ( temporary_buffer [_] , string_"script" [_] ) , switch_to ( Script_data_escaped_state [_] ) )  | otherwise ( switch_to ( Script_data_double_escaped_state [_] ) ) 
==>
If Equal(EVal(temporary_buffer),EVal(string_"script")) :
 then  LVar(state) = EVal(Script_data_escaped_state)
 else  LVar(state) = EVal(Script_data_double_escaped_state)
Emit the current input character as a character token
 =>  emit ( current_input_character [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(current_input_character))
char: [10, 10] (U+000A LINE FEED (LF))
If the temporary buffer is the string script , then switch to the Script_data_escaped_state . Otherwise , switch to the Script_data_double_escaped_state
 =>  if_then ( is ( temporary_buffer [_] , string_"script" [_] ) , switch_to ( Script_data_escaped_state [_] ) )  | otherwise ( switch_to ( Script_data_double_escaped_state [_] ) ) 
==>
If Equal(EVal(temporary_buffer),EVal(string_"script")) :
 then  LVar(state) = EVal(Script_data_escaped_state)
 else  LVar(state) = EVal(Script_data_double_escaped_state)
Emit the current input character as a character token
 =>  emit ( current_input_character [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(current_input_character))
char: [12, 12] (U+000C FORM FEED (FF))
If the temporary buffer is the string script , then switch to the Script_data_escaped_state . Otherwise , switch to the Script_data_double_escaped_state
 =>  if_then ( is ( temporary_buffer [_] , string_"script" [_] ) , switch_to ( Script_data_escaped_state [_] ) )  | otherwise ( switch_to ( Script_data_double_escaped_state [_] ) ) 
==>
If Equal(EVal(temporary_buffer),EVal(string_"script")) :
 then  LVar(state) = EVal(Script_data_escaped_state)
 else  LVar(state) = EVal(Script_data_double_escaped_state)
Emit the current input character as a character token
 =>  emit ( current_input_character [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(current_input_character))
char: [32, 32] (U+0020 SPACE)
If the temporary buffer is the string script , then switch to the Script_data_escaped_state . Otherwise , switch to the Script_data_double_escaped_state
 =>  if_then ( is ( temporary_buffer [_] , string_"script" [_] ) , switch_to ( Script_data_escaped_state [_] ) )  | otherwise ( switch_to ( Script_data_double_escaped_state [_] ) ) 
==>
If Equal(EVal(temporary_buffer),EVal(string_"script")) :
 then  LVar(state) = EVal(Script_data_escaped_state)
 else  LVar(state) = EVal(Script_data_double_escaped_state)
Emit the current input character as a character token
 =>  emit ( current_input_character [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(current_input_character))
char: [47, 47] (U+002F SOLIDUS (/))
If the temporary buffer is the string script , then switch to the Script_data_escaped_state . Otherwise , switch to the Script_data_double_escaped_state
 =>  if_then ( is ( temporary_buffer [_] , string_"script" [_] ) , switch_to ( Script_data_escaped_state [_] ) )  | otherwise ( switch_to ( Script_data_double_escaped_state [_] ) ) 
==>
If Equal(EVal(temporary_buffer),EVal(string_"script")) :
 then  LVar(state) = EVal(Script_data_escaped_state)
 else  LVar(state) = EVal(Script_data_double_escaped_state)
Emit the current input character as a character token
 =>  emit ( current_input_character [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(current_input_character))
char: [62, 62] (U+003E GREATER-THAN SIGN (&gt;))
If the temporary buffer is the string script , then switch to the Script_data_escaped_state . Otherwise , switch to the Script_data_double_escaped_state
 =>  if_then ( is ( temporary_buffer [_] , string_"script" [_] ) , switch_to ( Script_data_escaped_state [_] ) )  | otherwise ( switch_to ( Script_data_double_escaped_state [_] ) ) 
==>
If Equal(EVal(temporary_buffer),EVal(string_"script")) :
 then  LVar(state) = EVal(Script_data_escaped_state)
 else  LVar(state) = EVal(Script_data_double_escaped_state)
Emit the current input character as a character token
 =>  emit ( current_input_character [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(current_input_character))
char: [65, 90] (ASCII upper alpha)
Append the lowercase version of the current input character [0] ( add 0x0020 to the current input character [0] code point ) to the temporary buffer
 =>  append_to ( lowercase_version [0] , temporary_buffer [_] ) 
==>
LVar(temporary_buffer) = ECons(EVal(temporary_buffer),EVal(x0))
Emit the current input character [0] as a character token
 =>  emit ( current_input_character [0] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(current_input_character))
char: [97, 122] (ASCII lower alpha)
Append the current input character [0] to the temporary buffer
 =>  append_to ( current_input_character [0] , temporary_buffer [_] ) 
==>
LVar(temporary_buffer) = ECons(EVal(temporary_buffer),EVal(current_input_character))
Emit the current input character [0] as a character token
 =>  emit ( current_input_character [0] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(current_input_character))
char: [-1, 65535] (Anything else)
Reconsume in the Script_data_double_escaped_state
 =>  reconsume_in ( Script_data_double_escaped_state [_] ) 
==>
LVar(state) = EVal(Script_data_double_escaped_state)
LVar(reconsume_flag) = EVal(True)


name: Before_attribute_name_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
==>
If Equal(EVal(reconsume_flag),EVal(False)) :
 then  If Equal(EVal(input_index),ELength(EVal(input))) :
  then   LVar(current_input_character) = EVal(eof)
  else   LVar(current_input_character) = EIdxof(EVal(input),EVal(input_index))
  LVar(input_index) = EPlus(EVal(input_index),ELength(EVal(next_input_character)))
 else  LVar(reconsume_flag) = EVal(False)
trans:
char: [9, 9] (U+0009 CHARACTER TABULATION (tab))
Ignore the character
 =>  ignore_the_character 
==>
Skip
char: [10, 10] (U+000A LINE FEED (LF))
Ignore the character
 =>  ignore_the_character 
==>
Skip
char: [12, 12] (U+000C FORM FEED (FF))
Ignore the character
 =>  ignore_the_character 
==>
Skip
char: [32, 32] (U+0020 SPACE)
Ignore the character
 =>  ignore_the_character 
==>
Skip
char: [47, 47] (U+002F SOLIDUS (/))
Reconsume in the After_attribute_name_state
 =>  reconsume_in ( After_attribute_name_state [_] ) 
==>
LVar(state) = EVal(After_attribute_name_state)
LVar(reconsume_flag) = EVal(True)
char: [62, 62] (U+003E GREATER-THAN SIGN (&gt;))
Reconsume in the After_attribute_name_state
 =>  reconsume_in ( After_attribute_name_state [_] ) 
==>
LVar(state) = EVal(After_attribute_name_state)
LVar(reconsume_flag) = EVal(True)
char: [-1, -1] (EOF)
Reconsume in the After_attribute_name_state
 =>  reconsume_in ( After_attribute_name_state [_] ) 
==>
LVar(state) = EVal(After_attribute_name_state)
LVar(reconsume_flag) = EVal(True)
char: [61, 61] (U+003D EQUALS SIGN (=))
This is an unexpected-equals-sign-before-attribute-name parse error
 =>  this_is_parse_error ( unexpected-equals-sign-before-attribute-name_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(unexpected-equals-sign-before-attribute-name_parse_error))
Start a new attribute [0] in the current tag token
 =>  start_a_new_attribute_in_the_current_tag_token 
==>
LAtt(LVar(current_token),Att1(A1Var(attributes),ANone)) = ECons(EAtt1(EVal(current_token),Att1(A1Var(attributes),ANone)),EVal(attribute))
Set a new attribute [0] name to the current input character , and a new attribute [0] value to the empty string
 =>  set_to ( attribute [0] . name , current_input_character [_] ) | set_to ( attribute [0] . value , empty_string [_] ) 
==>
LAtt(LVar(current_token),Att1(A1Var(attributes),Att1(LastElem,Att1(A1Var(name),ANone)))) = EVal(current_input_character)
LAtt(LVar(current_token),Att1(A1Var(attributes),Att1(LastElem,Att1(A1Var(value),ANone)))) = EVal(empty_string)
Switch to the Attribute_name_state
 =>  switch_to ( Attribute_name_state [_] ) 
==>
LVar(state) = EVal(Attribute_name_state)
char: [-1, 65535] (Anything else)
Start a new attribute in the current tag token
 =>  start_a_new_attribute_in_the_current_tag_token
==>
LAtt(LVar(current_token),Att1(A1Var(attributes),ANone)) = ECons(EAtt1(EVal(current_token),Att1(A1Var(attributes),ANone)),EVal(attribute))
Set that attribute name and value to the empty string
 =>  set_to ( attribute [_] . name , empty_string [_] ) | set_to ( attribute [_] . value , empty_string [_] ) 
==>
LAtt(LVar(current_token),Att1(A1Var(attributes),Att1(LastElem,Att1(A1Var(name),ANone)))) = EVal(empty_string)
LAtt(LVar(current_token),Att1(A1Var(attributes),Att1(LastElem,Att1(A1Var(value),ANone)))) = EVal(empty_string)
Reconsume in the Attribute_name_state
 =>  reconsume_in ( Attribute_name_state [_] ) 
==>
LVar(state) = EVal(Attribute_name_state)
LVar(reconsume_flag) = EVal(True)


name: Attribute_name_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
==>
If Equal(EVal(reconsume_flag),EVal(False)) :
 then  If Equal(EVal(input_index),ELength(EVal(input))) :
  then   LVar(current_input_character) = EVal(eof)
  else   LVar(current_input_character) = EIdxof(EVal(input),EVal(input_index))
  LVar(input_index) = EPlus(EVal(input_index),ELength(EVal(next_input_character)))
 else  LVar(reconsume_flag) = EVal(False)
trans:
char: [9, 9] (U+0009 CHARACTER TABULATION (tab))
Reconsume in the After_attribute_name_state
 =>  reconsume_in ( After_attribute_name_state [_] ) 
==>
LVar(state) = EVal(After_attribute_name_state)
LVar(reconsume_flag) = EVal(True)
char: [10, 10] (U+000A LINE FEED (LF))
Reconsume in the After_attribute_name_state
 =>  reconsume_in ( After_attribute_name_state [_] ) 
==>
LVar(state) = EVal(After_attribute_name_state)
LVar(reconsume_flag) = EVal(True)
char: [12, 12] (U+000C FORM FEED (FF))
Reconsume in the After_attribute_name_state
 =>  reconsume_in ( After_attribute_name_state [_] ) 
==>
LVar(state) = EVal(After_attribute_name_state)
LVar(reconsume_flag) = EVal(True)
char: [32, 32] (U+0020 SPACE)
Reconsume in the After_attribute_name_state
 =>  reconsume_in ( After_attribute_name_state [_] ) 
==>
LVar(state) = EVal(After_attribute_name_state)
LVar(reconsume_flag) = EVal(True)
char: [47, 47] (U+002F SOLIDUS (/))
Reconsume in the After_attribute_name_state
 =>  reconsume_in ( After_attribute_name_state [_] ) 
==>
LVar(state) = EVal(After_attribute_name_state)
LVar(reconsume_flag) = EVal(True)
char: [62, 62] (U+003E GREATER-THAN SIGN (&gt;))
Reconsume in the After_attribute_name_state
 =>  reconsume_in ( After_attribute_name_state [_] ) 
==>
LVar(state) = EVal(After_attribute_name_state)
LVar(reconsume_flag) = EVal(True)
char: [-1, -1] (EOF)
Reconsume in the After_attribute_name_state
 =>  reconsume_in ( After_attribute_name_state [_] ) 
==>
LVar(state) = EVal(After_attribute_name_state)
LVar(reconsume_flag) = EVal(True)
char: [61, 61] (U+003D EQUALS SIGN (=))
Switch to the Before_attribute_value_state
 =>  switch_to ( Before_attribute_value_state [_] ) 
==>
LVar(state) = EVal(Before_attribute_value_state)
char: [65, 90] (ASCII upper alpha)
Append the lowercase version of the current input character [0] ( add 0x0020 to the current input character [0] code point ) to the current attribute 's name
 =>  append_to ( lowercase_version [_] , attribute [_] . name ) 
==>
LAtt(LVar(current_token),Att1(A1Var(attributes),Att1(LastElem,Att1(A1Var(name),ANone)))) = ECons(EAtt1(EVal(current_token),Att1(A1Var(attributes),Att1(LastElem,Att1(A1Var(name),ANone)))),EVal(lowercase_version))
char: [0, 0] (U+0000 NULL)
This is an unexpected-null-character parse error
 =>  this_is_parse_error ( unexpected-null-character_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(unexpected-null-character_parse_error))
Append a U+FFFD REPLACEMENT CHARACTER character to the current attribute 's name
 =>  append_to ( U+FFFD_REPLACEMENT_CHARACTER_character_token [_] , attribute [_] . name ) 
==>
LAtt(LVar(current_token),Att1(A1Var(attributes),Att1(LastElem,Att1(A1Var(name),ANone)))) = ECons(EAtt1(EVal(current_token),Att1(A1Var(attributes),Att1(LastElem,Att1(A1Var(name),ANone)))),EVal(U+FFFD_REPLACEMENT_CHARACTER_character_token))
char: [34, 34] (U+0022 QUOTATION MARK ("))
This [0] is an unexpected-character-in-attribute-name parse error
 =>  this_is_parse_error ( unexpected-character-in-attribute-name_parse_error [0] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(unexpected-character-in-attribute-name_parse_error))
Treat This [0] as per the anything else entry below
 =>  treat_it_as_per_the_"_anything_else_"_entry_below 
==>
LVar(treat_flag) = EVal(True)
char: [39, 39] (U+0027 APOSTROPHE ('))
This [0] is an unexpected-character-in-attribute-name parse error
 =>  this_is_parse_error ( unexpected-character-in-attribute-name_parse_error [0] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(unexpected-character-in-attribute-name_parse_error))
Treat This [0] as per the anything else entry below
 =>  treat_it_as_per_the_"_anything_else_"_entry_below 
==>
LVar(treat_flag) = EVal(True)
char: [60, 60] (U+003C LESS-THAN SIGN (&lt;))
This [0] is an unexpected-character-in-attribute-name parse error
 =>  this_is_parse_error ( unexpected-character-in-attribute-name_parse_error [0] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(unexpected-character-in-attribute-name_parse_error))
Treat This [0] as per the anything else entry below
 =>  treat_it_as_per_the_"_anything_else_"_entry_below 
==>
LVar(treat_flag) = EVal(True)
char: [-1, 65535] (Anything else)
Append the current input character to the current attribute 's name
 =>  append_to ( current_input_character [_] , attribute [_] . name ) 
==>
LAtt(LVar(current_token),Att1(A1Var(attributes),Att1(LastElem,Att1(A1Var(name),ANone)))) = ECons(EAtt1(EVal(current_token),Att1(A1Var(attributes),Att1(LastElem,Att1(A1Var(name),ANone)))),EVal(current_input_character))


name: After_attribute_name_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
==>
If Equal(EVal(reconsume_flag),EVal(False)) :
 then  If Equal(EVal(input_index),ELength(EVal(input))) :
  then   LVar(current_input_character) = EVal(eof)
  else   LVar(current_input_character) = EIdxof(EVal(input),EVal(input_index))
  LVar(input_index) = EPlus(EVal(input_index),ELength(EVal(next_input_character)))
 else  LVar(reconsume_flag) = EVal(False)
trans:
char: [9, 9] (U+0009 CHARACTER TABULATION (tab))
Ignore the character
 =>  ignore_the_character 
==>
Skip
char: [10, 10] (U+000A LINE FEED (LF))
Ignore the character
 =>  ignore_the_character 
==>
Skip
char: [12, 12] (U+000C FORM FEED (FF))
Ignore the character
 =>  ignore_the_character 
==>
Skip
char: [32, 32] (U+0020 SPACE)
Ignore the character
 =>  ignore_the_character 
==>
Skip
char: [47, 47] (U+002F SOLIDUS (/))
Switch to the Self_closing_start_tag_state
 =>  switch_to ( Self_closing_start_tag_state [_] ) 
==>
LVar(state) = EVal(Self_closing_start_tag_state)
char: [61, 61] (U+003D EQUALS SIGN (=))
Switch to the Before_attribute_value_state
 =>  switch_to ( Before_attribute_value_state [_] ) 
==>
LVar(state) = EVal(Before_attribute_value_state)
char: [62, 62] (U+003E GREATER-THAN SIGN (&gt;))
Switch to the Data_state
 =>  switch_to ( Data_state [_] ) 
==>
LVar(state) = EVal(Data_state)
Emit the current tag token
 =>  emit ( current_tag_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(current_token))
char: [-1, -1] (EOF)
This is an eof-in-tag parse error
 =>  this_is_parse_error ( eof-in-tag_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(eof-in-tag_parse_error))
Emit an end-of-file token
 =>  emit ( end-of-file_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(end-of-file_token))
char: [-1, 65535] (Anything else)
Start a new attribute in the current tag token
 =>  start_a_new_attribute_in_the_current_tag_token
==>
LAtt(LVar(current_token),Att1(A1Var(attributes),ANone)) = ECons(EAtt1(EVal(current_token),Att1(A1Var(attributes),ANone)),EVal(attribute))
Set that attribute name and value to the empty string
 =>  set_to ( attribute [_] . name , empty_string [_] ) | set_to ( attribute [_] . value , empty_string [_] ) 
==>
LAtt(LVar(current_token),Att1(A1Var(attributes),Att1(LastElem,Att1(A1Var(name),ANone)))) = EVal(empty_string)
LAtt(LVar(current_token),Att1(A1Var(attributes),Att1(LastElem,Att1(A1Var(value),ANone)))) = EVal(empty_string)
Reconsume in the Attribute_name_state
 =>  reconsume_in ( Attribute_name_state [_] ) 
==>
LVar(state) = EVal(Attribute_name_state)
LVar(reconsume_flag) = EVal(True)


name: Before_attribute_value_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
==>
If Equal(EVal(reconsume_flag),EVal(False)) :
 then  If Equal(EVal(input_index),ELength(EVal(input))) :
  then   LVar(current_input_character) = EVal(eof)
  else   LVar(current_input_character) = EIdxof(EVal(input),EVal(input_index))
  LVar(input_index) = EPlus(EVal(input_index),ELength(EVal(next_input_character)))
 else  LVar(reconsume_flag) = EVal(False)
trans:
char: [9, 9] (U+0009 CHARACTER TABULATION (tab))
Ignore the character
 =>  ignore_the_character 
==>
Skip
char: [10, 10] (U+000A LINE FEED (LF))
Ignore the character
 =>  ignore_the_character 
==>
Skip
char: [12, 12] (U+000C FORM FEED (FF))
Ignore the character
 =>  ignore_the_character 
==>
Skip
char: [32, 32] (U+0020 SPACE)
Ignore the character
 =>  ignore_the_character 
==>
Skip
char: [34, 34] (U+0022 QUOTATION MARK ("))
Switch to the Attribute_value_double_quoted_state
 =>  switch_to ( Attribute_value_double_quoted_state [_] ) 
==>
LVar(state) = EVal(Attribute_value_double_quoted_state)
char: [39, 39] (U+0027 APOSTROPHE ('))
Switch to the Attribute_value_single_quoted_state
 =>  switch_to ( Attribute_value_single_quoted_state [_] ) 
==>
LVar(state) = EVal(Attribute_value_single_quoted_state)
char: [62, 62] (U+003E GREATER-THAN SIGN (&gt;))
This is a missing-attribute-value parse error
 =>  this_is_parse_error ( missing-attribute-value_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(missing-attribute-value_parse_error))
Switch to the Data_state
 =>  switch_to ( Data_state [_] ) 
==>
LVar(state) = EVal(Data_state)
Emit the current tag token
 =>  emit ( current_tag_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(current_token))
char: [-1, 65535] (Anything else)
Reconsume in the Attribute_value_unquoted_state
 =>  reconsume_in ( Attribute_value_unquoted_state [_] ) 
==>
LVar(state) = EVal(Attribute_value_unquoted_state)
LVar(reconsume_flag) = EVal(True)


name: Attribute_value_double_quoted_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
==>
If Equal(EVal(reconsume_flag),EVal(False)) :
 then  If Equal(EVal(input_index),ELength(EVal(input))) :
  then   LVar(current_input_character) = EVal(eof)
  else   LVar(current_input_character) = EIdxof(EVal(input),EVal(input_index))
  LVar(input_index) = EPlus(EVal(input_index),ELength(EVal(next_input_character)))
 else  LVar(reconsume_flag) = EVal(False)
trans:
char: [34, 34] (U+0022 QUOTATION MARK ("))
Switch to the After_attribute_value_quoted_state
 =>  switch_to ( After_attribute_value_quoted_state [_] ) 
==>
LVar(state) = EVal(After_attribute_value_quoted_state)
char: [38, 38] (U+0026 AMPERSAND (&amp;))
Set the return state to the Attribute_value_double_quoted_state
 =>  set_to ( return_state [_] , Attribute_value_double_quoted_state [_] ) 
==>
LVar(return_state) = EVal(Attribute_value_double_quoted_state)
Switch to the Character_reference_state
 =>  switch_to ( Character_reference_state [_] ) 
==>
LVar(state) = EVal(Character_reference_state)
char: [0, 0] (U+0000 NULL)
This is an unexpected-null-character parse error
 =>  this_is_parse_error ( unexpected-null-character_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(unexpected-null-character_parse_error))
Append a U+FFFD REPLACEMENT CHARACTER character to the current attribute 's value
 =>  append_to ( U+FFFD_REPLACEMENT_CHARACTER_character_token [_] , attribute [_] . value ) 
==>
LAtt(LVar(current_token),Att1(A1Var(attributes),Att1(LastElem,Att1(A1Var(value),ANone)))) = ECons(EAtt1(EVal(current_token),Att1(A1Var(attributes),Att1(LastElem,Att1(A1Var(value),ANone)))),EVal(U+FFFD_REPLACEMENT_CHARACTER_character_token))
char: [-1, -1] (EOF)
This is an eof-in-tag parse error
 =>  this_is_parse_error ( eof-in-tag_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(eof-in-tag_parse_error))
Emit an end-of-file token
 =>  emit ( end-of-file_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(end-of-file_token))
char: [-1, 65535] (Anything else)
Append the current input character to the current attribute 's value
 =>  append_to ( current_input_character [_] , attribute [_] . value ) 
==>
LAtt(LVar(current_token),Att1(A1Var(attributes),Att1(LastElem,Att1(A1Var(value),ANone)))) = ECons(EAtt1(EVal(current_token),Att1(A1Var(attributes),Att1(LastElem,Att1(A1Var(value),ANone)))),EVal(current_input_character))


name: Attribute_value_single_quoted_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
==>
If Equal(EVal(reconsume_flag),EVal(False)) :
 then  If Equal(EVal(input_index),ELength(EVal(input))) :
  then   LVar(current_input_character) = EVal(eof)
  else   LVar(current_input_character) = EIdxof(EVal(input),EVal(input_index))
  LVar(input_index) = EPlus(EVal(input_index),ELength(EVal(next_input_character)))
 else  LVar(reconsume_flag) = EVal(False)
trans:
char: [39, 39] (U+0027 APOSTROPHE ('))
Switch to the After_attribute_value_quoted_state
 =>  switch_to ( After_attribute_value_quoted_state [_] ) 
==>
LVar(state) = EVal(After_attribute_value_quoted_state)
char: [38, 38] (U+0026 AMPERSAND (&amp;))
Set the return state to the Attribute_value_single_quoted_state
 =>  set_to ( return_state [_] , Attribute_value_single_quoted_state [_] ) 
==>
LVar(return_state) = EVal(Attribute_value_single_quoted_state)
Switch to the Character_reference_state
 =>  switch_to ( Character_reference_state [_] ) 
==>
LVar(state) = EVal(Character_reference_state)
char: [0, 0] (U+0000 NULL)
This is an unexpected-null-character parse error
 =>  this_is_parse_error ( unexpected-null-character_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(unexpected-null-character_parse_error))
Append a U+FFFD REPLACEMENT CHARACTER character to the current attribute 's value
 =>  append_to ( U+FFFD_REPLACEMENT_CHARACTER_character_token [_] , attribute [_] . value ) 
==>
LAtt(LVar(current_token),Att1(A1Var(attributes),Att1(LastElem,Att1(A1Var(value),ANone)))) = ECons(EAtt1(EVal(current_token),Att1(A1Var(attributes),Att1(LastElem,Att1(A1Var(value),ANone)))),EVal(U+FFFD_REPLACEMENT_CHARACTER_character_token))
char: [-1, -1] (EOF)
This is an eof-in-tag parse error
 =>  this_is_parse_error ( eof-in-tag_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(eof-in-tag_parse_error))
Emit an end-of-file token
 =>  emit ( end-of-file_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(end-of-file_token))
char: [-1, 65535] (Anything else)
Append the current input character to the current attribute 's value
 =>  append_to ( current_input_character [_] , attribute [_] . value ) 
==>
LAtt(LVar(current_token),Att1(A1Var(attributes),Att1(LastElem,Att1(A1Var(value),ANone)))) = ECons(EAtt1(EVal(current_token),Att1(A1Var(attributes),Att1(LastElem,Att1(A1Var(value),ANone)))),EVal(current_input_character))


name: Attribute_value_unquoted_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
==>
If Equal(EVal(reconsume_flag),EVal(False)) :
 then  If Equal(EVal(input_index),ELength(EVal(input))) :
  then   LVar(current_input_character) = EVal(eof)
  else   LVar(current_input_character) = EIdxof(EVal(input),EVal(input_index))
  LVar(input_index) = EPlus(EVal(input_index),ELength(EVal(next_input_character)))
 else  LVar(reconsume_flag) = EVal(False)
trans:
char: [9, 9] (U+0009 CHARACTER TABULATION (tab))
Switch to the Before_attribute_name_state
 =>  switch_to ( Before_attribute_name_state [_] ) 
==>
LVar(state) = EVal(Before_attribute_name_state)
char: [10, 10] (U+000A LINE FEED (LF))
Switch to the Before_attribute_name_state
 =>  switch_to ( Before_attribute_name_state [_] ) 
==>
LVar(state) = EVal(Before_attribute_name_state)
char: [12, 12] (U+000C FORM FEED (FF))
Switch to the Before_attribute_name_state
 =>  switch_to ( Before_attribute_name_state [_] ) 
==>
LVar(state) = EVal(Before_attribute_name_state)
char: [32, 32] (U+0020 SPACE)
Switch to the Before_attribute_name_state
 =>  switch_to ( Before_attribute_name_state [_] ) 
==>
LVar(state) = EVal(Before_attribute_name_state)
char: [38, 38] (U+0026 AMPERSAND (&amp;))
Set the return state to the Attribute_value_unquoted_state
 =>  set_to ( return_state [_] , Attribute_value_unquoted_state [_] ) 
==>
LVar(return_state) = EVal(Attribute_value_unquoted_state)
Switch to the Character_reference_state
 =>  switch_to ( Character_reference_state [_] ) 
==>
LVar(state) = EVal(Character_reference_state)
char: [62, 62] (U+003E GREATER-THAN SIGN (&gt;))
Switch to the Data_state
 =>  switch_to ( Data_state [_] ) 
==>
LVar(state) = EVal(Data_state)
Emit the current tag token
 =>  emit ( current_tag_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(current_token))
char: [0, 0] (U+0000 NULL)
This is an unexpected-null-character parse error
 =>  this_is_parse_error ( unexpected-null-character_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(unexpected-null-character_parse_error))
Append a U+FFFD REPLACEMENT CHARACTER character to the current attribute 's value
 =>  append_to ( U+FFFD_REPLACEMENT_CHARACTER_character_token [_] , attribute [_] . value ) 
==>
LAtt(LVar(current_token),Att1(A1Var(attributes),Att1(LastElem,Att1(A1Var(value),ANone)))) = ECons(EAtt1(EVal(current_token),Att1(A1Var(attributes),Att1(LastElem,Att1(A1Var(value),ANone)))),EVal(U+FFFD_REPLACEMENT_CHARACTER_character_token))
char: [34, 34] (U+0022 QUOTATION MARK ("))
This [0] is an unexpected-character-in-unquoted-attribute-value parse error
 =>  this_is_parse_error ( unexpected-character-in-unquoted-attribute-value_parse_error [0] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(unexpected-character-in-unquoted-attribute-value_parse_error))
Treat This [0] as per the anything else entry below
 =>  treat_it_as_per_the_"_anything_else_"_entry_below 
==>
LVar(treat_flag) = EVal(True)
char: [39, 39] (U+0027 APOSTROPHE ('))
This [0] is an unexpected-character-in-unquoted-attribute-value parse error
 =>  this_is_parse_error ( unexpected-character-in-unquoted-attribute-value_parse_error [0] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(unexpected-character-in-unquoted-attribute-value_parse_error))
Treat This [0] as per the anything else entry below
 =>  treat_it_as_per_the_"_anything_else_"_entry_below 
==>
LVar(treat_flag) = EVal(True)
char: [60, 60] (U+003C LESS-THAN SIGN (&lt;))
This [0] is an unexpected-character-in-unquoted-attribute-value parse error
 =>  this_is_parse_error ( unexpected-character-in-unquoted-attribute-value_parse_error [0] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(unexpected-character-in-unquoted-attribute-value_parse_error))
Treat This [0] as per the anything else entry below
 =>  treat_it_as_per_the_"_anything_else_"_entry_below 
==>
LVar(treat_flag) = EVal(True)
char: [61, 61] (U+003D EQUALS SIGN (=))
This [0] is an unexpected-character-in-unquoted-attribute-value parse error
 =>  this_is_parse_error ( unexpected-character-in-unquoted-attribute-value_parse_error [0] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(unexpected-character-in-unquoted-attribute-value_parse_error))
Treat This [0] as per the anything else entry below
 =>  treat_it_as_per_the_"_anything_else_"_entry_below 
==>
LVar(treat_flag) = EVal(True)
char: [96, 96] (U+0060 GRAVE ACCENT (`))
This [0] is an unexpected-character-in-unquoted-attribute-value parse error
 =>  this_is_parse_error ( unexpected-character-in-unquoted-attribute-value_parse_error [0] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(unexpected-character-in-unquoted-attribute-value_parse_error))
Treat This [0] as per the anything else entry below
 =>  treat_it_as_per_the_"_anything_else_"_entry_below 
==>
LVar(treat_flag) = EVal(True)
char: [-1, -1] (EOF)
This is an eof-in-tag parse error
 =>  this_is_parse_error ( eof-in-tag_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(eof-in-tag_parse_error))
Emit an end-of-file token
 =>  emit ( end-of-file_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(end-of-file_token))
char: [-1, 65535] (Anything else)
Append the current input character to the current attribute 's value
 =>  append_to ( current_input_character [_] , attribute [_] . value ) 
==>
LAtt(LVar(current_token),Att1(A1Var(attributes),Att1(LastElem,Att1(A1Var(value),ANone)))) = ECons(EAtt1(EVal(current_token),Att1(A1Var(attributes),Att1(LastElem,Att1(A1Var(value),ANone)))),EVal(current_input_character))


name: After_attribute_value_quoted_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
==>
If Equal(EVal(reconsume_flag),EVal(False)) :
 then  If Equal(EVal(input_index),ELength(EVal(input))) :
  then   LVar(current_input_character) = EVal(eof)
  else   LVar(current_input_character) = EIdxof(EVal(input),EVal(input_index))
  LVar(input_index) = EPlus(EVal(input_index),ELength(EVal(next_input_character)))
 else  LVar(reconsume_flag) = EVal(False)
trans:
char: [9, 9] (U+0009 CHARACTER TABULATION (tab))
Switch to the Before_attribute_name_state
 =>  switch_to ( Before_attribute_name_state [_] ) 
==>
LVar(state) = EVal(Before_attribute_name_state)
char: [10, 10] (U+000A LINE FEED (LF))
Switch to the Before_attribute_name_state
 =>  switch_to ( Before_attribute_name_state [_] ) 
==>
LVar(state) = EVal(Before_attribute_name_state)
char: [12, 12] (U+000C FORM FEED (FF))
Switch to the Before_attribute_name_state
 =>  switch_to ( Before_attribute_name_state [_] ) 
==>
LVar(state) = EVal(Before_attribute_name_state)
char: [32, 32] (U+0020 SPACE)
Switch to the Before_attribute_name_state
 =>  switch_to ( Before_attribute_name_state [_] ) 
==>
LVar(state) = EVal(Before_attribute_name_state)
char: [47, 47] (U+002F SOLIDUS (/))
Switch to the Self_closing_start_tag_state
 =>  switch_to ( Self_closing_start_tag_state [_] ) 
==>
LVar(state) = EVal(Self_closing_start_tag_state)
char: [62, 62] (U+003E GREATER-THAN SIGN (&gt;))
Switch to the Data_state
 =>  switch_to ( Data_state [_] ) 
==>
LVar(state) = EVal(Data_state)
Emit the current tag token
 =>  emit ( current_tag_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(current_token))
char: [-1, -1] (EOF)
This is an eof-in-tag parse error
 =>  this_is_parse_error ( eof-in-tag_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(eof-in-tag_parse_error))
Emit an end-of-file token
 =>  emit ( end-of-file_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(end-of-file_token))
char: [-1, 65535] (Anything else)
This is a missing-whitespace-between-attributes parse error
 =>  this_is_parse_error ( missing-whitespace-between-attributes_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(missing-whitespace-between-attributes_parse_error))
Reconsume in the Before_attribute_name_state
 =>  reconsume_in ( Before_attribute_name_state [_] ) 
==>
LVar(state) = EVal(Before_attribute_name_state)
LVar(reconsume_flag) = EVal(True)


name: Self_closing_start_tag_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
==>
If Equal(EVal(reconsume_flag),EVal(False)) :
 then  If Equal(EVal(input_index),ELength(EVal(input))) :
  then   LVar(current_input_character) = EVal(eof)
  else   LVar(current_input_character) = EIdxof(EVal(input),EVal(input_index))
  LVar(input_index) = EPlus(EVal(input_index),ELength(EVal(next_input_character)))
 else  LVar(reconsume_flag) = EVal(False)
trans:
char: [62, 62] (U+003E GREATER-THAN SIGN (&gt;))
Set the self-closing flag of the current tag token [0]
 =>  set_to ( current_tag_token [_] . self-closing_flag [_] , on [_] ) 
==>
Skip
Switch to the Data_state
 =>  switch_to ( Data_state [_] ) 
==>
LVar(state) = EVal(Data_state)
Emit the current tag token [0]
 =>  emit ( current_tag_token [0] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(x0))
char: [-1, -1] (EOF)
This is an eof-in-tag parse error
 =>  this_is_parse_error ( eof-in-tag_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(eof-in-tag_parse_error))
Emit an end-of-file token
 =>  emit ( end-of-file_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(end-of-file_token))
char: [-1, 65535] (Anything else)
This is an unexpected-solidus-in-tag parse error
 =>  this_is_parse_error ( unexpected-solidus-in-tag_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(unexpected-solidus-in-tag_parse_error))
Reconsume in the Before_attribute_name_state
 =>  reconsume_in ( Before_attribute_name_state [_] ) 
==>
LVar(state) = EVal(Before_attribute_name_state)
LVar(reconsume_flag) = EVal(True)


name: Bogus_comment_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
==>
If Equal(EVal(reconsume_flag),EVal(False)) :
 then  If Equal(EVal(input_index),ELength(EVal(input))) :
  then   LVar(current_input_character) = EVal(eof)
  else   LVar(current_input_character) = EIdxof(EVal(input),EVal(input_index))
  LVar(input_index) = EPlus(EVal(input_index),ELength(EVal(next_input_character)))
 else  LVar(reconsume_flag) = EVal(False)
trans:
char: [62, 62] (U+003E GREATER-THAN SIGN (&gt;))
Switch to the Data_state
 =>  switch_to ( Data_state [_] ) 
==>
LVar(state) = EVal(Data_state)
Emit the comment token
 =>  emit ( comment_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(current_token))
char: [-1, -1] (EOF)
Emit the comment
 =>  emit ( comment_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(current_token))
Emit an end-of-file token
 =>  emit ( end-of-file_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(end-of-file_token))
char: [0, 0] (U+0000 NULL)
This is an unexpected-null-character parse error
 =>  this_is_parse_error ( unexpected-null-character_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(unexpected-null-character_parse_error))
Append a U+FFFD REPLACEMENT CHARACTER character to the comment token 's data
 =>  append_to ( U+FFFD_REPLACEMENT_CHARACTER_character_token [_] , comment_token [_] . data ) 
==>
LAtt(LVar(current_token),Att1(A1Var(data),ANone)) = ECons(EAtt1(EVal(current_token),Att1(A1Var(data),ANone)),EVal(U+FFFD_REPLACEMENT_CHARACTER_character_token))
char: [-1, 65535] (Anything else)
Append the current input character to the comment token 's data
 =>  append_to ( current_input_character [_] , comment_token [_] . data ) 
==>
LAtt(LVar(current_token),Att1(A1Var(data),ANone)) = ECons(EAtt1(EVal(current_token),Att1(A1Var(data),ANone)),EVal(current_input_character))


name: Comment_start_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
==>
If Equal(EVal(reconsume_flag),EVal(False)) :
 then  If Equal(EVal(input_index),ELength(EVal(input))) :
  then   LVar(current_input_character) = EVal(eof)
  else   LVar(current_input_character) = EIdxof(EVal(input),EVal(input_index))
  LVar(input_index) = EPlus(EVal(input_index),ELength(EVal(next_input_character)))
 else  LVar(reconsume_flag) = EVal(False)
trans:
char: [45, 45] (U+002D HYPHEN-MINUS (-))
Switch to the Comment_start_dash_state
 =>  switch_to ( Comment_start_dash_state [_] ) 
==>
LVar(state) = EVal(Comment_start_dash_state)
char: [62, 62] (U+003E GREATER-THAN SIGN (&gt;))
This is an abrupt-closing-of-empty-comment parse error
 =>  this_is_parse_error ( abrupt-closing-of-empty-comment_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(abrupt-closing-of-empty-comment_parse_error))
Switch to the Data_state
 =>  switch_to ( Data_state [_] ) 
==>
LVar(state) = EVal(Data_state)
Emit the comment token
 =>  emit ( comment_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(current_token))
char: [-1, 65535] (Anything else)
Reconsume in the Comment_state
 =>  reconsume_in ( Comment_state [_] ) 
==>
LVar(state) = EVal(Comment_state)
LVar(reconsume_flag) = EVal(True)


name: Comment_start_dash_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
==>
If Equal(EVal(reconsume_flag),EVal(False)) :
 then  If Equal(EVal(input_index),ELength(EVal(input))) :
  then   LVar(current_input_character) = EVal(eof)
  else   LVar(current_input_character) = EIdxof(EVal(input),EVal(input_index))
  LVar(input_index) = EPlus(EVal(input_index),ELength(EVal(next_input_character)))
 else  LVar(reconsume_flag) = EVal(False)
trans:
char: [45, 45] (U+002D HYPHEN-MINUS (-))
Switch to the Comment_end_state
 =>  switch_to ( Comment_end_state [_] ) 
==>
LVar(state) = EVal(Comment_end_state)
char: [62, 62] (U+003E GREATER-THAN SIGN (&gt;))
This is an abrupt-closing-of-empty-comment parse error
 =>  this_is_parse_error ( abrupt-closing-of-empty-comment_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(abrupt-closing-of-empty-comment_parse_error))
Switch to the Data_state
 =>  switch_to ( Data_state [_] ) 
==>
LVar(state) = EVal(Data_state)
Emit the comment token
 =>  emit ( comment_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(current_token))
char: [-1, -1] (EOF)
This is an eof-in-comment parse error
 =>  this_is_parse_error ( eof-in-comment_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(eof-in-comment_parse_error))
Emit the comment token
 =>  emit ( comment_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(current_token))
Emit an end-of-file token
 =>  emit ( end-of-file_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(end-of-file_token))
char: [-1, 65535] (Anything else)
Append a U+002D HYPHEN-MINUS character (-) to the comment token 's data
 =>  append_to ( U+002D_HYPHEN-MINUS_character_token [_] , comment_token [_] . data ) 
==>
LAtt(LVar(current_token),Att1(A1Var(data),ANone)) = ECons(EAtt1(EVal(current_token),Att1(A1Var(data),ANone)),EVal(U+002D_HYPHEN-MINUS_character_token))
Reconsume in the Comment_state
 =>  reconsume_in ( Comment_state [_] ) 
==>
LVar(state) = EVal(Comment_state)
LVar(reconsume_flag) = EVal(True)


name: Comment_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
==>
If Equal(EVal(reconsume_flag),EVal(False)) :
 then  If Equal(EVal(input_index),ELength(EVal(input))) :
  then   LVar(current_input_character) = EVal(eof)
  else   LVar(current_input_character) = EIdxof(EVal(input),EVal(input_index))
  LVar(input_index) = EPlus(EVal(input_index),ELength(EVal(next_input_character)))
 else  LVar(reconsume_flag) = EVal(False)
trans:
char: [60, 60] (U+003C LESS-THAN SIGN (&lt;))
Append the current input character to the comment token 's data
 =>  append_to ( current_input_character [_] , comment_token [_] . data ) 
==>
LAtt(LVar(current_token),Att1(A1Var(data),ANone)) = ECons(EAtt1(EVal(current_token),Att1(A1Var(data),ANone)),EVal(current_input_character))
Switch to the Comment_less_than_sign_state
 =>  switch_to ( Comment_less_than_sign_state [_] ) 
==>
LVar(state) = EVal(Comment_less_than_sign_state)
char: [45, 45] (U+002D HYPHEN-MINUS (-))
Switch to the Comment_end_dash_state
 =>  switch_to ( Comment_end_dash_state [_] ) 
==>
LVar(state) = EVal(Comment_end_dash_state)
char: [0, 0] (U+0000 NULL)
This is an unexpected-null-character parse error
 =>  this_is_parse_error ( unexpected-null-character_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(unexpected-null-character_parse_error))
Append a U+FFFD REPLACEMENT CHARACTER character to the comment token 's data
 =>  append_to ( U+FFFD_REPLACEMENT_CHARACTER_character_token [_] , comment_token [_] . data ) 
==>
LAtt(LVar(current_token),Att1(A1Var(data),ANone)) = ECons(EAtt1(EVal(current_token),Att1(A1Var(data),ANone)),EVal(U+FFFD_REPLACEMENT_CHARACTER_character_token))
char: [-1, -1] (EOF)
This is an eof-in-comment parse error
 =>  this_is_parse_error ( eof-in-comment_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(eof-in-comment_parse_error))
Emit the comment token
 =>  emit ( comment_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(current_token))
Emit an end-of-file token
 =>  emit ( end-of-file_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(end-of-file_token))
char: [-1, 65535] (Anything else)
Append the current input character to the comment token 's data
 =>  append_to ( current_input_character [_] , comment_token [_] . data ) 
==>
LAtt(LVar(current_token),Att1(A1Var(data),ANone)) = ECons(EAtt1(EVal(current_token),Att1(A1Var(data),ANone)),EVal(current_input_character))


name: Comment_less_than_sign_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
==>
If Equal(EVal(reconsume_flag),EVal(False)) :
 then  If Equal(EVal(input_index),ELength(EVal(input))) :
  then   LVar(current_input_character) = EVal(eof)
  else   LVar(current_input_character) = EIdxof(EVal(input),EVal(input_index))
  LVar(input_index) = EPlus(EVal(input_index),ELength(EVal(next_input_character)))
 else  LVar(reconsume_flag) = EVal(False)
trans:
char: [33, 33] (U+0021 EXCLAMATION MARK (!))
Append the current input character to the comment token 's data
 =>  append_to ( current_input_character [_] , comment_token [_] . data ) 
==>
LAtt(LVar(current_token),Att1(A1Var(data),ANone)) = ECons(EAtt1(EVal(current_token),Att1(A1Var(data),ANone)),EVal(current_input_character))
Switch to the Comment_less_than_sign_bang_state
 =>  switch_to ( Comment_less_than_sign_bang_state [_] ) 
==>
LVar(state) = EVal(Comment_less_than_sign_bang_state)
char: [60, 60] (U+003C LESS-THAN SIGN (&lt;))
Append the current input character to the comment token 's data
 =>  append_to ( current_input_character [_] , comment_token [_] . data ) 
==>
LAtt(LVar(current_token),Att1(A1Var(data),ANone)) = ECons(EAtt1(EVal(current_token),Att1(A1Var(data),ANone)),EVal(current_input_character))
char: [-1, 65535] (Anything else)
Reconsume in the Comment_state
 =>  reconsume_in ( Comment_state [_] ) 
==>
LVar(state) = EVal(Comment_state)
LVar(reconsume_flag) = EVal(True)


name: Comment_less_than_sign_bang_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
==>
If Equal(EVal(reconsume_flag),EVal(False)) :
 then  If Equal(EVal(input_index),ELength(EVal(input))) :
  then   LVar(current_input_character) = EVal(eof)
  else   LVar(current_input_character) = EIdxof(EVal(input),EVal(input_index))
  LVar(input_index) = EPlus(EVal(input_index),ELength(EVal(next_input_character)))
 else  LVar(reconsume_flag) = EVal(False)
trans:
char: [45, 45] (U+002D HYPHEN-MINUS (-))
Switch to the Comment_less_than_sign_bang_dash_state
 =>  switch_to ( Comment_less_than_sign_bang_dash_state [_] ) 
==>
LVar(state) = EVal(Comment_less_than_sign_bang_dash_state)
char: [-1, 65535] (Anything else)
Reconsume in the Comment_state
 =>  reconsume_in ( Comment_state [_] ) 
==>
LVar(state) = EVal(Comment_state)
LVar(reconsume_flag) = EVal(True)


name: Comment_less_than_sign_bang_dash_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
==>
If Equal(EVal(reconsume_flag),EVal(False)) :
 then  If Equal(EVal(input_index),ELength(EVal(input))) :
  then   LVar(current_input_character) = EVal(eof)
  else   LVar(current_input_character) = EIdxof(EVal(input),EVal(input_index))
  LVar(input_index) = EPlus(EVal(input_index),ELength(EVal(next_input_character)))
 else  LVar(reconsume_flag) = EVal(False)
trans:
char: [45, 45] (U+002D HYPHEN-MINUS (-))
Switch to the Comment_less_than_sign_bang_dash_dash_state
 =>  switch_to ( Comment_less_than_sign_bang_dash_dash_state [_] ) 
==>
LVar(state) = EVal(Comment_less_than_sign_bang_dash_dash_state)
char: [-1, 65535] (Anything else)
Reconsume in the Comment_end_dash_state
 =>  reconsume_in ( Comment_end_dash_state [_] ) 
==>
LVar(state) = EVal(Comment_end_dash_state)
LVar(reconsume_flag) = EVal(True)


name: Comment_less_than_sign_bang_dash_dash_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
==>
If Equal(EVal(reconsume_flag),EVal(False)) :
 then  If Equal(EVal(input_index),ELength(EVal(input))) :
  then   LVar(current_input_character) = EVal(eof)
  else   LVar(current_input_character) = EIdxof(EVal(input),EVal(input_index))
  LVar(input_index) = EPlus(EVal(input_index),ELength(EVal(next_input_character)))
 else  LVar(reconsume_flag) = EVal(False)
trans:
char: [62, 62] (U+003E GREATER-THAN SIGN (&gt;))
Reconsume in the Comment_end_state
 =>  reconsume_in ( Comment_end_state [_] ) 
==>
LVar(state) = EVal(Comment_end_state)
LVar(reconsume_flag) = EVal(True)
char: [-1, -1] (EOF)
Reconsume in the Comment_end_state
 =>  reconsume_in ( Comment_end_state [_] ) 
==>
LVar(state) = EVal(Comment_end_state)
LVar(reconsume_flag) = EVal(True)
char: [-1, 65535] (Anything else)
This is a nested-comment parse error
 =>  this_is_parse_error ( nested-comment_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(nested-comment_parse_error))
Reconsume in the Comment_end_state
 =>  reconsume_in ( Comment_end_state [_] ) 
==>
LVar(state) = EVal(Comment_end_state)
LVar(reconsume_flag) = EVal(True)


name: Comment_end_dash_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
==>
If Equal(EVal(reconsume_flag),EVal(False)) :
 then  If Equal(EVal(input_index),ELength(EVal(input))) :
  then   LVar(current_input_character) = EVal(eof)
  else   LVar(current_input_character) = EIdxof(EVal(input),EVal(input_index))
  LVar(input_index) = EPlus(EVal(input_index),ELength(EVal(next_input_character)))
 else  LVar(reconsume_flag) = EVal(False)
trans:
char: [45, 45] (U+002D HYPHEN-MINUS (-))
Switch to the Comment_end_state
 =>  switch_to ( Comment_end_state [_] ) 
==>
LVar(state) = EVal(Comment_end_state)
char: [-1, -1] (EOF)
This is an eof-in-comment parse error
 =>  this_is_parse_error ( eof-in-comment_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(eof-in-comment_parse_error))
Emit the comment token
 =>  emit ( comment_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(current_token))
Emit an end-of-file token
 =>  emit ( end-of-file_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(end-of-file_token))
char: [-1, 65535] (Anything else)
Append a U+002D HYPHEN-MINUS character (-) to the comment token 's data
 =>  append_to ( U+002D_HYPHEN-MINUS_character_token [_] , comment_token [_] . data ) 
==>
LAtt(LVar(current_token),Att1(A1Var(data),ANone)) = ECons(EAtt1(EVal(current_token),Att1(A1Var(data),ANone)),EVal(U+002D_HYPHEN-MINUS_character_token))
Reconsume in the Comment_state
 =>  reconsume_in ( Comment_state [_] ) 
==>
LVar(state) = EVal(Comment_state)
LVar(reconsume_flag) = EVal(True)


name: Comment_end_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
==>
If Equal(EVal(reconsume_flag),EVal(False)) :
 then  If Equal(EVal(input_index),ELength(EVal(input))) :
  then   LVar(current_input_character) = EVal(eof)
  else   LVar(current_input_character) = EIdxof(EVal(input),EVal(input_index))
  LVar(input_index) = EPlus(EVal(input_index),ELength(EVal(next_input_character)))
 else  LVar(reconsume_flag) = EVal(False)
trans:
char: [62, 62] (U+003E GREATER-THAN SIGN (&gt;))
Switch to the Data_state
 =>  switch_to ( Data_state [_] ) 
==>
LVar(state) = EVal(Data_state)
Emit the comment token
 =>  emit ( comment_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(current_token))
char: [33, 33] (U+0021 EXCLAMATION MARK (!))
Switch to the Comment_end_bang_state
 =>  switch_to ( Comment_end_bang_state [_] ) 
==>
LVar(state) = EVal(Comment_end_bang_state)
char: [45, 45] (U+002D HYPHEN-MINUS (-))
Append a U+002D HYPHEN-MINUS character (-) to the comment token 's data
 =>  append_to ( U+002D_HYPHEN-MINUS_character_token [_] , comment_token [_] . data ) 
==>
LAtt(LVar(current_token),Att1(A1Var(data),ANone)) = ECons(EAtt1(EVal(current_token),Att1(A1Var(data),ANone)),EVal(U+002D_HYPHEN-MINUS_character_token))
char: [-1, -1] (EOF)
This is an eof-in-comment parse error
 =>  this_is_parse_error ( eof-in-comment_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(eof-in-comment_parse_error))
Emit the comment token
 =>  emit ( comment_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(current_token))
Emit an end-of-file token
 =>  emit ( end-of-file_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(end-of-file_token))
char: [-1, 65535] (Anything else)
Append two U+002D HYPHEN-MINUS characters (-) to the comment token 's data
 =>  append_to ( U+002D_HYPHEN-MINUS_character_token [_] , comment_token [_] . data ) | append_to ( U+002D_HYPHEN-MINUS_character_token [_] , comment_token [_] . data ) 
==>
LAtt(LVar(current_token),Att1(A1Var(data),ANone)) = ECons(EAtt1(EVal(current_token),Att1(A1Var(data),ANone)),EVal(U+002D_HYPHEN-MINUS_character_token))
LAtt(LVar(current_token),Att1(A1Var(data),ANone)) = ECons(EAtt1(EVal(current_token),Att1(A1Var(data),ANone)),EVal(U+002D_HYPHEN-MINUS_character_token))
Reconsume in the Comment_state
 =>  reconsume_in ( Comment_state [_] ) 
==>
LVar(state) = EVal(Comment_state)
LVar(reconsume_flag) = EVal(True)


name: Comment_end_bang_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
==>
If Equal(EVal(reconsume_flag),EVal(False)) :
 then  If Equal(EVal(input_index),ELength(EVal(input))) :
  then   LVar(current_input_character) = EVal(eof)
  else   LVar(current_input_character) = EIdxof(EVal(input),EVal(input_index))
  LVar(input_index) = EPlus(EVal(input_index),ELength(EVal(next_input_character)))
 else  LVar(reconsume_flag) = EVal(False)
trans:
char: [45, 45] (U+002D HYPHEN-MINUS (-))
Append two U+002D HYPHEN-MINUS characters (-) and a U+0021 EXCLAMATION MARK character ( -EXC- ) to the comment token 's data
 =>  append_to ( U+002D_HYPHEN-MINUS_character_token [_] , comment_token [_] . data ) | append_to ( U+002D_HYPHEN-MINUS_character_token [_] , comment_token [_] . data ) | append_to ( U+0021_EXCLAMATION_MARK_character_token [_] , comment_token [_] . data ) 
==>
LAtt(LVar(current_token),Att1(A1Var(data),ANone)) = ECons(EAtt1(EVal(current_token),Att1(A1Var(data),ANone)),EVal(U+002D_HYPHEN-MINUS_character_token))
LAtt(LVar(current_token),Att1(A1Var(data),ANone)) = ECons(EAtt1(EVal(current_token),Att1(A1Var(data),ANone)),EVal(U+002D_HYPHEN-MINUS_character_token))
LAtt(LVar(current_token),Att1(A1Var(data),ANone)) = ECons(EAtt1(EVal(current_token),Att1(A1Var(data),ANone)),EVal(U+0021_EXCLAMATION_MARK_character_token))
Switch to the Comment_end_dash_state
 =>  switch_to ( Comment_end_dash_state [_] ) 
==>
LVar(state) = EVal(Comment_end_dash_state)
char: [62, 62] (U+003E GREATER-THAN SIGN (&gt;))
This is an incorrectly-closed-comment parse error
 =>  this_is_parse_error ( incorrectly-closed-comment_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(incorrectly-closed-comment_parse_error))
Switch to the Data_state
 =>  switch_to ( Data_state [_] ) 
==>
LVar(state) = EVal(Data_state)
Emit the comment token
 =>  emit ( comment_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(current_token))
char: [-1, -1] (EOF)
This is an eof-in-comment parse error
 =>  this_is_parse_error ( eof-in-comment_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(eof-in-comment_parse_error))
Emit the comment token
 =>  emit ( comment_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(current_token))
Emit an end-of-file token
 =>  emit ( end-of-file_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(end-of-file_token))
char: [-1, 65535] (Anything else)
Append two U+002D HYPHEN-MINUS characters (-) and a U+0021 EXCLAMATION MARK character ( ! ) to the comment token 's data
 =>  append_to ( U+002D_HYPHEN-MINUS_character_token [_] , comment_token [_] . data ) | append_to ( U+002D_HYPHEN-MINUS_character_token [_] , comment_token [_] . data ) | append_to ( U+0021_EXCLAMATION_MARK_character_token [_] , comment_token [_] . data ) 
==>
LAtt(LVar(current_token),Att1(A1Var(data),ANone)) = ECons(EAtt1(EVal(current_token),Att1(A1Var(data),ANone)),EVal(U+002D_HYPHEN-MINUS_character_token))
LAtt(LVar(current_token),Att1(A1Var(data),ANone)) = ECons(EAtt1(EVal(current_token),Att1(A1Var(data),ANone)),EVal(U+002D_HYPHEN-MINUS_character_token))
LAtt(LVar(current_token),Att1(A1Var(data),ANone)) = ECons(EAtt1(EVal(current_token),Att1(A1Var(data),ANone)),EVal(U+0021_EXCLAMATION_MARK_character_token))
Reconsume in the Comment_state
 =>  reconsume_in ( Comment_state [_] ) 
==>
LVar(state) = EVal(Comment_state)
LVar(reconsume_flag) = EVal(True)


name: DOCTYPE_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
==>
If Equal(EVal(reconsume_flag),EVal(False)) :
 then  If Equal(EVal(input_index),ELength(EVal(input))) :
  then   LVar(current_input_character) = EVal(eof)
  else   LVar(current_input_character) = EIdxof(EVal(input),EVal(input_index))
  LVar(input_index) = EPlus(EVal(input_index),ELength(EVal(next_input_character)))
 else  LVar(reconsume_flag) = EVal(False)
trans:
char: [9, 9] (U+0009 CHARACTER TABULATION (tab))
Switch to the Before_DOCTYPE_name_state
 =>  switch_to ( Before_DOCTYPE_name_state [_] ) 
==>
LVar(state) = EVal(Before_DOCTYPE_name_state)
char: [10, 10] (U+000A LINE FEED (LF))
Switch to the Before_DOCTYPE_name_state
 =>  switch_to ( Before_DOCTYPE_name_state [_] ) 
==>
LVar(state) = EVal(Before_DOCTYPE_name_state)
char: [12, 12] (U+000C FORM FEED (FF))
Switch to the Before_DOCTYPE_name_state
 =>  switch_to ( Before_DOCTYPE_name_state [_] ) 
==>
LVar(state) = EVal(Before_DOCTYPE_name_state)
char: [32, 32] (U+0020 SPACE)
Switch to the Before_DOCTYPE_name_state
 =>  switch_to ( Before_DOCTYPE_name_state [_] ) 
==>
LVar(state) = EVal(Before_DOCTYPE_name_state)
char: [62, 62] (U+003E GREATER-THAN SIGN (&gt;))
Reconsume in the Before_DOCTYPE_name_state
 =>  reconsume_in ( Before_DOCTYPE_name_state [_] ) 
==>
LVar(state) = EVal(Before_DOCTYPE_name_state)
LVar(reconsume_flag) = EVal(True)
char: [-1, -1] (EOF)
This is an eof-in-doctype parse error
 =>  this_is_parse_error ( eof-in-doctype_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(eof-in-doctype_parse_error))
Create a new DOCTYPE token [0]
 =>  create ( DOCTYPE_token [0] ) 
==>
LVar(x0) = create EVal(DOCTYPE_token)
LVar(current_token) <- EVal(x0)
Set a new DOCTYPE token [0] force-quirks flag to on
 =>  set_to ( DOCTYPE_token [0] . force-quirks_flag , on [_] ) 
==>
LAtt(LVar(x0),Att1(A1Var(force-quirks_flag),ANone)) = EVal(on)
Emit a new DOCTYPE token [0]
 =>  emit ( DOCTYPE_token [0] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(x0))
Emit an end-of-file token
 =>  emit ( end-of-file_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(end-of-file_token))
char: [-1, 65535] (Anything else)
This is a missing-whitespace-before-doctype-name parse error
 =>  this_is_parse_error ( missing-whitespace-before-doctype-name_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(missing-whitespace-before-doctype-name_parse_error))
Reconsume in the Before_DOCTYPE_name_state
 =>  reconsume_in ( Before_DOCTYPE_name_state [_] ) 
==>
LVar(state) = EVal(Before_DOCTYPE_name_state)
LVar(reconsume_flag) = EVal(True)


name: Before_DOCTYPE_name_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
==>
If Equal(EVal(reconsume_flag),EVal(False)) :
 then  If Equal(EVal(input_index),ELength(EVal(input))) :
  then   LVar(current_input_character) = EVal(eof)
  else   LVar(current_input_character) = EIdxof(EVal(input),EVal(input_index))
  LVar(input_index) = EPlus(EVal(input_index),ELength(EVal(next_input_character)))
 else  LVar(reconsume_flag) = EVal(False)
trans:
char: [9, 9] (U+0009 CHARACTER TABULATION (tab))
Ignore the character
 =>  ignore_the_character 
==>
Skip
char: [10, 10] (U+000A LINE FEED (LF))
Ignore the character
 =>  ignore_the_character 
==>
Skip
char: [12, 12] (U+000C FORM FEED (FF))
Ignore the character
 =>  ignore_the_character 
==>
Skip
char: [32, 32] (U+0020 SPACE)
Ignore the character
 =>  ignore_the_character 
==>
Skip
char: [65, 90] (ASCII upper alpha)
Create a new DOCTYPE token [0]
 =>  create ( DOCTYPE_token [0] ) 
==>
LVar(x0) = create EVal(DOCTYPE_token)
LVar(current_token) <- EVal(x0)
Set a new DOCTYPE token [0] name to the lowercase version of the current input character [1] ( add 0x0020 to the current input character [1] code point 
 =>  set_to ( DOCTYPE_token [0] . name , current_input_character [1] . lowercase_version ) 
==>
LAtt(LVar(x0),Att1(A1Var(name),ANone)) = EAtt2(EVal(current_input_character),A2Var(lowercase_version))
Switch to the DOCTYPE_name_state
 =>  switch_to ( DOCTYPE_name_state [_] ) 
==>
LVar(state) = EVal(DOCTYPE_name_state)
char: [0, 0] (U+0000 NULL)
This is an unexpected-null-character parse error
 =>  this_is_parse_error ( unexpected-null-character_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(unexpected-null-character_parse_error))
Create a new DOCTYPE token [0]
 =>  create ( DOCTYPE_token [0] ) 
==>
LVar(x0) = create EVal(DOCTYPE_token)
LVar(current_token) <- EVal(x0)
Set a new DOCTYPE token [0] name to a U+FFFD REPLACEMENT CHARACTER character
 =>  set_to ( DOCTYPE_token [0] . name , U+FFFD_REPLACEMENT_CHARACTER_character_token [_] ) 
==>
LAtt(LVar(x0),Att1(A1Var(name),ANone)) = EVal(U+FFFD_REPLACEMENT_CHARACTER_character_token)
Switch to the DOCTYPE_name_state
 =>  switch_to ( DOCTYPE_name_state [_] ) 
==>
LVar(state) = EVal(DOCTYPE_name_state)
char: [62, 62] (U+003E GREATER-THAN SIGN (&gt;))
This is a missing-doctype-name parse error
 =>  this_is_parse_error ( missing-doctype-name_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(missing-doctype-name_parse_error))
Create a new DOCTYPE token [0]
 =>  create ( DOCTYPE_token [0] ) 
==>
LVar(x0) = create EVal(DOCTYPE_token)
LVar(current_token) <- EVal(x0)
Set a new DOCTYPE token [0] force-quirks flag to on
 =>  set_to ( DOCTYPE_token [0] . force-quirks_flag , on [_] ) 
==>
LAtt(LVar(x0),Att1(A1Var(force-quirks_flag),ANone)) = EVal(on)
Switch to the Data_state
 =>  switch_to ( Data_state [_] ) 
==>
LVar(state) = EVal(Data_state)
Emit a new DOCTYPE token [0]
 =>  emit ( DOCTYPE_token [0] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(x0))
char: [-1, -1] (EOF)
This is an eof-in-doctype parse error
 =>  this_is_parse_error ( eof-in-doctype_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(eof-in-doctype_parse_error))
Create a new DOCTYPE token [0]
 =>  create ( DOCTYPE_token [0] ) 
==>
LVar(x0) = create EVal(DOCTYPE_token)
LVar(current_token) <- EVal(x0)
Set a new DOCTYPE token [0]   force-quirks flag to on
 =>  set_to ( DOCTYPE_token [0] . force-quirks_flag , on [_] ) 
==>
LAtt(LVar(x0),Att1(A1Var(force-quirks_flag),ANone)) = EVal(on)
Emit a new DOCTYPE token [0]
 =>  emit ( DOCTYPE_token [0] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(x0))
Emit an end-of-file token
 =>  emit ( end-of-file_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(end-of-file_token))
char: [-1, 65535] (Anything else)
Create a new DOCTYPE token [0]
 =>  create ( DOCTYPE_token [0] ) 
==>
LVar(x0) = create EVal(DOCTYPE_token)
LVar(current_token) <- EVal(x0)
Set a new DOCTYPE token [0] name to the current input character
 =>  set_to ( DOCTYPE_token [0] . name , current_input_character [_] ) 
==>
LAtt(LVar(x0),Att1(A1Var(name),ANone)) = EVal(current_input_character)
Switch to the DOCTYPE_name_state
 =>  switch_to ( DOCTYPE_name_state [_] ) 
==>
LVar(state) = EVal(DOCTYPE_name_state)


name: DOCTYPE_name_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
==>
If Equal(EVal(reconsume_flag),EVal(False)) :
 then  If Equal(EVal(input_index),ELength(EVal(input))) :
  then   LVar(current_input_character) = EVal(eof)
  else   LVar(current_input_character) = EIdxof(EVal(input),EVal(input_index))
  LVar(input_index) = EPlus(EVal(input_index),ELength(EVal(next_input_character)))
 else  LVar(reconsume_flag) = EVal(False)
trans:
char: [9, 9] (U+0009 CHARACTER TABULATION (tab))
Switch to the After_DOCTYPE_name_state
 =>  switch_to ( After_DOCTYPE_name_state [_] ) 
==>
LVar(state) = EVal(After_DOCTYPE_name_state)
char: [10, 10] (U+000A LINE FEED (LF))
Switch to the After_DOCTYPE_name_state
 =>  switch_to ( After_DOCTYPE_name_state [_] ) 
==>
LVar(state) = EVal(After_DOCTYPE_name_state)
char: [12, 12] (U+000C FORM FEED (FF))
Switch to the After_DOCTYPE_name_state
 =>  switch_to ( After_DOCTYPE_name_state [_] ) 
==>
LVar(state) = EVal(After_DOCTYPE_name_state)
char: [32, 32] (U+0020 SPACE)
Switch to the After_DOCTYPE_name_state
 =>  switch_to ( After_DOCTYPE_name_state [_] ) 
==>
LVar(state) = EVal(After_DOCTYPE_name_state)
char: [62, 62] (U+003E GREATER-THAN SIGN (&gt;))
Switch to the Data_state
 =>  switch_to ( Data_state [_] ) 
==>
LVar(state) = EVal(Data_state)
Emit the current DOCTYPE token
 =>  emit ( DOCTYPE_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(current_token))
char: [65, 90] (ASCII upper alpha)
Append the lowercase version of the current input character [0] ( add 0x0020 to the current input character [0] code point ) to the current DOCTYPE token 's name
 =>  append_to ( current_input_character [_] . lowercase_version , DOCTYPE_token [_] . name ) 
==>
LAtt(LVar(current_token),Att1(A1Var(name),ANone)) = ECons(EAtt1(EVal(current_token),Att1(A1Var(name),ANone)),EAtt2(EVal(current_input_character),A2Var(lowercase_version)))
char: [0, 0] (U+0000 NULL)
This is an unexpected-null-character parse error
 =>  this_is_parse_error ( unexpected-null-character_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(unexpected-null-character_parse_error))
Append a U+FFFD REPLACEMENT CHARACTER character to the current DOCTYPE token 's name
 =>  append_to ( U+FFFD_REPLACEMENT_CHARACTER_character_token [_] , DOCTYPE_token [_] . name ) 
==>
LAtt(LVar(current_token),Att1(A1Var(name),ANone)) = ECons(EAtt1(EVal(current_token),Att1(A1Var(name),ANone)),EVal(U+FFFD_REPLACEMENT_CHARACTER_character_token))
char: [-1, -1] (EOF)
This is an eof-in-doctype parse error
 =>  this_is_parse_error ( eof-in-doctype_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(eof-in-doctype_parse_error))
Set the DOCTYPE token 's [0] force-quirks flag to on
 =>  set_to ( DOCTYPE_token [0] . force-quirks_flag , on [_] ) 
==>
LAtt(LVar(x0),Att1(A1Var(force-quirks_flag),ANone)) = EVal(on)
Emit the DOCTYPE token 's [0]
 =>  emit ( current_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(current_token))
Emit an end-of-file token
 =>  emit ( end-of-file_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(end-of-file_token))
char: [-1, 65535] (Anything else)
Append the current input character to the current DOCTYPE token 's name
 =>  append_to ( current_input_character [_] , DOCTYPE_token [_] . name ) 
==>
LAtt(LVar(current_token),Att1(A1Var(name),ANone)) = ECons(EAtt1(EVal(current_token),Att1(A1Var(name),ANone)),EVal(current_input_character))


name: After_DOCTYPE_public_keyword_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
==>
If Equal(EVal(reconsume_flag),EVal(False)) :
 then  If Equal(EVal(input_index),ELength(EVal(input))) :
  then   LVar(current_input_character) = EVal(eof)
  else   LVar(current_input_character) = EIdxof(EVal(input),EVal(input_index))
  LVar(input_index) = EPlus(EVal(input_index),ELength(EVal(next_input_character)))
 else  LVar(reconsume_flag) = EVal(False)
trans:
char: [9, 9] (U+0009 CHARACTER TABULATION (tab))
Switch to the Before_DOCTYPE_public_identifier_state
 =>  switch_to ( Before_DOCTYPE_public_identifier_state [_] ) 
==>
LVar(state) = EVal(Before_DOCTYPE_public_identifier_state)
char: [10, 10] (U+000A LINE FEED (LF))
Switch to the Before_DOCTYPE_public_identifier_state
 =>  switch_to ( Before_DOCTYPE_public_identifier_state [_] ) 
==>
LVar(state) = EVal(Before_DOCTYPE_public_identifier_state)
char: [12, 12] (U+000C FORM FEED (FF))
Switch to the Before_DOCTYPE_public_identifier_state
 =>  switch_to ( Before_DOCTYPE_public_identifier_state [_] ) 
==>
LVar(state) = EVal(Before_DOCTYPE_public_identifier_state)
char: [32, 32] (U+0020 SPACE)
Switch to the Before_DOCTYPE_public_identifier_state
 =>  switch_to ( Before_DOCTYPE_public_identifier_state [_] ) 
==>
LVar(state) = EVal(Before_DOCTYPE_public_identifier_state)
char: [34, 34] (U+0022 QUOTATION MARK ("))
This is a missing-whitespace-after-doctype-public-keyword parse error
 =>  this_is_parse_error ( missing-whitespace-after-doctype-public-keyword_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(missing-whitespace-after-doctype-public-keyword_parse_error))
Set the DOCTYPE token 's public identifier to the empty string ( not missing ) , then switch to the DOCTYPE_public_identifier_double_quoted_state
 =>  set_to ( DOCTYPE_token [_] . public_identifier , empty_string [_] ) | switch_to ( DOCTYPE_public_identifier_double_quoted_state [_] ) 
==>
LAtt(LVar(current_token),Att1(A1Var(public_identifier),ANone)) = EVal(empty_string)
LVar(state) = EVal(DOCTYPE_public_identifier_double_quoted_state)
char: [39, 39] (U+0027 APOSTROPHE ('))
This is a missing-whitespace-after-doctype-public-keyword parse error
 =>  this_is_parse_error ( missing-whitespace-after-doctype-public-keyword_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(missing-whitespace-after-doctype-public-keyword_parse_error))
Set the DOCTYPE token 's public identifier to the empty string ( not missing ) , then switch to the DOCTYPE_public_identifier_single_quoted_state
 =>  set_to ( DOCTYPE_token [_] . public_identifier , empty_string [_] ) | switch_to ( DOCTYPE_public_identifier_single_quoted_state [_] ) 
==>
LAtt(LVar(current_token),Att1(A1Var(public_identifier),ANone)) = EVal(empty_string)
LVar(state) = EVal(DOCTYPE_public_identifier_single_quoted_state)
char: [62, 62] (U+003E GREATER-THAN SIGN (&gt;))
This is a missing-doctype-public-identifier parse error
 =>  this_is_parse_error ( missing-doctype-public-identifier_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(missing-doctype-public-identifier_parse_error))
Set the DOCTYPE token 's [0] force-quirks flag to on
 =>  set_to ( DOCTYPE_token [0] . force-quirks_flag , on [_] ) 
==>
LAtt(LVar(x0),Att1(A1Var(force-quirks_flag),ANone)) = EVal(on)
Switch to the Data_state
 =>  switch_to ( Data_state [_] ) 
==>
LVar(state) = EVal(Data_state)
Emit the DOCTYPE token 's [0]
 =>  emit ( current_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(current_token))
char: [-1, -1] (EOF)
This is an eof-in-doctype parse error
 =>  this_is_parse_error ( eof-in-doctype_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(eof-in-doctype_parse_error))
Set the DOCTYPE token 's [0] force-quirks flag to on
 =>  set_to ( DOCTYPE_token [0] . force-quirks_flag , on [_] ) 
==>
LAtt(LVar(x0),Att1(A1Var(force-quirks_flag),ANone)) = EVal(on)
Emit the DOCTYPE token 's [0]
 =>  emit ( current_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(current_token))
Emit an end-of-file token
 =>  emit ( end-of-file_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(end-of-file_token))
char: [-1, 65535] (Anything else)
This is a missing-quote-before-doctype-public-identifier parse error
 =>  this_is_parse_error ( missing-quote-before-doctype-public-identifier_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(missing-quote-before-doctype-public-identifier_parse_error))
Set the DOCTYPE token 's force-quirks flag to on
 =>  set_to ( DOCTYPE_token [_] . force-quirks_flag , on [_] ) 
==>
LAtt(LVar(current_token),Att1(A1Var(force-quirks_flag),ANone)) = EVal(on)
Reconsume in the Bogus_DOCTYPE_state
 =>  reconsume_in ( Bogus_DOCTYPE_state [_] ) 
==>
LVar(state) = EVal(Bogus_DOCTYPE_state)
LVar(reconsume_flag) = EVal(True)


name: Before_DOCTYPE_public_identifier_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
==>
If Equal(EVal(reconsume_flag),EVal(False)) :
 then  If Equal(EVal(input_index),ELength(EVal(input))) :
  then   LVar(current_input_character) = EVal(eof)
  else   LVar(current_input_character) = EIdxof(EVal(input),EVal(input_index))
  LVar(input_index) = EPlus(EVal(input_index),ELength(EVal(next_input_character)))
 else  LVar(reconsume_flag) = EVal(False)
trans:
char: [9, 9] (U+0009 CHARACTER TABULATION (tab))
Ignore the character
 =>  ignore_the_character 
==>
Skip
char: [10, 10] (U+000A LINE FEED (LF))
Ignore the character
 =>  ignore_the_character 
==>
Skip
char: [12, 12] (U+000C FORM FEED (FF))
Ignore the character
 =>  ignore_the_character 
==>
Skip
char: [32, 32] (U+0020 SPACE)
Ignore the character
 =>  ignore_the_character 
==>
Skip
char: [34, 34] (U+0022 QUOTATION MARK ("))
Set the DOCTYPE token 's public identifier to the empty string ( not missing ) , then switch to the DOCTYPE_public_identifier_double_quoted_state
 =>  set_to ( DOCTYPE_token [_] . public_identifier , empty_string [_] ) | switch_to ( DOCTYPE_public_identifier_double_quoted_state [_] ) 
==>
LAtt(LVar(current_token),Att1(A1Var(public_identifier),ANone)) = EVal(empty_string)
LVar(state) = EVal(DOCTYPE_public_identifier_double_quoted_state)
char: [39, 39] (U+0027 APOSTROPHE ('))
Set the DOCTYPE token 's public identifier to the empty string ( not missing ) , then switch to the DOCTYPE_public_identifier_single_quoted_state
 =>  set_to ( DOCTYPE_token [_] . public_identifier , empty_string [_] ) | switch_to ( DOCTYPE_public_identifier_single_quoted_state [_] ) 
==>
LAtt(LVar(current_token),Att1(A1Var(public_identifier),ANone)) = EVal(empty_string)
LVar(state) = EVal(DOCTYPE_public_identifier_single_quoted_state)
char: [62, 62] (U+003E GREATER-THAN SIGN (&gt;))
This is a missing-doctype-public-identifier parse error
 =>  this_is_parse_error ( missing-doctype-public-identifier_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(missing-doctype-public-identifier_parse_error))
Set the DOCTYPE token 's [0] force-quirks flag to on
 =>  set_to ( DOCTYPE_token [0] . force-quirks_flag , on [_] ) 
==>
LAtt(LVar(x0),Att1(A1Var(force-quirks_flag),ANone)) = EVal(on)
Switch to the Data_state
 =>  switch_to ( Data_state [_] ) 
==>
LVar(state) = EVal(Data_state)
Emit the DOCTYPE token 's [0]
 =>  emit ( current_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(current_token))
char: [-1, -1] (EOF)
This is an eof-in-doctype parse error
 =>  this_is_parse_error ( eof-in-doctype_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(eof-in-doctype_parse_error))
Set the DOCTYPE token 's [0] force-quirks flag to on
 =>  set_to ( DOCTYPE_token [0] . force-quirks_flag , on [_] ) 
==>
LAtt(LVar(x0),Att1(A1Var(force-quirks_flag),ANone)) = EVal(on)
Emit the DOCTYPE token 's [0]
 =>  emit ( current_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(current_token))
Emit an end-of-file token
 =>  emit ( end-of-file_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(end-of-file_token))
char: [-1, 65535] (Anything else)
This is a missing-quote-before-doctype-public-identifier parse error
 =>  this_is_parse_error ( missing-quote-before-doctype-public-identifier_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(missing-quote-before-doctype-public-identifier_parse_error))
Set the DOCTYPE token 's force-quirks flag to on
 =>  set_to ( DOCTYPE_token [_] . force-quirks_flag , on [_] ) 
==>
LAtt(LVar(current_token),Att1(A1Var(force-quirks_flag),ANone)) = EVal(on)
Reconsume in the Bogus_DOCTYPE_state
 =>  reconsume_in ( Bogus_DOCTYPE_state [_] ) 
==>
LVar(state) = EVal(Bogus_DOCTYPE_state)
LVar(reconsume_flag) = EVal(True)


name: DOCTYPE_public_identifier_double_quoted_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
==>
If Equal(EVal(reconsume_flag),EVal(False)) :
 then  If Equal(EVal(input_index),ELength(EVal(input))) :
  then   LVar(current_input_character) = EVal(eof)
  else   LVar(current_input_character) = EIdxof(EVal(input),EVal(input_index))
  LVar(input_index) = EPlus(EVal(input_index),ELength(EVal(next_input_character)))
 else  LVar(reconsume_flag) = EVal(False)
trans:
char: [34, 34] (U+0022 QUOTATION MARK ("))
Switch to the After_DOCTYPE_public_identifier_state
 =>  switch_to ( After_DOCTYPE_public_identifier_state [_] ) 
==>
LVar(state) = EVal(After_DOCTYPE_public_identifier_state)
char: [0, 0] (U+0000 NULL)
This is an unexpected-null-character parse error
 =>  this_is_parse_error ( unexpected-null-character_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(unexpected-null-character_parse_error))
Append a U+FFFD REPLACEMENT CHARACTER character to the current DOCTYPE token 's public identifier
 =>  append_to ( U+FFFD_REPLACEMENT_CHARACTER_character_token [_] , DOCTYPE_token [_] . public_identifier ) 
==>
LAtt(LVar(current_token),Att1(A1Var(public_identifier),ANone)) = ECons(EAtt1(EVal(current_token),Att1(A1Var(public_identifier),ANone)),EVal(U+FFFD_REPLACEMENT_CHARACTER_character_token))
char: [62, 62] (U+003E GREATER-THAN SIGN (&gt;))
This is an abrupt-doctype-public-identifier parse error
 =>  this_is_parse_error ( abrupt-doctype-public-identifier_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(abrupt-doctype-public-identifier_parse_error))
Set the DOCTYPE token 's [0] force-quirks flag to on
 =>  set_to ( DOCTYPE_token [0] . force-quirks_flag , on [_] ) 
==>
LAtt(LVar(x0),Att1(A1Var(force-quirks_flag),ANone)) = EVal(on)
Switch to the Data_state
 =>  switch_to ( Data_state [_] ) 
==>
LVar(state) = EVal(Data_state)
Emit the DOCTYPE token 's [0]
 =>  emit ( current_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(current_token))
char: [-1, -1] (EOF)
This is an eof-in-doctype parse error
 =>  this_is_parse_error ( eof-in-doctype_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(eof-in-doctype_parse_error))
Set the DOCTYPE token 's [0] force-quirks flag to on
 =>  set_to ( DOCTYPE_token [0] . force-quirks_flag , on [_] ) 
==>
LAtt(LVar(x0),Att1(A1Var(force-quirks_flag),ANone)) = EVal(on)
Emit the DOCTYPE token 's [0]
 =>  emit ( current_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(current_token))
Emit an end-of-file token
 =>  emit ( end-of-file_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(end-of-file_token))
char: [-1, 65535] (Anything else)
Append the current input character to the current DOCTYPE token 's public identifier
 =>  append_to ( current_input_character [_] , DOCTYPE_token [_] . public_identifier ) 
==>
LAtt(LVar(current_token),Att1(A1Var(public_identifier),ANone)) = ECons(EAtt1(EVal(current_token),Att1(A1Var(public_identifier),ANone)),EVal(current_input_character))


name: DOCTYPE_public_identifier_single_quoted_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
==>
If Equal(EVal(reconsume_flag),EVal(False)) :
 then  If Equal(EVal(input_index),ELength(EVal(input))) :
  then   LVar(current_input_character) = EVal(eof)
  else   LVar(current_input_character) = EIdxof(EVal(input),EVal(input_index))
  LVar(input_index) = EPlus(EVal(input_index),ELength(EVal(next_input_character)))
 else  LVar(reconsume_flag) = EVal(False)
trans:
char: [39, 39] (U+0027 APOSTROPHE ('))
Switch to the After_DOCTYPE_public_identifier_state
 =>  switch_to ( After_DOCTYPE_public_identifier_state [_] ) 
==>
LVar(state) = EVal(After_DOCTYPE_public_identifier_state)
char: [0, 0] (U+0000 NULL)
This is an unexpected-null-character parse error
 =>  this_is_parse_error ( unexpected-null-character_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(unexpected-null-character_parse_error))
Append a U+FFFD REPLACEMENT CHARACTER character to the current DOCTYPE token 's public identifier
 =>  append_to ( U+FFFD_REPLACEMENT_CHARACTER_character_token [_] , DOCTYPE_token [_] . public_identifier ) 
==>
LAtt(LVar(current_token),Att1(A1Var(public_identifier),ANone)) = ECons(EAtt1(EVal(current_token),Att1(A1Var(public_identifier),ANone)),EVal(U+FFFD_REPLACEMENT_CHARACTER_character_token))
char: [62, 62] (U+003E GREATER-THAN SIGN (&gt;))
This is an abrupt-doctype-public-identifier parse error
 =>  this_is_parse_error ( abrupt-doctype-public-identifier_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(abrupt-doctype-public-identifier_parse_error))
Set the DOCTYPE token 's [0] force-quirks flag to on
 =>  set_to ( DOCTYPE_token [0] . force-quirks_flag , on [_] ) 
==>
LAtt(LVar(x0),Att1(A1Var(force-quirks_flag),ANone)) = EVal(on)
Switch to the Data_state
 =>  switch_to ( Data_state [_] ) 
==>
LVar(state) = EVal(Data_state)
Emit the DOCTYPE token 's [0]
 =>  emit ( current_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(current_token))
char: [-1, -1] (EOF)
This is an eof-in-doctype parse error
 =>  this_is_parse_error ( eof-in-doctype_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(eof-in-doctype_parse_error))
Set the DOCTYPE token 's [0] force-quirks flag to on
 =>  set_to ( DOCTYPE_token [0] . force-quirks_flag , on [_] ) 
==>
LAtt(LVar(x0),Att1(A1Var(force-quirks_flag),ANone)) = EVal(on)
Emit the DOCTYPE token 's [0]
 =>  emit ( current_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(current_token))
Emit an end-of-file token
 =>  emit ( end-of-file_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(end-of-file_token))
char: [-1, 65535] (Anything else)
Append the current input character to the current DOCTYPE token 's public identifier
 =>  append_to ( current_input_character [_] , DOCTYPE_token [_] . public_identifier ) 
==>
LAtt(LVar(current_token),Att1(A1Var(public_identifier),ANone)) = ECons(EAtt1(EVal(current_token),Att1(A1Var(public_identifier),ANone)),EVal(current_input_character))


name: After_DOCTYPE_public_identifier_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
==>
If Equal(EVal(reconsume_flag),EVal(False)) :
 then  If Equal(EVal(input_index),ELength(EVal(input))) :
  then   LVar(current_input_character) = EVal(eof)
  else   LVar(current_input_character) = EIdxof(EVal(input),EVal(input_index))
  LVar(input_index) = EPlus(EVal(input_index),ELength(EVal(next_input_character)))
 else  LVar(reconsume_flag) = EVal(False)
trans:
char: [9, 9] (U+0009 CHARACTER TABULATION (tab))
Switch to the Between_DOCTYPE_public_and_system_identifiers_state
 =>  switch_to ( Between_DOCTYPE_public_and_system_identifiers_state [_] ) 
==>
LVar(state) = EVal(Between_DOCTYPE_public_and_system_identifiers_state)
char: [10, 10] (U+000A LINE FEED (LF))
Switch to the Between_DOCTYPE_public_and_system_identifiers_state
 =>  switch_to ( Between_DOCTYPE_public_and_system_identifiers_state [_] ) 
==>
LVar(state) = EVal(Between_DOCTYPE_public_and_system_identifiers_state)
char: [12, 12] (U+000C FORM FEED (FF))
Switch to the Between_DOCTYPE_public_and_system_identifiers_state
 =>  switch_to ( Between_DOCTYPE_public_and_system_identifiers_state [_] ) 
==>
LVar(state) = EVal(Between_DOCTYPE_public_and_system_identifiers_state)
char: [32, 32] (U+0020 SPACE)
Switch to the Between_DOCTYPE_public_and_system_identifiers_state
 =>  switch_to ( Between_DOCTYPE_public_and_system_identifiers_state [_] ) 
==>
LVar(state) = EVal(Between_DOCTYPE_public_and_system_identifiers_state)
char: [62, 62] (U+003E GREATER-THAN SIGN (&gt;))
Switch to the Data_state
 =>  switch_to ( Data_state [_] ) 
==>
LVar(state) = EVal(Data_state)
Emit the current DOCTYPE token
 =>  emit ( DOCTYPE_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(current_token))
char: [34, 34] (U+0022 QUOTATION MARK ("))
This is a missing-whitespace-between-doctype-public-and-system-identifiers parse error
 =>  this_is_parse_error ( missing-whitespace-between-doctype-public-and-system-identifiers_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(missing-whitespace-between-doctype-public-and-system-identifiers_parse_error))
Set the DOCTYPE token 's system identifier to the empty string ( not missing ) , then switch to the DOCTYPE_system_identifier_double_quoted_state
 =>  set_to ( DOCTYPE_token [_] . system_identifier , empty_string [_] ) | switch_to ( DOCTYPE_system_identifier_double_quoted_state [_] ) 
==>
LAtt(LVar(current_token),Att1(A1Var(system_identifier),ANone)) = EVal(empty_string)
LVar(state) = EVal(DOCTYPE_system_identifier_double_quoted_state)
char: [39, 39] (U+0027 APOSTROPHE ('))
This is a missing-whitespace-between-doctype-public-and-system-identifiers parse error
 =>  this_is_parse_error ( missing-whitespace-between-doctype-public-and-system-identifiers_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(missing-whitespace-between-doctype-public-and-system-identifiers_parse_error))
Set the DOCTYPE token 's system identifier to the empty string ( not missing ) , then switch to the DOCTYPE_system_identifier_single_quoted_state
 =>  set_to ( DOCTYPE_token [_] . system_identifier , empty_string [_] ) | switch_to ( DOCTYPE_system_identifier_single_quoted_state [_] ) 
==>
LAtt(LVar(current_token),Att1(A1Var(system_identifier),ANone)) = EVal(empty_string)
LVar(state) = EVal(DOCTYPE_system_identifier_single_quoted_state)
char: [-1, -1] (EOF)
This is an eof-in-doctype parse error
 =>  this_is_parse_error ( eof-in-doctype_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(eof-in-doctype_parse_error))
Set the DOCTYPE token 's [0] force-quirks flag to on
 =>  set_to ( DOCTYPE_token [0] . force-quirks_flag , on [_] ) 
==>
LAtt(LVar(x0),Att1(A1Var(force-quirks_flag),ANone)) = EVal(on)
Emit the DOCTYPE token 's [0]
 =>  emit ( current_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(current_token))
Emit an end-of-file token
 =>  emit ( end-of-file_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(end-of-file_token))
char: [-1, 65535] (Anything else)
This is a missing-quote-before-doctype-system-identifier parse error
 =>  this_is_parse_error ( missing-quote-before-doctype-system-identifier_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(missing-quote-before-doctype-system-identifier_parse_error))
Set the DOCTYPE token 's force-quirks flag to on
 =>  set_to ( DOCTYPE_token [_] . force-quirks_flag , on [_] ) 
==>
LAtt(LVar(current_token),Att1(A1Var(force-quirks_flag),ANone)) = EVal(on)
Reconsume in the Bogus_DOCTYPE_state
 =>  reconsume_in ( Bogus_DOCTYPE_state [_] ) 
==>
LVar(state) = EVal(Bogus_DOCTYPE_state)
LVar(reconsume_flag) = EVal(True)


name: Between_DOCTYPE_public_and_system_identifiers_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
==>
If Equal(EVal(reconsume_flag),EVal(False)) :
 then  If Equal(EVal(input_index),ELength(EVal(input))) :
  then   LVar(current_input_character) = EVal(eof)
  else   LVar(current_input_character) = EIdxof(EVal(input),EVal(input_index))
  LVar(input_index) = EPlus(EVal(input_index),ELength(EVal(next_input_character)))
 else  LVar(reconsume_flag) = EVal(False)
trans:
char: [9, 9] (U+0009 CHARACTER TABULATION (tab))
Ignore the character
 =>  ignore_the_character 
==>
Skip
char: [10, 10] (U+000A LINE FEED (LF))
Ignore the character
 =>  ignore_the_character 
==>
Skip
char: [12, 12] (U+000C FORM FEED (FF))
Ignore the character
 =>  ignore_the_character 
==>
Skip
char: [32, 32] (U+0020 SPACE)
Ignore the character
 =>  ignore_the_character 
==>
Skip
char: [62, 62] (U+003E GREATER-THAN SIGN (&gt;))
Switch to the Data_state
 =>  switch_to ( Data_state [_] ) 
==>
LVar(state) = EVal(Data_state)
Emit the current DOCTYPE token
 =>  emit ( DOCTYPE_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(current_token))
char: [34, 34] (U+0022 QUOTATION MARK ("))
Set the DOCTYPE token 's system identifier to the empty string ( not missing ) , then switch to the DOCTYPE_system_identifier_double_quoted_state
 =>  set_to ( DOCTYPE_token [_] . system_identifier , empty_string [_] ) | switch_to ( DOCTYPE_system_identifier_double_quoted_state [_] ) 
==>
LAtt(LVar(current_token),Att1(A1Var(system_identifier),ANone)) = EVal(empty_string)
LVar(state) = EVal(DOCTYPE_system_identifier_double_quoted_state)
char: [39, 39] (U+0027 APOSTROPHE ('))
Set the DOCTYPE token 's system identifier to the empty string ( not missing ) , then switch to the DOCTYPE_system_identifier_single_quoted_state
 =>  set_to ( DOCTYPE_token [_] . system_identifier , empty_string [_] ) | switch_to ( DOCTYPE_system_identifier_single_quoted_state [_] ) 
==>
LAtt(LVar(current_token),Att1(A1Var(system_identifier),ANone)) = EVal(empty_string)
LVar(state) = EVal(DOCTYPE_system_identifier_single_quoted_state)
char: [-1, -1] (EOF)
This is an eof-in-doctype parse error
 =>  this_is_parse_error ( eof-in-doctype_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(eof-in-doctype_parse_error))
Set the DOCTYPE token 's [0] force-quirks flag to on
 =>  set_to ( DOCTYPE_token [0] . force-quirks_flag , on [_] ) 
==>
LAtt(LVar(x0),Att1(A1Var(force-quirks_flag),ANone)) = EVal(on)
Emit the DOCTYPE token 's [0]
 =>  emit ( current_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(current_token))
Emit an end-of-file token
 =>  emit ( end-of-file_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(end-of-file_token))
char: [-1, 65535] (Anything else)
This is a missing-quote-before-doctype-system-identifier parse error
 =>  this_is_parse_error ( missing-quote-before-doctype-system-identifier_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(missing-quote-before-doctype-system-identifier_parse_error))
Set the DOCTYPE token 's force-quirks flag to on
 =>  set_to ( DOCTYPE_token [_] . force-quirks_flag , on [_] ) 
==>
LAtt(LVar(current_token),Att1(A1Var(force-quirks_flag),ANone)) = EVal(on)
Reconsume in the Bogus_DOCTYPE_state
 =>  reconsume_in ( Bogus_DOCTYPE_state [_] ) 
==>
LVar(state) = EVal(Bogus_DOCTYPE_state)
LVar(reconsume_flag) = EVal(True)


name: After_DOCTYPE_system_keyword_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
==>
If Equal(EVal(reconsume_flag),EVal(False)) :
 then  If Equal(EVal(input_index),ELength(EVal(input))) :
  then   LVar(current_input_character) = EVal(eof)
  else   LVar(current_input_character) = EIdxof(EVal(input),EVal(input_index))
  LVar(input_index) = EPlus(EVal(input_index),ELength(EVal(next_input_character)))
 else  LVar(reconsume_flag) = EVal(False)
trans:
char: [9, 9] (U+0009 CHARACTER TABULATION (tab))
Switch to the Before_DOCTYPE_system_identifier_state
 =>  switch_to ( Before_DOCTYPE_system_identifier_state [_] ) 
==>
LVar(state) = EVal(Before_DOCTYPE_system_identifier_state)
char: [10, 10] (U+000A LINE FEED (LF))
Switch to the Before_DOCTYPE_system_identifier_state
 =>  switch_to ( Before_DOCTYPE_system_identifier_state [_] ) 
==>
LVar(state) = EVal(Before_DOCTYPE_system_identifier_state)
char: [12, 12] (U+000C FORM FEED (FF))
Switch to the Before_DOCTYPE_system_identifier_state
 =>  switch_to ( Before_DOCTYPE_system_identifier_state [_] ) 
==>
LVar(state) = EVal(Before_DOCTYPE_system_identifier_state)
char: [32, 32] (U+0020 SPACE)
Switch to the Before_DOCTYPE_system_identifier_state
 =>  switch_to ( Before_DOCTYPE_system_identifier_state [_] ) 
==>
LVar(state) = EVal(Before_DOCTYPE_system_identifier_state)
char: [34, 34] (U+0022 QUOTATION MARK ("))
This is a missing-whitespace-after-doctype-system-keyword parse error
 =>  this_is_parse_error ( missing-whitespace-after-doctype-system-keyword_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(missing-whitespace-after-doctype-system-keyword_parse_error))
Set the DOCTYPE token 's system identifier to the empty string ( not missing ) , then switch to the DOCTYPE_system_identifier_double_quoted_state
 =>  set_to ( DOCTYPE_token [_] . system_identifier , empty_string [_] ) | switch_to ( DOCTYPE_system_identifier_double_quoted_state [_] ) 
==>
LAtt(LVar(current_token),Att1(A1Var(system_identifier),ANone)) = EVal(empty_string)
LVar(state) = EVal(DOCTYPE_system_identifier_double_quoted_state)
char: [39, 39] (U+0027 APOSTROPHE ('))
This is a missing-whitespace-after-doctype-system-keyword parse error
 =>  this_is_parse_error ( missing-whitespace-after-doctype-system-keyword_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(missing-whitespace-after-doctype-system-keyword_parse_error))
Set the DOCTYPE token 's system identifier to the empty string ( not missing ) , then switch to the DOCTYPE_system_identifier_single_quoted_state
 =>  set_to ( DOCTYPE_token [_] . system_identifier , empty_string [_] ) | switch_to ( DOCTYPE_system_identifier_single_quoted_state [_] ) 
==>
LAtt(LVar(current_token),Att1(A1Var(system_identifier),ANone)) = EVal(empty_string)
LVar(state) = EVal(DOCTYPE_system_identifier_single_quoted_state)
char: [62, 62] (U+003E GREATER-THAN SIGN (&gt;))
This is a missing-doctype-system-identifier parse error
 =>  this_is_parse_error ( missing-doctype-system-identifier_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(missing-doctype-system-identifier_parse_error))
Set the DOCTYPE token 's [0] force-quirks flag to on
 =>  set_to ( DOCTYPE_token [0] . force-quirks_flag , on [_] ) 
==>
LAtt(LVar(x0),Att1(A1Var(force-quirks_flag),ANone)) = EVal(on)
Switch to the Data_state
 =>  switch_to ( Data_state [_] ) 
==>
LVar(state) = EVal(Data_state)
Emit the DOCTYPE token 's [0]
 =>  emit ( current_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(current_token))
char: [-1, -1] (EOF)
This is an eof-in-doctype parse error
 =>  this_is_parse_error ( eof-in-doctype_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(eof-in-doctype_parse_error))
Set the DOCTYPE token 's [0] force-quirks flag to on
 =>  set_to ( DOCTYPE_token [0] . force-quirks_flag , on [_] ) 
==>
LAtt(LVar(x0),Att1(A1Var(force-quirks_flag),ANone)) = EVal(on)
Emit the DOCTYPE token 's [0]
 =>  emit ( current_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(current_token))
Emit an end-of-file token
 =>  emit ( end-of-file_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(end-of-file_token))
char: [-1, 65535] (Anything else)
This is a missing-quote-before-doctype-system-identifier parse error
 =>  this_is_parse_error ( missing-quote-before-doctype-system-identifier_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(missing-quote-before-doctype-system-identifier_parse_error))
Set the DOCTYPE token 's force-quirks flag to on
 =>  set_to ( DOCTYPE_token [_] . force-quirks_flag , on [_] ) 
==>
LAtt(LVar(current_token),Att1(A1Var(force-quirks_flag),ANone)) = EVal(on)
Reconsume in the Bogus_DOCTYPE_state
 =>  reconsume_in ( Bogus_DOCTYPE_state [_] ) 
==>
LVar(state) = EVal(Bogus_DOCTYPE_state)
LVar(reconsume_flag) = EVal(True)


name: Before_DOCTYPE_system_identifier_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
==>
If Equal(EVal(reconsume_flag),EVal(False)) :
 then  If Equal(EVal(input_index),ELength(EVal(input))) :
  then   LVar(current_input_character) = EVal(eof)
  else   LVar(current_input_character) = EIdxof(EVal(input),EVal(input_index))
  LVar(input_index) = EPlus(EVal(input_index),ELength(EVal(next_input_character)))
 else  LVar(reconsume_flag) = EVal(False)
trans:
char: [9, 9] (U+0009 CHARACTER TABULATION (tab))
Ignore the character
 =>  ignore_the_character 
==>
Skip
char: [10, 10] (U+000A LINE FEED (LF))
Ignore the character
 =>  ignore_the_character 
==>
Skip
char: [12, 12] (U+000C FORM FEED (FF))
Ignore the character
 =>  ignore_the_character 
==>
Skip
char: [32, 32] (U+0020 SPACE)
Ignore the character
 =>  ignore_the_character 
==>
Skip
char: [34, 34] (U+0022 QUOTATION MARK ("))
Set the DOCTYPE token 's system identifier to the empty string ( not missing ) , then switch to the DOCTYPE_system_identifier_double_quoted_state
 =>  set_to ( DOCTYPE_token [_] . system_identifier , empty_string [_] ) | switch_to ( DOCTYPE_system_identifier_double_quoted_state [_] ) 
==>
LAtt(LVar(current_token),Att1(A1Var(system_identifier),ANone)) = EVal(empty_string)
LVar(state) = EVal(DOCTYPE_system_identifier_double_quoted_state)
char: [39, 39] (U+0027 APOSTROPHE ('))
Set the DOCTYPE token 's system identifier to the empty string ( not missing ) , then switch to the DOCTYPE_system_identifier_single_quoted_state
 =>  set_to ( DOCTYPE_token [_] . system_identifier , empty_string [_] ) | switch_to ( DOCTYPE_system_identifier_single_quoted_state [_] ) 
==>
LAtt(LVar(current_token),Att1(A1Var(system_identifier),ANone)) = EVal(empty_string)
LVar(state) = EVal(DOCTYPE_system_identifier_single_quoted_state)
char: [62, 62] (U+003E GREATER-THAN SIGN (&gt;))
This is a missing-doctype-system-identifier parse error
 =>  this_is_parse_error ( missing-doctype-system-identifier_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(missing-doctype-system-identifier_parse_error))
Set the DOCTYPE token 's [0] force-quirks flag to on
 =>  set_to ( DOCTYPE_token [0] . force-quirks_flag , on [_] ) 
==>
LAtt(LVar(x0),Att1(A1Var(force-quirks_flag),ANone)) = EVal(on)
Switch to the Data_state
 =>  switch_to ( Data_state [_] ) 
==>
LVar(state) = EVal(Data_state)
Emit the DOCTYPE token 's [0]
 =>  emit ( current_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(current_token))
char: [-1, -1] (EOF)
This is an eof-in-doctype parse error
 =>  this_is_parse_error ( eof-in-doctype_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(eof-in-doctype_parse_error))
Set the DOCTYPE token 's [0] force-quirks flag to on
 =>  set_to ( DOCTYPE_token [0] . force-quirks_flag , on [_] ) 
==>
LAtt(LVar(x0),Att1(A1Var(force-quirks_flag),ANone)) = EVal(on)
Emit the DOCTYPE token 's [0]
 =>  emit ( current_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(current_token))
Emit an end-of-file token
 =>  emit ( end-of-file_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(end-of-file_token))
char: [-1, 65535] (Anything else)
This is a missing-quote-before-doctype-system-identifier parse error
 =>  this_is_parse_error ( missing-quote-before-doctype-system-identifier_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(missing-quote-before-doctype-system-identifier_parse_error))
Set the DOCTYPE token 's force-quirks flag to on
 =>  set_to ( DOCTYPE_token [_] . force-quirks_flag , on [_] ) 
==>
LAtt(LVar(current_token),Att1(A1Var(force-quirks_flag),ANone)) = EVal(on)
Reconsume in the Bogus_DOCTYPE_state
 =>  reconsume_in ( Bogus_DOCTYPE_state [_] ) 
==>
LVar(state) = EVal(Bogus_DOCTYPE_state)
LVar(reconsume_flag) = EVal(True)


name: DOCTYPE_system_identifier_double_quoted_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
==>
If Equal(EVal(reconsume_flag),EVal(False)) :
 then  If Equal(EVal(input_index),ELength(EVal(input))) :
  then   LVar(current_input_character) = EVal(eof)
  else   LVar(current_input_character) = EIdxof(EVal(input),EVal(input_index))
  LVar(input_index) = EPlus(EVal(input_index),ELength(EVal(next_input_character)))
 else  LVar(reconsume_flag) = EVal(False)
trans:
char: [34, 34] (U+0022 QUOTATION MARK ("))
Switch to the After_DOCTYPE_system_identifier_state
 =>  switch_to ( After_DOCTYPE_system_identifier_state [_] ) 
==>
LVar(state) = EVal(After_DOCTYPE_system_identifier_state)
char: [0, 0] (U+0000 NULL)
This is an unexpected-null-character parse error
 =>  this_is_parse_error ( unexpected-null-character_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(unexpected-null-character_parse_error))
Append a U+FFFD REPLACEMENT CHARACTER character to the current DOCTYPE token 's system identifier
 =>  append_to ( U+FFFD_REPLACEMENT_CHARACTER_character_token [_] , DOCTYPE_token [_] . system_identifier ) 
==>
LAtt(LVar(current_token),Att1(A1Var(system_identifier),ANone)) = ECons(EAtt1(EVal(current_token),Att1(A1Var(system_identifier),ANone)),EVal(U+FFFD_REPLACEMENT_CHARACTER_character_token))
char: [62, 62] (U+003E GREATER-THAN SIGN (&gt;))
This is an abrupt-doctype-system-identifier parse error
 =>  this_is_parse_error ( abrupt-doctype-system-identifier_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(abrupt-doctype-system-identifier_parse_error))
Set the DOCTYPE token 's [0] force-quirks flag to on
 =>  set_to ( DOCTYPE_token [0] . force-quirks_flag , on [_] ) 
==>
LAtt(LVar(x0),Att1(A1Var(force-quirks_flag),ANone)) = EVal(on)
Switch to the Data_state
 =>  switch_to ( Data_state [_] ) 
==>
LVar(state) = EVal(Data_state)
Emit the DOCTYPE token 's [0]
 =>  emit ( current_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(current_token))
char: [-1, -1] (EOF)
This is an eof-in-doctype parse error
 =>  this_is_parse_error ( eof-in-doctype_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(eof-in-doctype_parse_error))
Set the DOCTYPE token 's [0] force-quirks flag to on
 =>  set_to ( DOCTYPE_token [0] . force-quirks_flag , on [_] ) 
==>
LAtt(LVar(x0),Att1(A1Var(force-quirks_flag),ANone)) = EVal(on)
Emit the DOCTYPE token 's [0]
 =>  emit ( current_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(current_token))
Emit an end-of-file token
 =>  emit ( end-of-file_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(end-of-file_token))
char: [-1, 65535] (Anything else)
Append the current input character to the current DOCTYPE token 's system identifier
 =>  append_to ( current_input_character [_] , DOCTYPE_token [_] . system_identifier ) 
==>
LAtt(LVar(current_token),Att1(A1Var(system_identifier),ANone)) = ECons(EAtt1(EVal(current_token),Att1(A1Var(system_identifier),ANone)),EVal(current_input_character))


name: DOCTYPE_system_identifier_single_quoted_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
==>
If Equal(EVal(reconsume_flag),EVal(False)) :
 then  If Equal(EVal(input_index),ELength(EVal(input))) :
  then   LVar(current_input_character) = EVal(eof)
  else   LVar(current_input_character) = EIdxof(EVal(input),EVal(input_index))
  LVar(input_index) = EPlus(EVal(input_index),ELength(EVal(next_input_character)))
 else  LVar(reconsume_flag) = EVal(False)
trans:
char: [39, 39] (U+0027 APOSTROPHE ('))
Switch to the After_DOCTYPE_system_identifier_state
 =>  switch_to ( After_DOCTYPE_system_identifier_state [_] ) 
==>
LVar(state) = EVal(After_DOCTYPE_system_identifier_state)
char: [0, 0] (U+0000 NULL)
This is an unexpected-null-character parse error
 =>  this_is_parse_error ( unexpected-null-character_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(unexpected-null-character_parse_error))
Append a U+FFFD REPLACEMENT CHARACTER character to the current DOCTYPE token 's system identifier
 =>  append_to ( U+FFFD_REPLACEMENT_CHARACTER_character_token [_] , DOCTYPE_token [_] . system_identifier ) 
==>
LAtt(LVar(current_token),Att1(A1Var(system_identifier),ANone)) = ECons(EAtt1(EVal(current_token),Att1(A1Var(system_identifier),ANone)),EVal(U+FFFD_REPLACEMENT_CHARACTER_character_token))
char: [62, 62] (U+003E GREATER-THAN SIGN (&gt;))
This is an abrupt-doctype-system-identifier parse error
 =>  this_is_parse_error ( abrupt-doctype-system-identifier_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(abrupt-doctype-system-identifier_parse_error))
Set the DOCTYPE token 's [0] force-quirks flag to on
 =>  set_to ( DOCTYPE_token [0] . force-quirks_flag , on [_] ) 
==>
LAtt(LVar(x0),Att1(A1Var(force-quirks_flag),ANone)) = EVal(on)
Switch to the Data_state
 =>  switch_to ( Data_state [_] ) 
==>
LVar(state) = EVal(Data_state)
Emit the DOCTYPE token 's [0]
 =>  emit ( current_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(current_token))
char: [-1, -1] (EOF)
This is an eof-in-doctype parse error
 =>  this_is_parse_error ( eof-in-doctype_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(eof-in-doctype_parse_error))
Set the DOCTYPE token 's [0] force-quirks flag to on
 =>  set_to ( DOCTYPE_token [0] . force-quirks_flag , on [_] ) 
==>
LAtt(LVar(x0),Att1(A1Var(force-quirks_flag),ANone)) = EVal(on)
Emit the DOCTYPE token 's [0]
 =>  emit ( current_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(current_token))
Emit an end-of-file token
 =>  emit ( end-of-file_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(end-of-file_token))
char: [-1, 65535] (Anything else)
Append the current input character to the current DOCTYPE token 's system identifier
 =>  append_to ( current_input_character [_] , DOCTYPE_token [_] . system_identifier ) 
==>
LAtt(LVar(current_token),Att1(A1Var(system_identifier),ANone)) = ECons(EAtt1(EVal(current_token),Att1(A1Var(system_identifier),ANone)),EVal(current_input_character))


name: After_DOCTYPE_system_identifier_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
==>
If Equal(EVal(reconsume_flag),EVal(False)) :
 then  If Equal(EVal(input_index),ELength(EVal(input))) :
  then   LVar(current_input_character) = EVal(eof)
  else   LVar(current_input_character) = EIdxof(EVal(input),EVal(input_index))
  LVar(input_index) = EPlus(EVal(input_index),ELength(EVal(next_input_character)))
 else  LVar(reconsume_flag) = EVal(False)
trans:
char: [9, 9] (U+0009 CHARACTER TABULATION (tab))
Ignore the character
 =>  ignore_the_character 
==>
Skip
char: [10, 10] (U+000A LINE FEED (LF))
Ignore the character
 =>  ignore_the_character 
==>
Skip
char: [12, 12] (U+000C FORM FEED (FF))
Ignore the character
 =>  ignore_the_character 
==>
Skip
char: [32, 32] (U+0020 SPACE)
Ignore the character
 =>  ignore_the_character 
==>
Skip
char: [62, 62] (U+003E GREATER-THAN SIGN (&gt;))
Switch to the Data_state
 =>  switch_to ( Data_state [_] ) 
==>
LVar(state) = EVal(Data_state)
Emit the current DOCTYPE token
 =>  emit ( DOCTYPE_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(current_token))
char: [-1, -1] (EOF)
This is an eof-in-doctype parse error
 =>  this_is_parse_error ( eof-in-doctype_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(eof-in-doctype_parse_error))
Set the DOCTYPE token 's [0] force-quirks flag to on
 =>  set_to ( DOCTYPE_token [0] . force-quirks_flag , on [_] ) 
==>
LAtt(LVar(x0),Att1(A1Var(force-quirks_flag),ANone)) = EVal(on)
Emit the DOCTYPE token 's [0]
 =>  emit ( current_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(current_token))
Emit an end-of-file token
 =>  emit ( end-of-file_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(end-of-file_token))
char: [-1, 65535] (Anything else)
This is an unexpected-character-after-doctype-system-identifier parse error
 =>  this_is_parse_error ( unexpected-character-after-doctype-system-identifier_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(unexpected-character-after-doctype-system-identifier_parse_error))
Reconsume [0] in the Bogus_DOCTYPE_state
 =>  reconsume_in ( Bogus_DOCTYPE_state [0] ) 
==>
LVar(state) = EVal(Bogus_DOCTYPE_state)
LVar(reconsume_flag) = EVal(True)

 =>  
==>
Skip


name: Bogus_DOCTYPE_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
==>
If Equal(EVal(reconsume_flag),EVal(False)) :
 then  If Equal(EVal(input_index),ELength(EVal(input))) :
  then   LVar(current_input_character) = EVal(eof)
  else   LVar(current_input_character) = EIdxof(EVal(input),EVal(input_index))
  LVar(input_index) = EPlus(EVal(input_index),ELength(EVal(next_input_character)))
 else  LVar(reconsume_flag) = EVal(False)
trans:
char: [62, 62] (U+003E GREATER-THAN SIGN (&gt;))
Switch to the Data_state
 =>  switch_to ( Data_state [_] ) 
==>
LVar(state) = EVal(Data_state)
Emit the DOCTYPE token
 =>  emit ( DOCTYPE_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(current_token))
char: [0, 0] (U+0000 NULL)
This [0] is an unexpected-null-character parse error
 =>  this_is_parse_error ( unexpected-null-character_parse_error [0] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(unexpected-null-character_parse_error))
Ignore This [0]
 =>  ignore_the_character 
==>
Skip
char: [-1, -1] (EOF)
Emit the DOCTYPE token
 =>  emit ( DOCTYPE_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(current_token))
Emit an end-of-file token
 =>  emit ( end-of-file_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(end-of-file_token))
char: [-1, 65535] (Anything else)
Ignore the character
 =>  ignore_the_character 
==>
Skip


name: CDATA_section_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
==>
If Equal(EVal(reconsume_flag),EVal(False)) :
 then  If Equal(EVal(input_index),ELength(EVal(input))) :
  then   LVar(current_input_character) = EVal(eof)
  else   LVar(current_input_character) = EIdxof(EVal(input),EVal(input_index))
  LVar(input_index) = EPlus(EVal(input_index),ELength(EVal(next_input_character)))
 else  LVar(reconsume_flag) = EVal(False)
trans:
char: [93, 93] (U+005D RIGHT SQUARE BRACKET (]))
Switch to the CDATA_section_bracket_state
 =>  switch_to ( CDATA_section_bracket_state [_] ) 
==>
LVar(state) = EVal(CDATA_section_bracket_state)
char: [-1, -1] (EOF)
This is an eof-in-cdata parse error
 =>  this_is_parse_error ( eof-in-cdata_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(eof-in-cdata_parse_error))
Emit an end-of-file token
 =>  emit ( end-of-file_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(end-of-file_token))
char: [-1, 65535] (Anything else)
Emit the current input character as a character token
 =>  emit ( current_input_character [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(current_input_character))


name: CDATA_section_bracket_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
==>
If Equal(EVal(reconsume_flag),EVal(False)) :
 then  If Equal(EVal(input_index),ELength(EVal(input))) :
  then   LVar(current_input_character) = EVal(eof)
  else   LVar(current_input_character) = EIdxof(EVal(input),EVal(input_index))
  LVar(input_index) = EPlus(EVal(input_index),ELength(EVal(next_input_character)))
 else  LVar(reconsume_flag) = EVal(False)
trans:
char: [93, 93] (U+005D RIGHT SQUARE BRACKET (]))
Switch to the CDATA_section_end_state
 =>  switch_to ( CDATA_section_end_state [_] ) 
==>
LVar(state) = EVal(CDATA_section_end_state)
char: [-1, 65535] (Anything else)
Emit a U+005D RIGHT SQUARE BRACKET character token
 =>  emit ( U+005D_RIGHT_SQUARE_BRACKET_character_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(U+005D_RIGHT_SQUARE_BRACKET_character_token))
Reconsume in the CDATA_section_state
 =>  reconsume_in ( CDATA_section_state [_] ) 
==>
LVar(state) = EVal(CDATA_section_state)
LVar(reconsume_flag) = EVal(True)


name: CDATA_section_end_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
==>
If Equal(EVal(reconsume_flag),EVal(False)) :
 then  If Equal(EVal(input_index),ELength(EVal(input))) :
  then   LVar(current_input_character) = EVal(eof)
  else   LVar(current_input_character) = EIdxof(EVal(input),EVal(input_index))
  LVar(input_index) = EPlus(EVal(input_index),ELength(EVal(next_input_character)))
 else  LVar(reconsume_flag) = EVal(False)
trans:
char: [93, 93] (U+005D RIGHT SQUARE BRACKET (]))
Emit a U+005D RIGHT SQUARE BRACKET character token
 =>  emit ( U+005D_RIGHT_SQUARE_BRACKET_character_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(U+005D_RIGHT_SQUARE_BRACKET_character_token))
char: [62, 62] (U+003E GREATER-THAN SIGN character)
Switch to the Data_state
 =>  switch_to ( Data_state [_] ) 
==>
LVar(state) = EVal(Data_state)
char: [-1, 65535] (Anything else)
Emit two U+005D RIGHT SQUARE BRACKET character tokens
 =>  emit ( U+005D_RIGHT_SQUARE_BRACKET_character_token [_] ) | emit ( U+005D_RIGHT_SQUARE_BRACKET_character_token [_] ) 
==>
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(U+005D_RIGHT_SQUARE_BRACKET_character_token))
LVar(output_tokens) = ECons(EVal(output_tokens),EVal(U+005D_RIGHT_SQUARE_BRACKET_character_token))
Reconsume in the CDATA_section_state
 =>  reconsume_in ( CDATA_section_state [_] ) 
==>
LVar(state) = EVal(CDATA_section_state)
LVar(reconsume_flag) = EVal(True)


name: Character_reference_state
prev:
Set the temporary buffer [0] to the empty string
 =>  set_to ( temporary_buffer [0] , empty_string [_] ) 
==>
LVar(temporary_buffer) = EVal(empty_string)
Append a U+0026 AMPERSAND ( & amp ;) character to the temporary buffer [0]
 =>  append_to ( U+0026_AMPERSAND_character_token [_] , temporary_buffer [0] ) 
==>
LVar(temporary_buffer) = ECons(EVal(temporary_buffer),EVal(U+0026_AMPERSAND_character_token))
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
==>
If Equal(EVal(reconsume_flag),EVal(False)) :
 then  If Equal(EVal(input_index),ELength(EVal(input))) :
  then   LVar(current_input_character) = EVal(eof)
  else   LVar(current_input_character) = EIdxof(EVal(input),EVal(input_index))
  LVar(input_index) = EPlus(EVal(input_index),ELength(EVal(next_input_character)))
 else  LVar(reconsume_flag) = EVal(False)
trans:
char: [48, 57], [65, 90], [97, 122] (ASCII alphanumeric)
Reconsume in the Named_character_reference_state
 =>  reconsume_in ( Named_character_reference_state [_] ) 
==>
LVar(state) = EVal(Named_character_reference_state)
LVar(reconsume_flag) = EVal(True)
char: [35, 35] (U+0023 NUMBER SIGN (#))
Append the current input character to the temporary buffer
 =>  append_to ( current_input_character [_] , temporary_buffer [_] ) 
==>
LVar(temporary_buffer) = ECons(EVal(temporary_buffer),EVal(current_input_character))
Switch to the Numeric_character_reference_state
 =>  switch_to ( Numeric_character_reference_state [_] ) 
==>
LVar(state) = EVal(Numeric_character_reference_state)
char: [-1, 65535] (Anything else)
Flush code points consumed as a character reference
 =>  flush_code_points_consumed_as_a_character_reference 
==>
If Or(Equal(EVal(return_state),EVal(Attribute_value_double_quoted_state)),Or(Equal(EVal(return_state),EVal(Attribute_value_single_quoted_state)),Equal(EVal(return_state),EVal(Attribute_value_unquoted_state)))) :
 then  LAtt(LVar(current_token),Att1(A1Var(attributes),Att1(LastElem,Att1(A1Var(value),ANone)))) = ECons(EAtt1(EVal(current_token),Att1(A1Var(attributes),Att1(LastElem,Att1(A1Var(value),ANone)))),EVal(temporary_buffer))
 else  LVar(output_tokens) = ECons(EVal(output_tokens),EVal(temporary_buffer))
Reconsume in the return state
 =>  reconsume_in ( return_state [_] ) 
==>
LVar(state) = EVal(return_state)
LVar(reconsume_flag) = EVal(True)


name: Ambiguous_ampersand_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
==>
If Equal(EVal(reconsume_flag),EVal(False)) :
 then  If Equal(EVal(input_index),ELength(EVal(input))) :
  then   LVar(current_input_character) = EVal(eof)
  else   LVar(current_input_character) = EIdxof(EVal(input),EVal(input_index))
  LVar(input_index) = EPlus(EVal(input_index),ELength(EVal(next_input_character)))
 else  LVar(reconsume_flag) = EVal(False)
trans:
char: [48, 57], [65, 90], [97, 122] (ASCII alphanumeric)
If the character reference was consumed as part of an attribute [0] , then append the current input character [1] to an attribute [0] value . Otherwise , emit the current input character [1] as a character token
 =>  if_then ( the_character_reference_was_consumed_as_part_of_an_attribute , append_to ( current_input_character [1] , attribute [0] . value ) )  | otherwise ( emit ( current_input_character [1] ) ) 
==>
If Or(Equal(EVal(return_state),EVal(Attribute_value_double_quoted_state)),Or(Equal(EVal(return_state),EVal(Attribute_value_single_quoted_state)),Equal(EVal(return_state),EVal(Attribute_value_unquoted_state)))) :
 then  LAtt(LVar(current_token),Att1(A1Var(attributes),Att1(LastElem,Att1(A1Var(value),ANone)))) = ECons(EAtt1(EVal(current_token),Att1(A1Var(attributes),Att1(LastElem,Att1(A1Var(value),ANone)))),EVal(current_input_character))
 else  LVar(output_tokens) = ECons(EVal(output_tokens),EVal(current_input_character))
char: [59, 59] (U+003B SEMICOLON (;))
This is an unknown-named-character-reference parse error
 =>  this_is_parse_error ( unknown-named-character-reference_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(unknown-named-character-reference_parse_error))
Reconsume in the return state
 =>  reconsume_in ( return_state [_] ) 
==>
LVar(state) = EVal(return_state)
LVar(reconsume_flag) = EVal(True)
char: [-1, 65535] (Anything else)
Reconsume in the return state
 =>  reconsume_in ( return_state [_] ) 
==>
LVar(state) = EVal(return_state)
LVar(reconsume_flag) = EVal(True)


name: Numeric_character_reference_state
prev:
Set the character reference code to zero ( 0).Consume the next input character 
 =>  set_to ( character_reference_code [_] , 0 [_] ) | consume ( next_input_character [_] ) 
==>
LVar(character_reference_code) = EVal(0)
If Equal(EVal(reconsume_flag),EVal(False)) :
 then  If Equal(EVal(input_index),ELength(EVal(input))) :
  then   LVar(current_input_character) = EVal(eof)
  else   LVar(current_input_character) = EIdxof(EVal(input),EVal(input_index))
  LVar(input_index) = EPlus(EVal(input_index),ELength(EVal(next_input_character)))
 else  LVar(reconsume_flag) = EVal(False)
trans:
char: [120, 120] (U+0078 LATIN SMALL LETTER X)
Append the current input character to the temporary buffer
 =>  append_to ( current_input_character [_] , temporary_buffer [_] ) 
==>
LVar(temporary_buffer) = ECons(EVal(temporary_buffer),EVal(current_input_character))
Switch to the Hexadecimal_character_reference_start_state
 =>  switch_to ( Hexadecimal_character_reference_start_state [_] ) 
==>
LVar(state) = EVal(Hexadecimal_character_reference_start_state)
char: [88, 88] (U+0058 LATIN CAPITAL LETTER X)
Append the current input character to the temporary buffer
 =>  append_to ( current_input_character [_] , temporary_buffer [_] ) 
==>
LVar(temporary_buffer) = ECons(EVal(temporary_buffer),EVal(current_input_character))
Switch to the Hexadecimal_character_reference_start_state
 =>  switch_to ( Hexadecimal_character_reference_start_state [_] ) 
==>
LVar(state) = EVal(Hexadecimal_character_reference_start_state)
char: [-1, 65535] (Anything else)
Reconsume in the Decimal_character_reference_start_state
 =>  reconsume_in ( Decimal_character_reference_start_state [_] ) 
==>
LVar(state) = EVal(Decimal_character_reference_start_state)
LVar(reconsume_flag) = EVal(True)


name: Hexadecimal_character_reference_start_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
==>
If Equal(EVal(reconsume_flag),EVal(False)) :
 then  If Equal(EVal(input_index),ELength(EVal(input))) :
  then   LVar(current_input_character) = EVal(eof)
  else   LVar(current_input_character) = EIdxof(EVal(input),EVal(input_index))
  LVar(input_index) = EPlus(EVal(input_index),ELength(EVal(next_input_character)))
 else  LVar(reconsume_flag) = EVal(False)
trans:
char: [48, 57], [65, 70], [97, 102] (ASCII hex digit)
Reconsume in the Hexadecimal_character_reference_state
 =>  reconsume_in ( Hexadecimal_character_reference_state [_] ) 
==>
LVar(state) = EVal(Hexadecimal_character_reference_state)
LVar(reconsume_flag) = EVal(True)
char: [-1, 65535] (Anything else)
This is an absence-of-digits-in-numeric-character-reference parse error
 =>  this_is_parse_error ( absence-of-digits-in-numeric-character-reference_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(absence-of-digits-in-numeric-character-reference_parse_error))
Flush code points consumed as a character reference
 =>  flush_code_points_consumed_as_a_character_reference 
==>
If Or(Equal(EVal(return_state),EVal(Attribute_value_double_quoted_state)),Or(Equal(EVal(return_state),EVal(Attribute_value_single_quoted_state)),Equal(EVal(return_state),EVal(Attribute_value_unquoted_state)))) :
 then  LAtt(LVar(current_token),Att1(A1Var(attributes),Att1(LastElem,Att1(A1Var(value),ANone)))) = ECons(EAtt1(EVal(current_token),Att1(A1Var(attributes),Att1(LastElem,Att1(A1Var(value),ANone)))),EVal(temporary_buffer))
 else  LVar(output_tokens) = ECons(EVal(output_tokens),EVal(temporary_buffer))
Reconsume in the return state
 =>  reconsume_in ( return_state [_] ) 
==>
LVar(state) = EVal(return_state)
LVar(reconsume_flag) = EVal(True)


name: Decimal_character_reference_start_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
==>
If Equal(EVal(reconsume_flag),EVal(False)) :
 then  If Equal(EVal(input_index),ELength(EVal(input))) :
  then   LVar(current_input_character) = EVal(eof)
  else   LVar(current_input_character) = EIdxof(EVal(input),EVal(input_index))
  LVar(input_index) = EPlus(EVal(input_index),ELength(EVal(next_input_character)))
 else  LVar(reconsume_flag) = EVal(False)
trans:
char: [48, 57] (ASCII digit)
Reconsume in the Decimal_character_reference_state
 =>  reconsume_in ( Decimal_character_reference_state [_] ) 
==>
LVar(state) = EVal(Decimal_character_reference_state)
LVar(reconsume_flag) = EVal(True)
char: [-1, 65535] (Anything else)
This is an absence-of-digits-in-numeric-character-reference parse error
 =>  this_is_parse_error ( absence-of-digits-in-numeric-character-reference_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(absence-of-digits-in-numeric-character-reference_parse_error))
Flush code points consumed as a character reference
 =>  flush_code_points_consumed_as_a_character_reference 
==>
If Or(Equal(EVal(return_state),EVal(Attribute_value_double_quoted_state)),Or(Equal(EVal(return_state),EVal(Attribute_value_single_quoted_state)),Equal(EVal(return_state),EVal(Attribute_value_unquoted_state)))) :
 then  LAtt(LVar(current_token),Att1(A1Var(attributes),Att1(LastElem,Att1(A1Var(value),ANone)))) = ECons(EAtt1(EVal(current_token),Att1(A1Var(attributes),Att1(LastElem,Att1(A1Var(value),ANone)))),EVal(temporary_buffer))
 else  LVar(output_tokens) = ECons(EVal(output_tokens),EVal(temporary_buffer))
Reconsume in the return state
 =>  reconsume_in ( return_state [_] ) 
==>
LVar(state) = EVal(return_state)
LVar(reconsume_flag) = EVal(True)


name: Hexadecimal_character_reference_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
==>
If Equal(EVal(reconsume_flag),EVal(False)) :
 then  If Equal(EVal(input_index),ELength(EVal(input))) :
  then   LVar(current_input_character) = EVal(eof)
  else   LVar(current_input_character) = EIdxof(EVal(input),EVal(input_index))
  LVar(input_index) = EPlus(EVal(input_index),ELength(EVal(next_input_character)))
 else  LVar(reconsume_flag) = EVal(False)
trans:
char: [48, 57] (ASCII digit)
Multiply the character reference code [1] by 16
 =>  multiply_the_character_reference_code_by ( 16 [_] )
==>
LVar(character_reference_code) = EMul(EVal(character_reference_code),EVal(16))
Add a numeric version of the current input character [0] ( subtract 0x0030 from the current input character [0] code point ) to the character reference code [1]
 =>  add_to_the_character_reference_code ( current_input_character [0] . numeric_version ) 
==>
LVar(character_reference_code) = EPlus(EVal(character_reference_code),EAtt2(EVal(current_input_character),A2Var(numeric_version)))
char: [48, 57], [65, 70] (ASCII upper hex digit)
Multiply the character reference code [1] by 16
 =>  multiply_the_character_reference_code_by ( 16 [_] )
==>
LVar(character_reference_code) = EMul(EVal(character_reference_code),EVal(16))
Add a numeric version of the current input character [0] as a hexadecimal digit ( subtract 0x0037 from the current input character [0] code point ) to the character reference code [1]
 =>  add_to_the_character_reference_code ( current_input_character [0] . numeric_version ) 
==>
LVar(character_reference_code) = EPlus(EVal(character_reference_code),EAtt2(EVal(current_input_character),A2Var(numeric_version)))
char: [48, 57], [97, 102] (ASCII lower hex digit)
Multiply the character reference code [1] by 16
 =>  multiply_the_character_reference_code_by ( 16 [_] )
==>
LVar(character_reference_code) = EMul(EVal(character_reference_code),EVal(16))
Add a numeric version of the current input character [0] as a hexadecimal digit ( subtract 0x0057 from the current input character [0] code point ) to the character reference code [1]
 =>  add_to_the_character_reference_code ( current_input_character [0] . numeric_version ) 
==>
LVar(character_reference_code) = EPlus(EVal(character_reference_code),EAtt2(EVal(current_input_character),A2Var(numeric_version)))
char: [59, 59] (U+003B SEMICOLON)
Switch to the Numeric_character_reference_end_state
 =>  switch_to ( Numeric_character_reference_end_state [_] ) 
==>
LVar(state) = EVal(Numeric_character_reference_end_state)
char: [-1, 65535] (Anything else)
This is a missing-semicolon-after-character-reference parse error
 =>  this_is_parse_error ( missing-semicolon-after-character-reference_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(missing-semicolon-after-character-reference_parse_error))
Reconsume in the Numeric_character_reference_end_state
 =>  reconsume_in ( Numeric_character_reference_end_state [_] ) 
==>
LVar(state) = EVal(Numeric_character_reference_end_state)
LVar(reconsume_flag) = EVal(True)


name: Decimal_character_reference_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
==>
If Equal(EVal(reconsume_flag),EVal(False)) :
 then  If Equal(EVal(input_index),ELength(EVal(input))) :
  then   LVar(current_input_character) = EVal(eof)
  else   LVar(current_input_character) = EIdxof(EVal(input),EVal(input_index))
  LVar(input_index) = EPlus(EVal(input_index),ELength(EVal(next_input_character)))
 else  LVar(reconsume_flag) = EVal(False)
trans:
char: [48, 57] (ASCII digit)
Multiply the character reference code [1] by 10
 =>  multiply_the_character_reference_code_by ( 10 [_] ) 
==>
LVar(character_reference_code) = EMul(EVal(character_reference_code),EVal(10))
Add a numeric version of the current input character [0] ( subtract 0x0030 from the current input character [0] code point ) to the character reference code [1]
 =>  add_to_the_character_reference_code ( current_input_character [0] . numeric_version ) 
==>
LVar(character_reference_code) = EPlus(EVal(character_reference_code),EAtt2(EVal(current_input_character),A2Var(numeric_version)))
char: [59, 59] (U+003B SEMICOLON)
Switch to the Numeric_character_reference_end_state
 =>  switch_to ( Numeric_character_reference_end_state [_] ) 
==>
LVar(state) = EVal(Numeric_character_reference_end_state)
char: [-1, 65535] (Anything else)
This is a missing-semicolon-after-character-reference parse error
 =>  this_is_parse_error ( missing-semicolon-after-character-reference_parse_error [_] ) 
==>
LVar(error_list) = ECons(EVal(error_list),EVal(missing-semicolon-after-character-reference_parse_error))
Reconsume in the Numeric_character_reference_end_state
 =>  reconsume_in ( Numeric_character_reference_end_state [_] ) 
==>
LVar(state) = EVal(Numeric_character_reference_end_state)
LVar(reconsume_flag) = EVal(True)



