name:Data_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
trans:
char:U+0026 AMPERSAND (&amp;)
Set the return state to the Data_state
 =>  set_to ( return_state [_] , Data_state [_] ) 
Switch to the Character_reference_state
 =>  switch_to ( Character_reference_state [_] ) 
char:U+003C LESS-THAN SIGN (&lt;)
Switch to the Tag_open_state
 =>  switch_to ( Tag_open_state [_] ) 
char:U+0000 NULL
This is an unexpected-null-character parse error
 =>  append_to ( unexpected-null-character_parse_error [_] , unexpected-null-character_parse_error [_] ) 
Emit the current input character as a character token
 =>  emit ( current_input_character [_] ) 
char:EOF
Emit an end-of-file token
 =>  emit ( end-of-file_token [_] ) 
char:Anything else
Emit the current input character as a character token
 =>  emit ( current_input_character [_] ) 

name:RCDATA_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
trans:
char:U+0026 AMPERSAND (&amp;)
Set the return state to the RCDATA_state
 =>  set_to ( return_state [_] , RCDATA_state [_] ) 
Switch to the Character_reference_state
 =>  switch_to ( Character_reference_state [_] ) 
char:U+003C LESS-THAN SIGN (&lt;)
Switch to the RCDATA_less_than_sign_state
 =>  switch_to ( RCDATA_less_than_sign_state [_] ) 
char:U+0000 NULL
This is an unexpected-null-character parse error
 =>  append_to ( unexpected-null-character_parse_error [_] , unexpected-null-character_parse_error [_] ) 
Emit a U+FFFD REPLACEMENT CHARACTER character token
 =>  emit ( U+FFFD_REPLACEMENT_CHARACTER_character_token [_] ) 
char:EOF
Emit an end-of-file token
 =>  emit ( end-of-file_token [_] ) 
char:Anything else
Emit the current input character as a character token
 =>  emit ( current_input_character [_] ) 

name:RAWTEXT_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
trans:
char:U+003C LESS-THAN SIGN (&lt;)
Switch to the RAWTEXT_less_than_sign_state
 =>  switch_to ( RAWTEXT_less_than_sign_state [_] ) 
char:U+0000 NULL
This is an unexpected-null-character parse error
 =>  append_to ( unexpected-null-character_parse_error [_] , unexpected-null-character_parse_error [_] ) 
Emit a U+FFFD REPLACEMENT CHARACTER character token
 =>  emit ( U+FFFD_REPLACEMENT_CHARACTER_character_token [_] ) 
char:EOF
Emit an end-of-file token
 =>  emit ( end-of-file_token [_] ) 
char:Anything else
Emit the current input character as a character token
 =>  emit ( current_input_character [_] ) 

name:Script_data_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
trans:
char:U+003C LESS-THAN SIGN (&lt;)
Switch to the Script_data_less_than_sign_state
 =>  switch_to ( Script_data_less_than_sign_state [_] ) 
char:U+0000 NULL
This is an unexpected-null-character parse error
 =>  append_to ( unexpected-null-character_parse_error [_] , unexpected-null-character_parse_error [_] ) 
Emit a U+FFFD REPLACEMENT CHARACTER character token
 =>  emit ( U+FFFD_REPLACEMENT_CHARACTER_character_token [_] ) 
char:EOF
Emit an end-of-file token
 =>  emit ( end-of-file_token [_] ) 
char:Anything else
Emit the current input character as a character token
 =>  emit ( current_input_character [_] ) 

name:PLAINTEXT_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
trans:
char:U+0000 NULL
This is an unexpected-null-character parse error
 =>  append_to ( unexpected-null-character_parse_error [_] , unexpected-null-character_parse_error [_] ) 
Emit a U+FFFD REPLACEMENT CHARACTER character token
 =>  emit ( U+FFFD_REPLACEMENT_CHARACTER_character_token [_] ) 
char:EOF
Emit an end-of-file token
 =>  emit ( end-of-file_token [_] ) 
char:Anything else
Emit the current input character as a character token
 =>  emit ( current_input_character [_] ) 

name:Tag_open_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
trans:
char:U+0021 EXCLAMATION MARK (!)
Switch to the Markup_declaration_open_state
 =>  switch_to ( Markup_declaration_open_state [_] ) 
char:U+002F SOLIDUS (/)
Switch to the End_tag_open_state
 =>  switch_to ( End_tag_open_state [_] ) 
char:ASCII alpha
Create a new start tag token [0] and set a new start tag token [0] tag name to the empty string
 =>  create ( start_tag_token [0] ) | set_to ( start_tag_token [0] . name , empty_string [_] ) 
Reconsume in the Tag_name_state
 =>  reconsume_in ( Tag_name_state [_] ) 
char:U+003F QUESTION MARK (?)
This is an unexpected-question-mark-instead-of-tag-name parse error
 =>  append_to ( unexpected-question-mark-instead-of-tag-name_parse_error [_] , unexpected-question-mark-instead-of-tag-name_parse_error [_] ) 
Create a comment token whose data is the empty string
 =>  create ( comment_token [_] . data ) 
Reconsume in the Bogus_comment_state
 =>  reconsume_in ( Bogus_comment_state [_] ) 
char:EOF
This is an eof-before-tag-name parse error
 =>  append_to ( eof-before-tag-name_parse_error [_] , eof-before-tag-name_parse_error [_] ) 
Emit a U+003C LESS-THAN SIGN character token and an end-of-file token
 =>  emit ( U+003C_LESS-THAN_SIGN_character_token [_] ) | emit ( end-of-file_token [_] ) 
char:Anything else
This is an invalid-first-character-of-tag-name parse error
 =>  append_to ( invalid-first-character-of-tag-name_parse_error [_] , invalid-first-character-of-tag-name_parse_error [_] ) 
Emit a U+003C LESS-THAN SIGN character token
 =>  emit ( U+003C_LESS-THAN_SIGN_character_token [_] ) 
Reconsume in the Data_state
 =>  reconsume_in ( Data_state [_] ) 

name:End_tag_open_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
trans:
char:ASCII alpha
Create a new end tag token [0] , set a new end tag token [0] tag name to the empty string
 =>  create ( end_tag_token [0] ) | set_to ( end_tag_token [0] . name , empty_string [_] ) 
Reconsume in the Tag_name_state
 =>  reconsume_in ( Tag_name_state [_] ) 
char:U+003E GREATER-THAN SIGN (&gt;)
This is a missing-end-tag-name parse error
 =>  this_is_parse_error ( missing-end-tag-name_parse_error [_] ) 
Switch to the Data_state
 =>  switch_to ( Data_state [_] ) 
char:EOF
This is an eof-before-tag-name parse error
 =>  append_to ( eof-before-tag-name_parse_error [_] , eof-before-tag-name_parse_error [_] ) 
Emit a U+003C LESS-THAN SIGN character token , a U+002F SOLIDUS character token and an end-of-file token
 =>  emit ( U+003C_LESS-THAN_SIGN_character_token [_] ) | emit ( U+002F_SOLIDUS_character_token [_] ) | emit ( end-of-file_token [_] ) 
char:Anything else
This is an invalid-first-character-of-tag-name parse error
 =>  append_to ( invalid-first-character-of-tag-name_parse_error [_] , invalid-first-character-of-tag-name_parse_error [_] ) 
Create a comment token whose data is the empty string
 =>  create ( comment_token [_] . data ) 
Reconsume in the Bogus_comment_state
 =>  reconsume_in ( Bogus_comment_state [_] ) 

name:Tag_name_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
trans:
char:U+0009 CHARACTER TABULATION (tab)
Switch to the Before_attribute_name_state
 =>  switch_to ( Before_attribute_name_state [_] ) 
char:U+000A LINE FEED (LF)
Switch to the Before_attribute_name_state
 =>  switch_to ( Before_attribute_name_state [_] ) 
char:U+000C FORM FEED (FF)
Switch to the Before_attribute_name_state
 =>  switch_to ( Before_attribute_name_state [_] ) 
char:U+0020 SPACE
Switch to the Before_attribute_name_state
 =>  switch_to ( Before_attribute_name_state [_] ) 
char:U+002F SOLIDUS (/)
Switch to the Self_closing_start_tag_state
 =>  switch_to ( Self_closing_start_tag_state [_] ) 
char:U+003E GREATER-THAN SIGN (&gt;)
Switch to the Data_state
 =>  switch_to ( Data_state [_] ) 
Emit the current tag token
 =>  emit ( current_tag_token [_] ) 
char:ASCII upper alpha
Append the lowercase version of the current input character [0] ( add 0x0020 to the current input character [0] code point ) to the current tag token 's tag name
 =>  append_to ( current_input_character [0] . lowercase_version , current_tag_token [_] . name ) 
char:U+0000 NULL
This is an unexpected-null-character parse error
 =>  append_to ( unexpected-null-character_parse_error [_] , unexpected-null-character_parse_error [_] ) 
Append a U+FFFD REPLACEMENT CHARACTER character to the current tag token 's tag name
 =>  append_to ( U+FFFD_REPLACEMENT_CHARACTER_character_token [_] , current_tag_token [_] . name ) 
char:EOF
This is an eof-in-tag parse error
 =>  append_to ( eof-in-tag_parse_error [_] , parse_error [_] ) 
Emit an end-of-file token
 =>  emit ( end-of-file_token [_] ) 
char:Anything else
Append the current input character to the current tag token 's tag name
 =>  append_to ( current_input_character [_] , current_tag_token [_] . name ) 

name:RCDATA_less_than_sign_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
trans:
char:U+002F SOLIDUS (/)
Set the temporary buffer to the empty string
 =>  set_to ( temporary_buffer [_] , empty_string [_] ) 
Switch to the RCDATA_end_tag_open_state
 =>  switch_to ( RCDATA_end_tag_open_state [_] ) 
char:Anything else
Emit a U+003C LESS-THAN SIGN character token
 =>  emit ( U+003C_LESS-THAN_SIGN_character_token [_] ) 
Reconsume in the RCDATA_state
 =>  reconsume_in ( RCDATA_state [_] ) 

name:RCDATA_end_tag_open_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
trans:
char:ASCII alpha
Create a new end tag token [0] , set a new end tag token [0] tag name to the empty string
 =>  create ( end_tag_token [0] ) | set_to ( end_tag_token [0] . name , empty_string [_] ) 
Reconsume in the RCDATA_end_tag_name_state
 =>  reconsume_in ( RCDATA_end_tag_name_state [_] ) 
char:Anything else
Emit a U+003C LESS-THAN SIGN character token and a U+002F SOLIDUS character token
 =>  emit ( U+003C_LESS-THAN_SIGN_character_token [_] ) | emit ( U+002F_SOLIDUS_character_token [_] ) 
Reconsume in the RCDATA_state
 =>  reconsume_in ( RCDATA_state [_] ) 

name:RCDATA_end_tag_name_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
trans:
char:U+0009 CHARACTER TABULATION (tab)
If the current end tag token is an appropriate end tag token , then switch to the Before_attribute_name_state
 =>  if_then ( the_current_end_tag_token_is_an_appropriate_end_tag_token , switch_to ( Before_attribute_name_state [_] ) ) 
Otherwise , treat it as per the anything else entry below
 =>  otherwise ( treat_it_as_per_the_"_anything_else_"_entry_below ) 
char:U+000A LINE FEED (LF)
If the current end tag token is an appropriate end tag token , then switch to the Before_attribute_name_state
 =>  if_then ( the_current_end_tag_token_is_an_appropriate_end_tag_token , switch_to ( Before_attribute_name_state [_] ) ) 
Otherwise , treat it as per the anything else entry below
 =>  otherwise ( treat_it_as_per_the_"_anything_else_"_entry_below ) 
char:U+000C FORM FEED (FF)
If the current end tag token is an appropriate end tag token , then switch to the Before_attribute_name_state
 =>  if_then ( the_current_end_tag_token_is_an_appropriate_end_tag_token , switch_to ( Before_attribute_name_state [_] ) ) 
Otherwise , treat it as per the anything else entry below
 =>  otherwise ( treat_it_as_per_the_"_anything_else_"_entry_below ) 
char:U+0020 SPACE
If the current end tag token is an appropriate end tag token , then switch to the Before_attribute_name_state
 =>  if_then ( the_current_end_tag_token_is_an_appropriate_end_tag_token , switch_to ( Before_attribute_name_state [_] ) ) 
Otherwise , treat it as per the anything else entry below
 =>  otherwise ( treat_it_as_per_the_"_anything_else_"_entry_below ) 
char:U+002F SOLIDUS (/)
If the current end tag token is an appropriate end tag token , then switch to the Self_closing_start_tag_state
 =>  if_then ( the_current_end_tag_token_is_an_appropriate_end_tag_token , switch_to ( Self_closing_start_tag_state [_] ) ) 
Otherwise , treat it as per the anything else entry below
 =>  otherwise ( treat_it_as_per_the_"_anything_else_"_entry_below ) 
char:U+003E GREATER-THAN SIGN (&gt;)
If the current end tag token [0] is an appropriate end tag token , then switch to the Data_state and emit the current end tag token [0]
 =>  if_then ( the_current_end_tag_token_is_an_appropriate_end_tag_token , switch_to ( Data_state [_] ) , emit ( end_tag_token [0] ) ) 
Otherwise , treat it as per the anything else entry below
 =>  otherwise ( treat_it_as_per_the_"_anything_else_"_entry_below ) 
char:ASCII upper alpha
Append the lowercase version of the current input character [0] ( add 0x0020 to the current input character [0] code point ) to the current tag token 's tag name
 =>  append_to ( current_input_character [0] . lowercase_version , current_tag_token [_] . name ) 
Append the current input character [0] to the temporary buffer
 =>  append_to ( current_input_character [0] , temporary_buffer [_] ) 
char:ASCII lower alpha
Append the current input character [0] to the current tag token 's tag name
 =>  append_to ( current_input_character [0] , current_tag_token [_] . name ) 
Append the current input character [0] to the temporary buffer
 =>  append_to ( current_input_character [0] , temporary_buffer [_] ) 
char:Anything else
Emit a U+003C LESS-THAN SIGN character token , a U+002F SOLIDUS character token , and a character token for each of the characters in the temporary buffer [0] ( in the order the characters in the temporary buffer [0] were added to the temporary buffer [1] 
 =>  emit ( U+003C_LESS-THAN_SIGN_character_token [_] ) | emit ( U+002F_SOLIDUS_character_token [_] ) | emit ( character_token [_] . data ) | emit ( temporary_buffer [0] ) | reconsume_in ( temporary_buffer [0] ) 
Reconsume in the RCDATA_state
 =>  reconsume_in ( RCDATA_state [_] ) 

name:RAWTEXT_less_than_sign_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
trans:
char:U+002F SOLIDUS (/)
Set the temporary buffer to the empty string
 =>  set_to ( temporary_buffer [_] , empty_string [_] ) 
Switch to the RAWTEXT_end_tag_open_state
 =>  switch_to ( RAWTEXT_end_tag_open_state [_] ) 
char:Anything else
Emit a U+003C LESS-THAN SIGN character token
 =>  emit ( U+003C_LESS-THAN_SIGN_character_token [_] ) 
Reconsume in the RAWTEXT_state
 =>  reconsume_in ( RAWTEXT_state [_] ) 

name:RAWTEXT_end_tag_open_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
trans:
char:ASCII alpha
Create a new end tag token [0] , set a new end tag token [0] tag name to the empty string
 =>  create ( end_tag_token [0] ) | set_to ( end_tag_token [0] . name , empty_string [_] ) 
Reconsume in the RAWTEXT_end_tag_name_state
 =>  reconsume_in ( RAWTEXT_end_tag_name_state [_] ) 
char:Anything else
Emit a U+003C LESS-THAN SIGN character token and a U+002F SOLIDUS character token
 =>  emit ( U+003C_LESS-THAN_SIGN_character_token [_] ) | emit ( U+002F_SOLIDUS_character_token [_] ) 
Reconsume in the RAWTEXT_state
 =>  reconsume_in ( RAWTEXT_state [_] ) 

name:RAWTEXT_end_tag_name_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
trans:
char:U+0009 CHARACTER TABULATION (tab)
If the current end tag token is an appropriate end tag token , then switch to the Before_attribute_name_state
 =>  if_then ( the_current_end_tag_token_is_an_appropriate_end_tag_token , switch_to ( Before_attribute_name_state [_] ) ) 
Otherwise , treat it as per the anything else entry below
 =>  otherwise ( treat_it_as_per_the_"_anything_else_"_entry_below ) 
char:U+000A LINE FEED (LF)
If the current end tag token is an appropriate end tag token , then switch to the Before_attribute_name_state
 =>  if_then ( the_current_end_tag_token_is_an_appropriate_end_tag_token , switch_to ( Before_attribute_name_state [_] ) ) 
Otherwise , treat it as per the anything else entry below
 =>  otherwise ( treat_it_as_per_the_"_anything_else_"_entry_below ) 
char:U+000C FORM FEED (FF)
If the current end tag token is an appropriate end tag token , then switch to the Before_attribute_name_state
 =>  if_then ( the_current_end_tag_token_is_an_appropriate_end_tag_token , switch_to ( Before_attribute_name_state [_] ) ) 
Otherwise , treat it as per the anything else entry below
 =>  otherwise ( treat_it_as_per_the_"_anything_else_"_entry_below ) 
char:U+0020 SPACE
If the current end tag token is an appropriate end tag token , then switch to the Before_attribute_name_state
 =>  if_then ( the_current_end_tag_token_is_an_appropriate_end_tag_token , switch_to ( Before_attribute_name_state [_] ) ) 
Otherwise , treat it as per the anything else entry below
 =>  otherwise ( treat_it_as_per_the_"_anything_else_"_entry_below ) 
char:U+002F SOLIDUS (/)
If the current end tag token is an appropriate end tag token , then switch to the Self_closing_start_tag_state
 =>  if_then ( the_current_end_tag_token_is_an_appropriate_end_tag_token , switch_to ( Self_closing_start_tag_state [_] ) ) 
Otherwise , treat it as per the anything else entry below
 =>  otherwise ( treat_it_as_per_the_"_anything_else_"_entry_below ) 
char:U+003E GREATER-THAN SIGN (&gt;)
If the current end tag token [0] is an appropriate end tag token , then switch to the Data_state and emit the current end tag token [0]
 =>  if_then ( the_current_end_tag_token_is_an_appropriate_end_tag_token , switch_to ( Data_state [_] ) , emit ( end_tag_token [0] ) ) 
Otherwise , treat it as per the anything else entry below
 =>  otherwise ( treat_it_as_per_the_"_anything_else_"_entry_below ) 
char:ASCII upper alpha
Append the lowercase version of the current input character [0] ( add 0x0020 to the current input character [0] code point ) to the current tag token 's tag name
 =>  append_to ( current_input_character [0] . lowercase_version , current_tag_token [_] . name ) 
Append the current input character [0] to the temporary buffer
 =>  append_to ( current_input_character [0] , temporary_buffer [_] ) 
char:ASCII lower alpha
Append the current input character [0] to the current tag token 's tag name
 =>  append_to ( current_input_character [0] , current_tag_token [_] . name ) 
Append the current input character [0] to the temporary buffer
 =>  append_to ( current_input_character [0] , temporary_buffer [_] ) 
char:Anything else
Emit a U+003C LESS-THAN SIGN character token , a U+002F SOLIDUS character token , and a character token for each of the characters in the temporary buffer [0] ( in the order the characters in the temporary buffer [0] were added to the temporary buffer [1] 
 =>  emit ( U+003C_LESS-THAN_SIGN_character_token [_] ) | emit ( U+002F_SOLIDUS_character_token [_] ) | emit ( character_token [_] . data ) | emit ( temporary_buffer [0] ) | reconsume_in ( temporary_buffer [0] ) 
Reconsume in the RAWTEXT_state
 =>  reconsume_in ( RAWTEXT_state [_] ) 

name:Script_data_less_than_sign_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
trans:
char:U+002F SOLIDUS (/)
Set the temporary buffer to the empty string
 =>  set_to ( temporary_buffer [_] , empty_string [_] ) 
Switch to the Script_data_end_tag_open_state
 =>  switch_to ( Script_data_end_tag_open_state [_] ) 
char:U+0021 EXCLAMATION MARK (!)
Switch to the Script_data_escape_start_state
 =>  switch_to ( Script_data_escape_start_state [_] ) 
Emit a U+003C LESS-THAN SIGN character token and a U+0021 EXCLAMATION MARK character token
 =>  emit ( U+003C_LESS-THAN_SIGN_character_token [_] ) | emit ( U+0021_EXCLAMATION_MARK_character_token [_] ) 
char:Anything else
Emit a U+003C LESS-THAN SIGN character token
 =>  emit ( U+003C_LESS-THAN_SIGN_character_token [_] ) 
Reconsume in the Script_data_state
 =>  reconsume_in ( Script_data_state [_] ) 

name:Script_data_end_tag_open_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
trans:
char:ASCII alpha
Create a new end tag token [0] , set a new end tag token [0] tag name to the empty string
 =>  create ( end_tag_token [0] ) | set_to ( end_tag_token [0] . name , empty_string [_] ) 
Reconsume in the Script_data_end_tag_name_state
 =>  reconsume_in ( Script_data_end_tag_name_state [_] ) 
char:Anything else
Emit a U+003C LESS-THAN SIGN character token and a U+002F SOLIDUS character token
 =>  emit ( U+003C_LESS-THAN_SIGN_character_token [_] ) | emit ( U+002F_SOLIDUS_character_token [_] ) 
Reconsume in the Script_data_state
 =>  reconsume_in ( Script_data_state [_] ) 

name:Script_data_end_tag_name_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
trans:
char:U+0009 CHARACTER TABULATION (tab)
If the current end tag token is an appropriate end tag token , then switch to the Before_attribute_name_state
 =>  if_then ( the_current_end_tag_token_is_an_appropriate_end_tag_token , switch_to ( Before_attribute_name_state [_] ) ) 
Otherwise , treat it as per the anything else entry below
 =>  otherwise ( treat_it_as_per_the_"_anything_else_"_entry_below ) 
char:U+000A LINE FEED (LF)
If the current end tag token is an appropriate end tag token , then switch to the Before_attribute_name_state
 =>  if_then ( the_current_end_tag_token_is_an_appropriate_end_tag_token , switch_to ( Before_attribute_name_state [_] ) ) 
Otherwise , treat it as per the anything else entry below
 =>  otherwise ( treat_it_as_per_the_"_anything_else_"_entry_below ) 
char:U+000C FORM FEED (FF)
If the current end tag token is an appropriate end tag token , then switch to the Before_attribute_name_state
 =>  if_then ( the_current_end_tag_token_is_an_appropriate_end_tag_token , switch_to ( Before_attribute_name_state [_] ) ) 
Otherwise , treat it as per the anything else entry below
 =>  otherwise ( treat_it_as_per_the_"_anything_else_"_entry_below ) 
char:U+0020 SPACE
If the current end tag token is an appropriate end tag token , then switch to the Before_attribute_name_state
 =>  if_then ( the_current_end_tag_token_is_an_appropriate_end_tag_token , switch_to ( Before_attribute_name_state [_] ) ) 
Otherwise , treat it as per the anything else entry below
 =>  otherwise ( treat_it_as_per_the_"_anything_else_"_entry_below ) 
char:U+002F SOLIDUS (/)
If the current end tag token is an appropriate end tag token , then switch to the Self_closing_start_tag_state
 =>  if_then ( the_current_end_tag_token_is_an_appropriate_end_tag_token , switch_to ( Self_closing_start_tag_state [_] ) ) 
Otherwise , treat it as per the anything else entry below
 =>  otherwise ( treat_it_as_per_the_"_anything_else_"_entry_below ) 
char:U+003E GREATER-THAN SIGN (&gt;)
If the current end tag token [0] is an appropriate end tag token , then switch to the Data_state and emit the current end tag token [0]
 =>  if_then ( the_current_end_tag_token_is_an_appropriate_end_tag_token , switch_to ( Data_state [_] ) , emit ( end_tag_token [0] ) ) 
Otherwise , treat it as per the anything else entry below
 =>  otherwise ( treat_it_as_per_the_"_anything_else_"_entry_below ) 
char:ASCII upper alpha
Append the lowercase version of the current input character [0] ( add 0x0020 to the current input character [0] code point ) to the current tag token 's tag name
 =>  append_to ( current_input_character [0] . lowercase_version , current_tag_token [_] . name ) 
Append the current input character [0] to the temporary buffer
 =>  append_to ( current_input_character [0] , temporary_buffer [_] ) 
char:ASCII lower alpha
Append the current input character [0] to the current tag token 's tag name
 =>  append_to ( current_input_character [0] , current_tag_token [_] . name ) 
Append the current input character [0] to the temporary buffer
 =>  append_to ( current_input_character [0] , temporary_buffer [_] ) 
char:Anything else
Emit a U+003C LESS-THAN SIGN character token , a U+002F SOLIDUS character token , and a character token for each of the characters in the temporary buffer [0] ( in the order the characters in the temporary buffer [0] were added to the temporary buffer [1] 
 =>  emit ( U+003C_LESS-THAN_SIGN_character_token [_] ) | emit ( U+002F_SOLIDUS_character_token [_] ) | emit ( character_token [_] . data ) | emit ( temporary_buffer [0] ) | reconsume_in ( temporary_buffer [0] ) 
Reconsume in the Script_data_state
 =>  reconsume_in ( Script_data_state [_] ) 

name:Script_data_escape_start_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
trans:
char:U+002D HYPHEN-MINUS (-)
Switch to the Script_data_escape_start_dash_state
 =>  switch_to ( Script_data_escape_start_dash_state [_] ) 
Emit a U+002D HYPHEN-MINUS character token
 =>  emit ( U+002D_HYPHEN-MINUS_character_token [_] ) 
char:Anything else
Reconsume in the Script_data_state
 =>  reconsume_in ( Script_data_state [_] ) 

name:Script_data_escape_start_dash_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
trans:
char:U+002D HYPHEN-MINUS (-)
Switch to the Script_data_escaped_dash_dash_state
 =>  switch_to ( Script_data_escaped_dash_dash_state [_] ) 
Emit a U+002D HYPHEN-MINUS character token
 =>  emit ( U+002D_HYPHEN-MINUS_character_token [_] ) 
char:Anything else
Reconsume in the Script_data_state
 =>  reconsume_in ( Script_data_state [_] ) 

name:Script_data_escaped_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
trans:
char:U+002D HYPHEN-MINUS (-)
Switch to the Script_data_escaped_dash_state
 =>  switch_to ( Script_data_escaped_dash_state [_] ) 
Emit a U+002D HYPHEN-MINUS character token
 =>  emit ( U+002D_HYPHEN-MINUS_character_token [_] ) 
char:U+003C LESS-THAN SIGN (&lt;)
Switch to the Script_data_escaped_less_than_sign_state
 =>  switch_to ( Script_data_escaped_less_than_sign_state [_] ) 
char:U+0000 NULL
This is an unexpected-null-character parse error
 =>  append_to ( unexpected-null-character_parse_error [_] , unexpected-null-character_parse_error [_] ) 
Emit a U+FFFD REPLACEMENT CHARACTER character token
 =>  emit ( U+FFFD_REPLACEMENT_CHARACTER_character_token [_] ) 
char:EOF
This is an eof-in-script-html-comment-like-text parse error
 =>  append_to ( eof-in-script-html-comment-like-text_parse_error [_] , eof-in-script-html-comment-like-text_parse_error [_] ) 
Emit an end-of-file token
 =>  emit ( end-of-file_token [_] ) 
char:Anything else
Emit the current input character as a character token
 =>  emit ( current_input_character [_] ) 

name:Script_data_escaped_dash_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
trans:
char:U+002D HYPHEN-MINUS (-)
Switch to the Script_data_escaped_dash_dash_state
 =>  switch_to ( Script_data_escaped_dash_dash_state [_] ) 
Emit a U+002D HYPHEN-MINUS character token
 =>  emit ( U+002D_HYPHEN-MINUS_character_token [_] ) 
char:U+003C LESS-THAN SIGN (&lt;)
Switch to the Script_data_escaped_less_than_sign_state
 =>  switch_to ( Script_data_escaped_less_than_sign_state [_] ) 
char:U+0000 NULL
This is an unexpected-null-character parse error
 =>  append_to ( unexpected-null-character_parse_error [_] , unexpected-null-character_parse_error [_] ) 
Switch to the Script_data_escaped_state
 =>  switch_to ( Script_data_escaped_state [_] ) 
Emit a U+FFFD REPLACEMENT CHARACTER character token
 =>  emit ( U+FFFD_REPLACEMENT_CHARACTER_character_token [_] ) 
char:EOF
This is an eof-in-script-html-comment-like-text parse error
 =>  append_to ( eof-in-script-html-comment-like-text_parse_error [_] , eof-in-script-html-comment-like-text_parse_error [_] ) 
Emit an end-of-file token
 =>  emit ( end-of-file_token [_] ) 
char:Anything else
Switch to the Script_data_escaped_state
 =>  switch_to ( Script_data_escaped_state [_] ) 
Emit the current input character as a character token
 =>  emit ( current_input_character [_] ) 

name:Script_data_escaped_dash_dash_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
trans:
char:U+002D HYPHEN-MINUS (-)
Emit a U+002D HYPHEN-MINUS character token
 =>  emit ( U+002D_HYPHEN-MINUS_character_token [_] ) 
char:U+003C LESS-THAN SIGN (&lt;)
Switch to the Script_data_escaped_less_than_sign_state
 =>  switch_to ( Script_data_escaped_less_than_sign_state [_] ) 
char:U+003E GREATER-THAN SIGN (&gt;)
Switch to the Script_data_state
 =>  switch_to ( Script_data_state [_] ) 
Emit a U+003E GREATER-THAN SIGN character token
 =>  emit ( U+003E_GREATER-THAN_SIGN_character_token [_] ) 
char:U+0000 NULL
This is an unexpected-null-character parse error
 =>  append_to ( unexpected-null-character_parse_error [_] , unexpected-null-character_parse_error [_] ) 
Switch to the Script_data_escaped_state
 =>  switch_to ( Script_data_escaped_state [_] ) 
Emit a U+FFFD REPLACEMENT CHARACTER character token
 =>  emit ( U+FFFD_REPLACEMENT_CHARACTER_character_token [_] ) 
char:EOF
This is an eof-in-script-html-comment-like-text parse error
 =>  append_to ( eof-in-script-html-comment-like-text_parse_error [_] , eof-in-script-html-comment-like-text_parse_error [_] ) 
Emit an end-of-file token
 =>  emit ( end-of-file_token [_] ) 
char:Anything else
Switch to the Script_data_escaped_state
 =>  switch_to ( Script_data_escaped_state [_] ) 
Emit the current input character as a character token
 =>  emit ( current_input_character [_] ) 

name:Script_data_escaped_less_than_sign_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
trans:
char:U+002F SOLIDUS (/)
Set the temporary buffer to the empty string
 =>  set_to ( temporary_buffer [_] , empty_string [_] ) 
Switch to the Script_data_escaped_end_tag_open_state
 =>  switch_to ( Script_data_escaped_end_tag_open_state [_] ) 
char:ASCII alpha
Set the temporary buffer to the empty string
 =>  set_to ( temporary_buffer [_] , empty_string [_] ) 
Emit a U+003C LESS-THAN SIGN character token
 =>  emit ( U+003C_LESS-THAN_SIGN_character_token [_] ) 
Reconsume in the Script_data_double_escape_start_state
 =>  reconsume_in ( Script_data_double_escape_start_state [_] ) 
char:Anything else
Emit a U+003C LESS-THAN SIGN character token
 =>  emit ( U+003C_LESS-THAN_SIGN_character_token [_] ) 
Reconsume in the Script_data_escaped_state
 =>  reconsume_in ( Script_data_escaped_state [_] ) 

name:Script_data_escaped_end_tag_open_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
trans:
char:ASCII alpha
Create a new end tag token [0] , set a new end tag token [0] tag name to the empty string
 =>  create ( end_tag_token [0] ) | set_to ( end_tag_token [0] . name , empty_string [_] ) 
Reconsume in the Script_data_escaped_end_tag_name_state
 =>  reconsume_in ( Script_data_escaped_end_tag_name_state [_] ) 
char:Anything else
Emit a U+003C LESS-THAN SIGN character token and a U+002F SOLIDUS character token
 =>  emit ( U+003C_LESS-THAN_SIGN_character_token [_] ) | emit ( U+002F_SOLIDUS_character_token [_] ) 
Reconsume in the Script_data_escaped_state
 =>  reconsume_in ( Script_data_escaped_state [_] ) 

name:Script_data_escaped_end_tag_name_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
trans:
char:U+0009 CHARACTER TABULATION (tab)
If the current end tag token is an appropriate end tag token , then switch to the Before_attribute_name_state
 =>  if_then ( the_current_end_tag_token_is_an_appropriate_end_tag_token , switch_to ( Before_attribute_name_state [_] ) ) 
Otherwise , treat it as per the anything else entry below
 =>  otherwise ( treat_it_as_per_the_"_anything_else_"_entry_below ) 
char:U+000A LINE FEED (LF)
If the current end tag token is an appropriate end tag token , then switch to the Before_attribute_name_state
 =>  if_then ( the_current_end_tag_token_is_an_appropriate_end_tag_token , switch_to ( Before_attribute_name_state [_] ) ) 
Otherwise , treat it as per the anything else entry below
 =>  otherwise ( treat_it_as_per_the_"_anything_else_"_entry_below ) 
char:U+000C FORM FEED (FF)
If the current end tag token is an appropriate end tag token , then switch to the Before_attribute_name_state
 =>  if_then ( the_current_end_tag_token_is_an_appropriate_end_tag_token , switch_to ( Before_attribute_name_state [_] ) ) 
Otherwise , treat it as per the anything else entry below
 =>  otherwise ( treat_it_as_per_the_"_anything_else_"_entry_below ) 
char:U+0020 SPACE
If the current end tag token is an appropriate end tag token , then switch to the Before_attribute_name_state
 =>  if_then ( the_current_end_tag_token_is_an_appropriate_end_tag_token , switch_to ( Before_attribute_name_state [_] ) ) 
Otherwise , treat it as per the anything else entry below
 =>  otherwise ( treat_it_as_per_the_"_anything_else_"_entry_below ) 
char:U+002F SOLIDUS (/)
If the current end tag token is an appropriate end tag token , then switch to the Self_closing_start_tag_state
 =>  if_then ( the_current_end_tag_token_is_an_appropriate_end_tag_token , switch_to ( Self_closing_start_tag_state [_] ) ) 
Otherwise , treat it as per the anything else entry below
 =>  otherwise ( treat_it_as_per_the_"_anything_else_"_entry_below ) 
char:U+003E GREATER-THAN SIGN (&gt;)
If the current end tag token [0] is an appropriate end tag token , then switch to the Data_state and emit the current end tag token [0]
 =>  if_then ( the_current_end_tag_token_is_an_appropriate_end_tag_token , switch_to ( Data_state [_] ) , emit ( end_tag_token [0] ) ) 
Otherwise , treat it as per the anything else entry below
 =>  otherwise ( treat_it_as_per_the_"_anything_else_"_entry_below ) 
char:ASCII upper alpha
Append the lowercase version of the current input character [0] ( add 0x0020 to the current input character [0] code point ) to the current tag token 's tag name
 =>  append_to ( current_input_character [0] . lowercase_version , current_tag_token [_] . name ) 
Append the current input character [0] to the temporary buffer
 =>  append_to ( current_input_character [0] , temporary_buffer [_] ) 
char:ASCII lower alpha
Append the current input character [0] to the current tag token 's tag name
 =>  append_to ( current_input_character [0] , current_tag_token [_] . name ) 
Append the current input character [0] to the temporary buffer
 =>  append_to ( current_input_character [0] , temporary_buffer [_] ) 
char:Anything else
Emit a U+003C LESS-THAN SIGN character token , a U+002F SOLIDUS character token , and a character token for each of the characters in the temporary buffer [0]   ( in the order the characters in the temporary buffer [0] were added to the temporary buffer [1] 
 =>  emit ( U+003C_LESS-THAN_SIGN_character_token [_] ) | emit ( U+002F_SOLIDUS_character_token [_] ) | emit ( character_token [_] . data ) | emit ( temporary_buffer [0] ) | reconsume_in ( temporary_buffer [0] ) 
Reconsume in the Script_data_escaped_state
 =>  reconsume_in ( Script_data_escaped_state [_] ) 

name:Script_data_double_escape_start_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
trans:
char:U+0009 CHARACTER TABULATION (tab)
If the temporary buffer is the string script , then switch to the Script_data_double_escaped_state
 =>  if_then ( is ( temporary_buffer [_] , string_"script" [_] ) , switch_to ( Script_data_double_escaped_state [_] ) ) 
Otherwise , switch to the Script_data_escaped_state
 =>  otherwise ( switch_to ( Script_data_escaped_state [_] ) ) 
Emit the current input character as a character token
 =>  emit ( current_input_character [_] ) 
char:U+000A LINE FEED (LF)
If the temporary buffer is the string script , then switch to the Script_data_double_escaped_state
 =>  if_then ( is ( temporary_buffer [_] , string_"script" [_] ) , switch_to ( Script_data_double_escaped_state [_] ) ) 
Otherwise , switch to the Script_data_escaped_state
 =>  otherwise ( switch_to ( Script_data_escaped_state [_] ) ) 
Emit the current input character as a character token
 =>  emit ( current_input_character [_] ) 
char:U+000C FORM FEED (FF)
If the temporary buffer is the string script , then switch to the Script_data_double_escaped_state
 =>  if_then ( is ( temporary_buffer [_] , string_"script" [_] ) , switch_to ( Script_data_double_escaped_state [_] ) ) 
Otherwise , switch to the Script_data_escaped_state
 =>  otherwise ( switch_to ( Script_data_escaped_state [_] ) ) 
Emit the current input character as a character token
 =>  emit ( current_input_character [_] ) 
char:U+0020 SPACE
If the temporary buffer is the string script , then switch to the Script_data_double_escaped_state
 =>  if_then ( is ( temporary_buffer [_] , string_"script" [_] ) , switch_to ( Script_data_double_escaped_state [_] ) ) 
Otherwise , switch to the Script_data_escaped_state
 =>  otherwise ( switch_to ( Script_data_escaped_state [_] ) ) 
Emit the current input character as a character token
 =>  emit ( current_input_character [_] ) 
char:U+002F SOLIDUS (/)
If the temporary buffer is the string script , then switch to the Script_data_double_escaped_state
 =>  if_then ( is ( temporary_buffer [_] , string_"script" [_] ) , switch_to ( Script_data_double_escaped_state [_] ) ) 
Otherwise , switch to the Script_data_escaped_state
 =>  otherwise ( switch_to ( Script_data_escaped_state [_] ) ) 
Emit the current input character as a character token
 =>  emit ( current_input_character [_] ) 
char:U+003E GREATER-THAN SIGN (&gt;)
If the temporary buffer is the string script , then switch to the Script_data_double_escaped_state
 =>  if_then ( is ( temporary_buffer [_] , string_"script" [_] ) , switch_to ( Script_data_double_escaped_state [_] ) ) 
Otherwise , switch to the Script_data_escaped_state
 =>  otherwise ( switch_to ( Script_data_escaped_state [_] ) ) 
Emit the current input character as a character token
 =>  emit ( current_input_character [_] ) 
char:ASCII upper alpha
Append the lowercase version of the current input character [0] ( add 0x0020 to the current input character [0] code point ) to the temporary buffer
 =>  append_to ( current_input_character [0] . lowercase_version , temporary_buffer [_] ) 
Emit the current input character [0] as a character token
 =>  emit ( current_input_character [0] ) 
char:ASCII lower alpha
Append the current input character [0] to the temporary buffer
 =>  append_to ( current_input_character [0] , temporary_buffer [_] ) 
Emit the current input character [0] as a character token
 =>  emit ( current_input_character [0] ) 
char:Anything else
Reconsume in the Script_data_escaped_state
 =>  reconsume_in ( Script_data_escaped_state [_] ) 

name:Script_data_double_escaped_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
trans:
char:U+002D HYPHEN-MINUS (-)
Switch to the Script_data_double_escaped_dash_state
 =>  switch_to ( Script_data_double_escaped_dash_state [_] ) 
Emit a U+002D HYPHEN-MINUS character token
 =>  emit ( U+002D_HYPHEN-MINUS_character_token [_] ) 
char:U+003C LESS-THAN SIGN (&lt;)
Switch to the Script_data_double_escaped_less_than_sign_state
 =>  switch_to ( Script_data_double_escaped_less_than_sign_state [_] ) 
Emit a U+003C LESS-THAN SIGN character token
 =>  emit ( U+003C_LESS-THAN_SIGN_character_token [_] ) 
char:U+0000 NULL
This is an unexpected-null-character parse error
 =>  append_to ( unexpected-null-character_parse_error [_] , unexpected-null-character_parse_error [_] ) 
Emit a U+FFFD REPLACEMENT CHARACTER character token
 =>  emit ( U+FFFD_REPLACEMENT_CHARACTER_character_token [_] ) 
char:EOF
This is an eof-in-script-html-comment-like-text parse error
 =>  append_to ( eof-in-script-html-comment-like-text_parse_error [_] , eof-in-script-html-comment-like-text_parse_error [_] ) 
Emit an end-of-file token
 =>  emit ( end-of-file_token [_] ) 
char:Anything else
Emit the current input character as a character token
 =>  emit ( current_input_character [_] ) 

name:Script_data_double_escaped_dash_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
trans:
char:U+002D HYPHEN-MINUS (-)
Switch to the Script_data_double_escaped_dash_dash_state
 =>  switch_to ( Script_data_double_escaped_dash_dash_state [_] ) 
Emit a U+002D HYPHEN-MINUS character token
 =>  emit ( U+002D_HYPHEN-MINUS_character_token [_] ) 
char:U+003C LESS-THAN SIGN (&lt;)
Switch to the Script_data_double_escaped_less_than_sign_state
 =>  switch_to ( Script_data_double_escaped_less_than_sign_state [_] ) 
Emit a U+003C LESS-THAN SIGN character token
 =>  emit ( U+003C_LESS-THAN_SIGN_character_token [_] ) 
char:U+0000 NULL
This is an unexpected-null-character parse error
 =>  append_to ( unexpected-null-character_parse_error [_] , unexpected-null-character_parse_error [_] ) 
Switch to the Script_data_double_escaped_state
 =>  switch_to ( Script_data_double_escaped_state [_] ) 
Emit a U+FFFD REPLACEMENT CHARACTER character token
 =>  emit ( U+FFFD_REPLACEMENT_CHARACTER_character_token [_] ) 
char:EOF
This is an eof-in-script-html-comment-like-text parse error
 =>  append_to ( eof-in-script-html-comment-like-text_parse_error [_] , eof-in-script-html-comment-like-text_parse_error [_] ) 
Emit an end-of-file token
 =>  emit ( end-of-file_token [_] ) 
char:Anything else
Switch to the Script_data_double_escaped_state
 =>  switch_to ( Script_data_double_escaped_state [_] ) 
Emit the current input character as a character token
 =>  emit ( current_input_character [_] ) 

name:Script_data_double_escaped_dash_dash_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
trans:
char:U+002D HYPHEN-MINUS (-)
Emit a U+002D HYPHEN-MINUS character token
 =>  emit ( U+002D_HYPHEN-MINUS_character_token [_] ) 
char:U+003C LESS-THAN SIGN (&lt;)
Switch to the Script_data_double_escaped_less_than_sign_state
 =>  switch_to ( Script_data_double_escaped_less_than_sign_state [_] ) 
Emit a U+003C LESS-THAN SIGN character token
 =>  emit ( U+003C_LESS-THAN_SIGN_character_token [_] ) 
char:U+003E GREATER-THAN SIGN (&gt;)
Switch to the Script_data_state
 =>  switch_to ( Script_data_state [_] ) 
Emit a U+003E GREATER-THAN SIGN character token
 =>  emit ( U+003E_GREATER-THAN_SIGN_character_token [_] ) 
char:U+0000 NULL
This is an unexpected-null-character parse error
 =>  append_to ( unexpected-null-character_parse_error [_] , unexpected-null-character_parse_error [_] ) 
Switch to the Script_data_double_escaped_state
 =>  switch_to ( Script_data_double_escaped_state [_] ) 
Emit a U+FFFD REPLACEMENT CHARACTER character token
 =>  emit ( U+FFFD_REPLACEMENT_CHARACTER_character_token [_] ) 
char:EOF
This is an eof-in-script-html-comment-like-text parse error
 =>  append_to ( eof-in-script-html-comment-like-text_parse_error [_] , eof-in-script-html-comment-like-text_parse_error [_] ) 
Emit an end-of-file token
 =>  emit ( end-of-file_token [_] ) 
char:Anything else
Switch to the Script_data_double_escaped_state
 =>  switch_to ( Script_data_double_escaped_state [_] ) 
Emit the current input character as a character token
 =>  emit ( current_input_character [_] ) 

name:Script_data_double_escaped_less_than_sign_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
trans:
char:U+002F SOLIDUS (/)
Set the temporary buffer to the empty string
 =>  set_to ( temporary_buffer [_] , empty_string [_] ) 
Switch to the Script_data_double_escape_end_state
 =>  switch_to ( Script_data_double_escape_end_state [_] ) 
Emit a U+002F SOLIDUS character token
 =>  emit ( U+002F_SOLIDUS_character_token [_] ) 
char:Anything else
Reconsume in the Script_data_double_escaped_state
 =>  reconsume_in ( Script_data_double_escaped_state [_] ) 

name:Script_data_double_escape_end_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
trans:
char:U+0009 CHARACTER TABULATION (tab)
If the temporary buffer is the string script , then switch to the Script_data_escaped_state
 =>  if_then ( is ( temporary_buffer [_] , string_"script" [_] ) , switch_to ( Script_data_escaped_state [_] ) ) 
Otherwise , switch to the Script_data_double_escaped_state
 =>  otherwise ( switch_to ( Script_data_double_escaped_state [_] ) ) 
Emit the current input character as a character token
 =>  emit ( current_input_character [_] ) 
char:U+000A LINE FEED (LF)
If the temporary buffer is the string script , then switch to the Script_data_escaped_state
 =>  if_then ( is ( temporary_buffer [_] , string_"script" [_] ) , switch_to ( Script_data_escaped_state [_] ) ) 
Otherwise , switch to the Script_data_double_escaped_state
 =>  otherwise ( switch_to ( Script_data_double_escaped_state [_] ) ) 
Emit the current input character as a character token
 =>  emit ( current_input_character [_] ) 
char:U+000C FORM FEED (FF)
If the temporary buffer is the string script , then switch to the Script_data_escaped_state
 =>  if_then ( is ( temporary_buffer [_] , string_"script" [_] ) , switch_to ( Script_data_escaped_state [_] ) ) 
Otherwise , switch to the Script_data_double_escaped_state
 =>  otherwise ( switch_to ( Script_data_double_escaped_state [_] ) ) 
Emit the current input character as a character token
 =>  emit ( current_input_character [_] ) 
char:U+0020 SPACE
If the temporary buffer is the string script , then switch to the Script_data_escaped_state
 =>  if_then ( is ( temporary_buffer [_] , string_"script" [_] ) , switch_to ( Script_data_escaped_state [_] ) ) 
Otherwise , switch to the Script_data_double_escaped_state
 =>  otherwise ( switch_to ( Script_data_double_escaped_state [_] ) ) 
Emit the current input character as a character token
 =>  emit ( current_input_character [_] ) 
char:U+002F SOLIDUS (/)
If the temporary buffer is the string script , then switch to the Script_data_escaped_state
 =>  if_then ( is ( temporary_buffer [_] , string_"script" [_] ) , switch_to ( Script_data_escaped_state [_] ) ) 
Otherwise , switch to the Script_data_double_escaped_state
 =>  otherwise ( switch_to ( Script_data_double_escaped_state [_] ) ) 
Emit the current input character as a character token
 =>  emit ( current_input_character [_] ) 
char:U+003E GREATER-THAN SIGN (&gt;)
If the temporary buffer is the string script , then switch to the Script_data_escaped_state
 =>  if_then ( is ( temporary_buffer [_] , string_"script" [_] ) , switch_to ( Script_data_escaped_state [_] ) ) 
Otherwise , switch to the Script_data_double_escaped_state
 =>  otherwise ( switch_to ( Script_data_double_escaped_state [_] ) ) 
Emit the current input character as a character token
 =>  emit ( current_input_character [_] ) 
char:ASCII upper alpha
Append the lowercase version of the current input character [0] ( add 0x0020 to the current input character [0] code point ) to the temporary buffer
 =>  append_to ( current_input_character [0] . lowercase_version , temporary_buffer [_] ) 
Emit the current input character [0] as a character token
 =>  emit ( current_input_character [0] ) 
char:ASCII lower alpha
Append the current input character [0] to the temporary buffer
 =>  append_to ( current_input_character [0] , temporary_buffer [_] ) 
Emit the current input character [0] as a character token
 =>  emit ( current_input_character [0] ) 
char:Anything else
Reconsume in the Script_data_double_escaped_state
 =>  reconsume_in ( Script_data_double_escaped_state [_] ) 

name:Before_attribute_name_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
trans:
char:U+0009 CHARACTER TABULATION (tab)
Ignore the character
 =>  ignore_the_character 
char:U+000A LINE FEED (LF)
Ignore the character
 =>  ignore_the_character 
char:U+000C FORM FEED (FF)
Ignore the character
 =>  ignore_the_character 
char:U+0020 SPACE
Ignore the character
 =>  ignore_the_character 
char:U+002F SOLIDUS (/)
Reconsume in the After_attribute_name_state
 =>  reconsume_in ( After_attribute_name_state [_] ) 
char:U+003E GREATER-THAN SIGN (&gt;)
Reconsume in the After_attribute_name_state
 =>  reconsume_in ( After_attribute_name_state [_] ) 
char:EOF
Reconsume in the After_attribute_name_state
 =>  reconsume_in ( After_attribute_name_state [_] ) 
char:U+003D EQUALS SIGN (=)
This is an unexpected-equals-sign-before-attribute-name parse error
 =>  append_to ( unexpected-equals-sign-before-attribute-name_parse_error [_] , unexpected-equals-sign-before-attribute-name_parse_error [_] ) 
Start a new attribute [0] in the current tag token
 =>  append_to ( attribute [0] , current_tag_token [_] ) 
Set a new attribute [0] name to the current input character , and a new attribute [0] value to the empty string
 =>  set_to ( attribute [0] . name , current_input_character [_] ) | set_to ( attribute [0] . value , empty_string [_] ) 
Switch to the Attribute_name_state
 =>  switch_to ( Attribute_name_state [_] ) 
char:Anything else
Start a new attribute in the current tag token
 =>  start_a_new_attribute_in_the_current_tag_token 
Set that attribute name and value to the empty string
 =>  set_to ( attribute [_] . name , empty_string [_] ) | set_to ( value [_] , empty_string [_] ) 
Reconsume in the Attribute_name_state
 =>  reconsume_in ( Attribute_name_state [_] ) 

name:Attribute_name_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
trans:
char:U+0009 CHARACTER TABULATION (tab)
Reconsume in the After_attribute_name_state
 =>  reconsume_in ( After_attribute_name_state [_] ) 
char:U+000A LINE FEED (LF)
Reconsume in the After_attribute_name_state
 =>  reconsume_in ( After_attribute_name_state [_] ) 
char:U+000C FORM FEED (FF)
Reconsume in the After_attribute_name_state
 =>  reconsume_in ( After_attribute_name_state [_] ) 
char:U+0020 SPACE
Reconsume in the After_attribute_name_state
 =>  reconsume_in ( After_attribute_name_state [_] ) 
char:U+002F SOLIDUS (/)
Reconsume in the After_attribute_name_state
 =>  reconsume_in ( After_attribute_name_state [_] ) 
char:U+003E GREATER-THAN SIGN (&gt;)
Reconsume in the After_attribute_name_state
 =>  reconsume_in ( After_attribute_name_state [_] ) 
char:EOF
Reconsume in the After_attribute_name_state
 =>  reconsume_in ( After_attribute_name_state [_] ) 
char:U+003D EQUALS SIGN (=)
Switch to the Before_attribute_value_state
 =>  switch_to ( Before_attribute_value_state [_] ) 
char:ASCII upper alpha
Append the lowercase version of the current input character [0] ( add 0x0020 to the current input character [0] code point ) to the current attribute 's name
 =>  append_to ( current_input_character [0] . lowercase_version , current_tag_token [_] . name ) 
char:U+0000 NULL
This is an unexpected-null-character parse error
 =>  append_to ( unexpected-null-character_parse_error [_] , unexpected-null-character_parse_error [_] ) 
Append a U+FFFD REPLACEMENT CHARACTER character to the current attribute 's name
 =>  append_to ( U+FFFD_REPLACEMENT_CHARACTER_character_token [_] , attribute [_] . name ) 
char:U+0022 QUOTATION MARK (")
This [0] is an unexpected-character-in-attribute-name parse error
 =>  append_to ( unexpected-character-in-attribute-name_parse_error [0] , unexpected-character-in-attribute-name_parse_error [_] ) 
Treat This [0] as per the anything else entry below
 =>  this_is_parse_error ( Tag_open_state [0] ) 
char:U+0027 APOSTROPHE (')
This [0] is an unexpected-character-in-attribute-name parse error
 =>  append_to ( unexpected-character-in-attribute-name_parse_error [0] , unexpected-character-in-attribute-name_parse_error [_] ) 
Treat This [0] as per the anything else entry below
 =>  this_is_parse_error ( Tag_open_state [0] ) 
char:U+003C LESS-THAN SIGN (&lt;)
This [0] is an unexpected-character-in-attribute-name parse error
 =>  append_to ( unexpected-character-in-attribute-name_parse_error [0] , unexpected-character-in-attribute-name_parse_error [_] ) 
Treat This [0] as per the anything else entry below
 =>  this_is_parse_error ( Tag_open_state [0] ) 
char:Anything else
Append the current input character to the current attribute 's name
 =>  append_to ( current_input_character [_] , attribute [_] . name ) 

name:After_attribute_name_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
trans:
char:U+0009 CHARACTER TABULATION (tab)
Ignore the character
 =>  ignore_the_character 
char:U+000A LINE FEED (LF)
Ignore the character
 =>  ignore_the_character 
char:U+000C FORM FEED (FF)
Ignore the character
 =>  ignore_the_character 
char:U+0020 SPACE
Ignore the character
 =>  ignore_the_character 
char:U+002F SOLIDUS (/)
Switch to the Self_closing_start_tag_state
 =>  switch_to ( Self_closing_start_tag_state [_] ) 
char:U+003D EQUALS SIGN (=)
Switch to the Before_attribute_value_state
 =>  switch_to ( Before_attribute_value_state [_] ) 
char:U+003E GREATER-THAN SIGN (&gt;)
Switch to the Data_state
 =>  switch_to ( Data_state [_] ) 
Emit the current tag token
 =>  emit ( current_tag_token [_] ) 
char:EOF
This is an eof-in-tag parse error
 =>  append_to ( eof-in-tag_parse_error [_] , parse_error [_] ) 
Emit an end-of-file token
 =>  emit ( end-of-file_token [_] ) 
char:Anything else
Start a new attribute in the current tag token
 =>  start_a_new_attribute_in_the_current_tag_token 
Set that attribute name and value to the empty string
 =>  set_to ( attribute [_] . name , empty_string [_] ) | set_to ( value [_] , empty_string [_] ) 
Reconsume in the Attribute_name_state
 =>  reconsume_in ( Attribute_name_state [_] ) 

name:Before_attribute_value_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
trans:
char:U+0009 CHARACTER TABULATION (tab)
Ignore the character
 =>  ignore_the_character 
char:U+000A LINE FEED (LF)
Ignore the character
 =>  ignore_the_character 
char:U+000C FORM FEED (FF)
Ignore the character
 =>  ignore_the_character 
char:U+0020 SPACE
Ignore the character
 =>  ignore_the_character 
char:U+0022 QUOTATION MARK (")
Switch to the Attribute_value_double_quoted_state
 =>  switch_to ( Attribute_value_double_quoted_state [_] ) 
char:U+0027 APOSTROPHE (')
Switch to the Attribute_value_single_quoted_state
 =>  switch_to ( Attribute_value_single_quoted_state [_] ) 
char:U+003E GREATER-THAN SIGN (&gt;)
This is a missing-attribute-value parse error
 =>  this_is_parse_error ( missing-attribute-value_parse_error [_] ) 
Switch to the Data_state
 =>  switch_to ( Data_state [_] ) 
Emit the current tag token
 =>  emit ( current_tag_token [_] ) 
char:Anything else
Reconsume in the Attribute_value_unquoted_state
 =>  reconsume_in ( Attribute_value_unquoted_state [_] ) 

name:Attribute_value_double_quoted_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
trans:
char:U+0022 QUOTATION MARK (")
Switch to the After_attribute_value_quoted_state
 =>  switch_to ( After_attribute_value_quoted_state [_] ) 
char:U+0026 AMPERSAND (&amp;)
Set the return state to the Attribute_value_double_quoted_state
 =>  set_to ( return_state [_] , Attribute_value_double_quoted_state [_] ) 
Switch to the Character_reference_state
 =>  switch_to ( Character_reference_state [_] ) 
char:U+0000 NULL
This is an unexpected-null-character parse error
 =>  append_to ( unexpected-null-character_parse_error [_] , unexpected-null-character_parse_error [_] ) 
Append a U+FFFD REPLACEMENT CHARACTER character to the current attribute 's value
 =>  append_to ( U+FFFD_REPLACEMENT_CHARACTER_character_token [_] , attribute [_] . value ) 
char:EOF
This is an eof-in-tag parse error
 =>  append_to ( eof-in-tag_parse_error [_] , parse_error [_] ) 
Emit an end-of-file token
 =>  emit ( end-of-file_token [_] ) 
char:Anything else
Append the current input character to the current attribute 's value
 =>  append_to ( current_input_character [_] , current_input_character [_] . value ) 

name:Attribute_value_single_quoted_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
trans:
char:U+0027 APOSTROPHE (')
Switch to the After_attribute_value_quoted_state
 =>  switch_to ( After_attribute_value_quoted_state [_] ) 
char:U+0026 AMPERSAND (&amp;)
Set the return state to the Attribute_value_single_quoted_state
 =>  set_to ( return_state [_] , Attribute_value_single_quoted_state [_] ) 
Switch to the Character_reference_state
 =>  switch_to ( Character_reference_state [_] ) 
char:U+0000 NULL
This is an unexpected-null-character parse error
 =>  append_to ( unexpected-null-character_parse_error [_] , unexpected-null-character_parse_error [_] ) 
Append a U+FFFD REPLACEMENT CHARACTER character to the current attribute 's value
 =>  append_to ( U+FFFD_REPLACEMENT_CHARACTER_character_token [_] , attribute [_] . value ) 
char:EOF
This is an eof-in-tag parse error
 =>  append_to ( eof-in-tag_parse_error [_] , parse_error [_] ) 
Emit an end-of-file token
 =>  emit ( end-of-file_token [_] ) 
char:Anything else
Append the current input character to the current attribute 's value
 =>  append_to ( current_input_character [_] , current_input_character [_] . value ) 

name:Attribute_value_unquoted_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
trans:
char:U+0009 CHARACTER TABULATION (tab)
Switch to the Before_attribute_name_state
 =>  switch_to ( Before_attribute_name_state [_] ) 
char:U+000A LINE FEED (LF)
Switch to the Before_attribute_name_state
 =>  switch_to ( Before_attribute_name_state [_] ) 
char:U+000C FORM FEED (FF)
Switch to the Before_attribute_name_state
 =>  switch_to ( Before_attribute_name_state [_] ) 
char:U+0020 SPACE
Switch to the Before_attribute_name_state
 =>  switch_to ( Before_attribute_name_state [_] ) 
char:U+0026 AMPERSAND (&amp;)
Set the return state to the Attribute_value_unquoted_state
 =>  set_to ( return_state [_] , Attribute_value_unquoted_state [_] ) 
Switch to the Character_reference_state
 =>  switch_to ( Character_reference_state [_] ) 
char:U+003E GREATER-THAN SIGN (&gt;)
Switch to the Data_state
 =>  switch_to ( Data_state [_] ) 
Emit the current tag token
 =>  emit ( current_tag_token [_] ) 
char:U+0000 NULL
This is an unexpected-null-character parse error
 =>  append_to ( unexpected-null-character_parse_error [_] , unexpected-null-character_parse_error [_] ) 
Append a U+FFFD REPLACEMENT CHARACTER character to the current attribute 's value
 =>  append_to ( U+FFFD_REPLACEMENT_CHARACTER_character_token [_] , attribute [_] . value ) 
char:U+0022 QUOTATION MARK (")
This [0] is an unexpected-character-in-unquoted-attribute-value parse error
 =>  append_to ( unexpected-character-in-unquoted-attribute-value_parse_error [0] , unexpected-character-in-unquoted-attribute-value_parse_error [_] ) 
Treat This [0] as per the anything else entry below
 =>  this_is_parse_error ( Tag_open_state [0] ) 
char:U+0027 APOSTROPHE (')
This [0] is an unexpected-character-in-unquoted-attribute-value parse error
 =>  append_to ( unexpected-character-in-unquoted-attribute-value_parse_error [0] , unexpected-character-in-unquoted-attribute-value_parse_error [_] ) 
Treat This [0] as per the anything else entry below
 =>  this_is_parse_error ( Tag_open_state [0] ) 
char:U+003C LESS-THAN SIGN (&lt;)
This [0] is an unexpected-character-in-unquoted-attribute-value parse error
 =>  append_to ( unexpected-character-in-unquoted-attribute-value_parse_error [0] , unexpected-character-in-unquoted-attribute-value_parse_error [_] ) 
Treat This [0] as per the anything else entry below
 =>  this_is_parse_error ( Tag_open_state [0] ) 
char:U+003D EQUALS SIGN (=)
This [0] is an unexpected-character-in-unquoted-attribute-value parse error
 =>  append_to ( unexpected-character-in-unquoted-attribute-value_parse_error [0] , unexpected-character-in-unquoted-attribute-value_parse_error [_] ) 
Treat This [0] as per the anything else entry below
 =>  this_is_parse_error ( Tag_open_state [0] ) 
char:U+0060 GRAVE ACCENT (`)
This [0] is an unexpected-character-in-unquoted-attribute-value parse error
 =>  append_to ( unexpected-character-in-unquoted-attribute-value_parse_error [0] , unexpected-character-in-unquoted-attribute-value_parse_error [_] ) 
Treat This [0] as per the anything else entry below
 =>  this_is_parse_error ( Tag_open_state [0] ) 
char:EOF
This is an eof-in-tag parse error
 =>  append_to ( eof-in-tag_parse_error [_] , parse_error [_] ) 
Emit an end-of-file token
 =>  emit ( end-of-file_token [_] ) 
char:Anything else
Append the current input character to the current attribute 's value
 =>  append_to ( current_input_character [_] , current_input_character [_] . value ) 

name:After_attribute_value_quoted_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
trans:
char:U+0009 CHARACTER TABULATION (tab)
Switch to the Before_attribute_name_state
 =>  switch_to ( Before_attribute_name_state [_] ) 
char:U+000A LINE FEED (LF)
Switch to the Before_attribute_name_state
 =>  switch_to ( Before_attribute_name_state [_] ) 
char:U+000C FORM FEED (FF)
Switch to the Before_attribute_name_state
 =>  switch_to ( Before_attribute_name_state [_] ) 
char:U+0020 SPACE
Switch to the Before_attribute_name_state
 =>  switch_to ( Before_attribute_name_state [_] ) 
char:U+002F SOLIDUS (/)
Switch to the Self_closing_start_tag_state
 =>  switch_to ( Self_closing_start_tag_state [_] ) 
char:U+003E GREATER-THAN SIGN (&gt;)
Switch to the Data_state
 =>  switch_to ( Data_state [_] ) 
Emit the current tag token
 =>  emit ( current_tag_token [_] ) 
char:EOF
This is an eof-in-tag parse error
 =>  append_to ( eof-in-tag_parse_error [_] , parse_error [_] ) 
Emit an end-of-file token
 =>  emit ( end-of-file_token [_] ) 
char:Anything else
This is a missing-whitespace-between-attributes parse error
 =>  this_is_parse_error ( missing-whitespace-between-attributes_parse_error [_] ) 
Reconsume in the Before_attribute_name_state
 =>  reconsume_in ( Before_attribute_name_state [_] ) 

name:Self_closing_start_tag_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
trans:
char:U+003E GREATER-THAN SIGN (&gt;)
Set the self-closing flag of the current tag token [0]
 =>  set_to ( current_tag_token [0] . self-closing_flag , current_tag_token [0] ) 
Switch to the Data_state
 =>  switch_to ( Data_state [_] ) 
Emit the current tag token [0]
 =>  emit ( current_tag_token [0] ) 
char:EOF
This is an eof-in-tag parse error
 =>  append_to ( eof-in-tag_parse_error [_] , parse_error [_] ) 
Emit an end-of-file token
 =>  emit ( end-of-file_token [_] ) 
char:Anything else
This is an unexpected-solidus-in-tag parse error
 =>  append_to ( unexpected-solidus-in-tag_parse_error [_] , unexpected-solidus-in-tag_parse_error [_] ) 
Reconsume in the Before_attribute_name_state
 =>  reconsume_in ( Before_attribute_name_state [_] ) 

name:Bogus_comment_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
trans:
char:U+003E GREATER-THAN SIGN (&gt;)
Switch to the Data_state
 =>  switch_to ( Data_state [_] ) 
Emit the comment token
 =>  emit ( comment_token [_] ) 
char:EOF
Emit the comment
 =>  emit ( comment_token [_] ) 
Emit an end-of-file token
 =>  emit ( end-of-file_token [_] ) 
char:U+0000 NULL
This is an unexpected-null-character parse error
 =>  append_to ( unexpected-null-character_parse_error [_] , unexpected-null-character_parse_error [_] ) 
Append a U+FFFD REPLACEMENT CHARACTER character to the comment token 's data
 =>  append_to ( U+FFFD_REPLACEMENT_CHARACTER_character_token [_] , comment_token [_] . data ) 
char:Anything else
Append the current input character to the comment token 's data
 =>  append_to ( current_input_character [_] , comment_token [_] . data ) 

name:Markup_declaration_open_state
prev:
If the next few characters are 
 =>  if_then ( next_input_character [_] ) 
trans:
char:Two U+002D HYPHEN-MINUS characters (-)
Consume those two characters , create a comment token whose data is the empty string , and switch to the Comment_start_state
 =>  consume ( RCDATA_end_tag_open_state [_] ) | create ( comment_token [_] . data ) | this_is_parse_error ( Comment_start_state [_] ) 
char:ASCII case-insensitive match for the word "DOCTYPE"
Consume those characters and switch to the DOCTYPE_state
 =>  consume ( Before_DOCTYPE_system_identifier_state [_] ) | switch_to ( DOCTYPE_state [_] ) 
char:The string "[CDATA[" (the five uppercase letters "CDATA" with a U+005B LEFT SQUARE BRACKET character before and after)
Consume those characters
 =>  consume ( RCDATA_end_tag_open_state [_] ) 
If there is an adjusted current node [0] and an adjusted current node [0] is not an element in the HTML namespace , then switch to the CDATA_section_state
 =>  if_then ( the_current_end_tag_token_is_an_appropriate_end_tag_token , set_to ( the_current_end_tag_token_is_an_appropriate_end_tag_token , invalid-first-character-of-tag-name_parse_error [_] ) , switch_to ( CDATA_section_state [_] ) ) 
Otherwise , this is a cdata-in-html-content parse error
 =>  otherwise ( set_to ( cdata-in-html-content_parse_error [_] , cdata-in-html-content_parse_error [_] ) ) 
Create a comment token whose data is the [ CDATA [ string
 =>  create ( comment_token [_] . data ) 
Switch to the Bogus_comment_state
 =>  switch_to ( Bogus_comment_state [_] ) 
char:Anything else
This is an incorrectly-opened-comment parse error
 =>  this_is_parse_error ( incorrectly-opened-comment_parse_error [_] ) 
Create a comment token whose data is the empty string
 =>  create ( comment_token [_] . data ) 
Switch to the Bogus_comment_state ( do n't consume anything in the current state 
 =>  switch_to ( Bogus_comment_state [_] ) 

name:Comment_start_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
trans:
char:U+002D HYPHEN-MINUS (-)
Switch to the Comment_start_dash_state
 =>  switch_to ( Comment_start_dash_state [_] ) 
char:U+003E GREATER-THAN SIGN (&gt;)
This is an abrupt-closing-of-empty-comment parse error
 =>  append_to ( abrupt-closing-of-empty-comment_parse_error [_] , abrupt-closing-of-empty-comment_parse_error [_] ) 
Switch to the Data_state
 =>  switch_to ( Data_state [_] ) 
Emit the comment token
 =>  emit ( comment_token [_] ) 
char:Anything else
Reconsume in the Comment_state
 =>  reconsume_in ( Comment_state [_] ) 

name:Comment_start_dash_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
trans:
char:U+002D HYPHEN-MINUS (-)
Switch to the Comment_end_state
 =>  switch_to ( Comment_end_state [_] ) 
char:U+003E GREATER-THAN SIGN (&gt;)
This is an abrupt-closing-of-empty-comment parse error
 =>  append_to ( abrupt-closing-of-empty-comment_parse_error [_] , abrupt-closing-of-empty-comment_parse_error [_] ) 
Switch to the Data_state
 =>  switch_to ( Data_state [_] ) 
Emit the comment token
 =>  emit ( comment_token [_] ) 
char:EOF
This is an eof-in-comment parse error
 =>  this_is_parse_error ( eof-in-comment_parse_error [_] ) 
Emit the comment token
 =>  emit ( comment_token [_] ) 
Emit an end-of-file token
 =>  emit ( end-of-file_token [_] ) 
char:Anything else
Append a U+002D HYPHEN-MINUS character (-) to the comment token 's data
 =>  append_to ( U+002D_HYPHEN-MINUS_character_token [_] , comment_token [_] . data ) 
Reconsume in the Comment_state
 =>  reconsume_in ( Comment_state [_] ) 

name:Comment_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
trans:
char:U+003C LESS-THAN SIGN (&lt;)
Append the current input character to the comment token 's data
 =>  append_to ( current_input_character [_] , comment_token [_] . data ) 
Switch to the Comment_less_than_sign_state
 =>  switch_to ( Comment_less_than_sign_state [_] ) 
char:U+002D HYPHEN-MINUS (-)
Switch to the Comment_end_dash_state
 =>  switch_to ( Comment_end_dash_state [_] ) 
char:U+0000 NULL
This is an unexpected-null-character parse error
 =>  append_to ( unexpected-null-character_parse_error [_] , unexpected-null-character_parse_error [_] ) 
Append a U+FFFD REPLACEMENT CHARACTER character to the comment token 's data
 =>  append_to ( U+FFFD_REPLACEMENT_CHARACTER_character_token [_] , comment_token [_] . data ) 
char:EOF
This is an eof-in-comment parse error
 =>  this_is_parse_error ( eof-in-comment_parse_error [_] ) 
Emit the comment token
 =>  emit ( comment_token [_] ) 
Emit an end-of-file token
 =>  emit ( end-of-file_token [_] ) 
char:Anything else
Append the current input character to the comment token 's data
 =>  append_to ( current_input_character [_] , comment_token [_] . data ) 

name:Comment_less_than_sign_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
trans:
char:U+0021 EXCLAMATION MARK (!)
Append the current input character to the comment token 's data
 =>  append_to ( current_input_character [_] , comment_token [_] . data ) 
Switch to the Comment_less_than_sign_bang_state
 =>  switch_to ( Comment_less_than_sign_bang_state [_] ) 
char:U+003C LESS-THAN SIGN (&lt;)
Append the current input character to the comment token 's data
 =>  append_to ( current_input_character [_] , comment_token [_] . data ) 
char:Anything else
Reconsume in the Comment_state
 =>  reconsume_in ( Comment_state [_] ) 

name:Comment_less_than_sign_bang_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
trans:
char:U+002D HYPHEN-MINUS (-)
Switch to the Comment_less_than_sign_bang_dash_state
 =>  switch_to ( Comment_less_than_sign_bang_dash_state [_] ) 
char:Anything else
Reconsume in the Comment_state
 =>  reconsume_in ( Comment_state [_] ) 

name:Comment_less_than_sign_bang_dash_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
trans:
char:U+002D HYPHEN-MINUS (-)
Switch to the Comment_less_than_sign_bang_dash_dash_state
 =>  switch_to ( Comment_less_than_sign_bang_dash_dash_state [_] ) 
char:Anything else
Reconsume in the Comment_end_dash_state
 =>  reconsume_in ( Comment_end_dash_state [_] ) 

name:Comment_less_than_sign_bang_dash_dash_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
trans:
char:U+003E GREATER-THAN SIGN (&gt;)
Reconsume in the Comment_end_state
 =>  reconsume_in ( Comment_end_state [_] ) 
char:EOF
Reconsume in the Comment_end_state
 =>  reconsume_in ( Comment_end_state [_] ) 
char:Anything else
This is a nested-comment parse error
 =>  this_is_parse_error ( nested-comment_parse_error [_] ) 
Reconsume in the Comment_end_state
 =>  reconsume_in ( Comment_end_state [_] ) 

name:Comment_end_dash_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
trans:
char:U+002D HYPHEN-MINUS (-)
Switch to the Comment_end_state
 =>  switch_to ( Comment_end_state [_] ) 
char:EOF
This is an eof-in-comment parse error
 =>  this_is_parse_error ( eof-in-comment_parse_error [_] ) 
Emit the comment token
 =>  emit ( comment_token [_] ) 
Emit an end-of-file token
 =>  emit ( end-of-file_token [_] ) 
char:Anything else
Append a U+002D HYPHEN-MINUS character (-) to the comment token 's data
 =>  append_to ( U+002D_HYPHEN-MINUS_character_token [_] , comment_token [_] . data ) 
Reconsume in the Comment_state
 =>  reconsume_in ( Comment_state [_] ) 

name:Comment_end_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
trans:
char:U+003E GREATER-THAN SIGN (&gt;)
Switch to the Data_state
 =>  switch_to ( Data_state [_] ) 
Emit the comment token
 =>  emit ( comment_token [_] ) 
char:U+0021 EXCLAMATION MARK (!)
Switch to the Comment_end_bang_state
 =>  switch_to ( Comment_end_bang_state [_] ) 
char:U+002D HYPHEN-MINUS (-)
Append a U+002D HYPHEN-MINUS character (-) to the comment token 's data
 =>  append_to ( U+002D_HYPHEN-MINUS_character_token [_] , comment_token [_] . data ) 
char:EOF
This is an eof-in-comment parse error
 =>  this_is_parse_error ( eof-in-comment_parse_error [_] ) 
Emit the comment token
 =>  emit ( comment_token [_] ) 
Emit an end-of-file token
 =>  emit ( end-of-file_token [_] ) 
char:Anything else
Append two U+002D HYPHEN-MINUS characters (-) to the comment token 's data
 =>  append_to ( U+002D_HYPHEN-MINUS_character_token [_] , comment_token [_] . data ) 
Reconsume in the Comment_state
 =>  reconsume_in ( Comment_state [_] ) 

name:Comment_end_bang_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
trans:
char:U+002D HYPHEN-MINUS (-)
Append two U+002D HYPHEN-MINUS characters (-) and a U+0021 EXCLAMATION MARK character ( -EXC- ) to the comment token 's data
 =>  append_to ( U+002D_HYPHEN-MINUS_character_token [_] , comment_token [_] . data ) | append_to ( U+0021_EXCLAMATION_MARK_character_token [_] , comment_token [_] . data ) 
Switch to the Comment_end_dash_state
 =>  switch_to ( Comment_end_dash_state [_] ) 
char:U+003E GREATER-THAN SIGN (&gt;)
This is an incorrectly-closed-comment parse error
 =>  this_is_parse_error ( incorrectly-closed-comment_parse_error [_] ) 
Switch to the Data_state
 =>  switch_to ( Data_state [_] ) 
Emit the comment token
 =>  emit ( comment_token [_] ) 
char:EOF
This is an eof-in-comment parse error
 =>  this_is_parse_error ( eof-in-comment_parse_error [_] ) 
Emit the comment token
 =>  emit ( comment_token [_] ) 
Emit an end-of-file token
 =>  emit ( end-of-file_token [_] ) 
char:Anything else
Append two U+002D HYPHEN-MINUS characters (-) and a U+0021 EXCLAMATION MARK character ( ! ) to the comment token 's data
 =>  append_to ( U+002D_HYPHEN-MINUS_character_token [_] , comment_token [_] . data ) | append_to ( U+0021_EXCLAMATION_MARK_character_token [_] , comment_token [_] . data ) 
Reconsume in the Comment_state
 =>  reconsume_in ( Comment_state [_] ) 

name:DOCTYPE_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
trans:
char:U+0009 CHARACTER TABULATION (tab)
Switch to the Before_DOCTYPE_name_state
 =>  switch_to ( Before_DOCTYPE_name_state [_] ) 
char:U+000A LINE FEED (LF)
Switch to the Before_DOCTYPE_name_state
 =>  switch_to ( Before_DOCTYPE_name_state [_] ) 
char:U+000C FORM FEED (FF)
Switch to the Before_DOCTYPE_name_state
 =>  switch_to ( Before_DOCTYPE_name_state [_] ) 
char:U+0020 SPACE
Switch to the Before_DOCTYPE_name_state
 =>  switch_to ( Before_DOCTYPE_name_state [_] ) 
char:U+003E GREATER-THAN SIGN (&gt;)
Reconsume in the Before_DOCTYPE_name_state
 =>  reconsume_in ( Before_DOCTYPE_name_state [_] ) 
char:EOF
This is an eof-in-doctype parse error
 =>  append_to ( eof-in-doctype_parse_error [_] , eof-in-doctype_parse_error [_] ) 
Create a new DOCTYPE token [0]
 =>  create ( DOCTYPE_token [0] ) 
Set a new DOCTYPE token [0] force-quirks flag to on
 =>  set_to ( DOCTYPE_token [0] . force-quirks_flag , on [_] ) 
Emit a new DOCTYPE token [0]
 =>  emit ( DOCTYPE_token [0] ) 
Emit an end-of-file token
 =>  emit ( end-of-file_token [_] ) 
char:Anything else
This is a missing-whitespace-before-doctype-name parse error
 =>  append_to ( missing-whitespace-before-doctype-name_parse_error [_] , missing-whitespace-before-doctype-name_parse_error [_] ) 
Reconsume in the Before_DOCTYPE_name_state
 =>  reconsume_in ( Before_DOCTYPE_name_state [_] ) 

name:Before_DOCTYPE_name_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
trans:
char:U+0009 CHARACTER TABULATION (tab)
Ignore the character
 =>  ignore_the_character 
char:U+000A LINE FEED (LF)
Ignore the character
 =>  ignore_the_character 
char:U+000C FORM FEED (FF)
Ignore the character
 =>  ignore_the_character 
char:U+0020 SPACE
Ignore the character
 =>  ignore_the_character 
char:ASCII upper alpha
Create a new DOCTYPE token [0]
 =>  create ( DOCTYPE_token [0] ) 
Set a new DOCTYPE token [0] name to the lowercase version of the current input character [1] ( add 0x0020 to the current input character [1] code point 
 =>  set_to ( DOCTYPE_token [0] . name , current_input_character [1] . lowercase_version ) 
Switch to the DOCTYPE_name_state
 =>  switch_to ( DOCTYPE_name_state [_] ) 
char:U+0000 NULL
This is an unexpected-null-character parse error
 =>  append_to ( unexpected-null-character_parse_error [_] , unexpected-null-character_parse_error [_] ) 
Create a new DOCTYPE token [0]
 =>  create ( DOCTYPE_token [0] ) 
Set a new DOCTYPE token [0] name to a U+FFFD REPLACEMENT CHARACTER character
 =>  set_to ( DOCTYPE_token [0] . name , U+FFFD_REPLACEMENT_CHARACTER_character_token [_] ) 
Switch to the DOCTYPE_name_state
 =>  switch_to ( DOCTYPE_name_state [_] ) 
char:U+003E GREATER-THAN SIGN (&gt;)
This is a missing-doctype-name parse error
 =>  this_is_parse_error ( missing-doctype-name_parse_error [_] ) 
Create a new DOCTYPE token [0]
 =>  create ( DOCTYPE_token [0] ) 
Set a new DOCTYPE token [0] force-quirks flag to on
 =>  set_to ( DOCTYPE_token [0] . force-quirks_flag , on [_] ) 
Switch to the Data_state
 =>  switch_to ( Data_state [_] ) 
Emit a new DOCTYPE token [0]
 =>  emit ( DOCTYPE_token [0] ) 
char:EOF
This is an eof-in-doctype parse error
 =>  append_to ( eof-in-doctype_parse_error [_] , eof-in-doctype_parse_error [_] ) 
Create a new DOCTYPE token [0]
 =>  create ( DOCTYPE_token [0] ) 
Set a new DOCTYPE token [0]   force-quirks flag to on
 =>  set_to ( DOCTYPE_token [0] . force-quirks_flag , on [_] ) 
Emit a new DOCTYPE token [0]
 =>  emit ( DOCTYPE_token [0] ) 
Emit an end-of-file token
 =>  emit ( end-of-file_token [_] ) 
char:Anything else
Create a new DOCTYPE token [0]
 =>  create ( DOCTYPE_token [0] ) 
Set a new DOCTYPE token [0] name to the current input character
 =>  set_to ( DOCTYPE_token [0] . name , current_input_character [_] ) 
Switch to the DOCTYPE_name_state
 =>  switch_to ( DOCTYPE_name_state [_] ) 

name:DOCTYPE_name_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
trans:
char:U+0009 CHARACTER TABULATION (tab)
Switch to the After_DOCTYPE_name_state
 =>  switch_to ( After_DOCTYPE_name_state [_] ) 
char:U+000A LINE FEED (LF)
Switch to the After_DOCTYPE_name_state
 =>  switch_to ( After_DOCTYPE_name_state [_] ) 
char:U+000C FORM FEED (FF)
Switch to the After_DOCTYPE_name_state
 =>  switch_to ( After_DOCTYPE_name_state [_] ) 
char:U+0020 SPACE
Switch to the After_DOCTYPE_name_state
 =>  switch_to ( After_DOCTYPE_name_state [_] ) 
char:U+003E GREATER-THAN SIGN (&gt;)
Switch to the Data_state
 =>  switch_to ( Data_state [_] ) 
Emit the current DOCTYPE token
 =>  emit ( current_tag_token [_] ) 
char:ASCII upper alpha
Append the lowercase version of the current input character [0] ( add 0x0020 to the current input character [0] code point ) to the current DOCTYPE token 's name
 =>  append_to ( current_input_character [0] . lowercase_version , current_tag_token [_] . name ) 
char:U+0000 NULL
This is an unexpected-null-character parse error
 =>  append_to ( unexpected-null-character_parse_error [_] , unexpected-null-character_parse_error [_] ) 
Append a U+FFFD REPLACEMENT CHARACTER character to the current DOCTYPE token 's name
 =>  append_to ( U+FFFD_REPLACEMENT_CHARACTER_character_token [_] , current_tag_token [_] . name ) 
char:EOF
This is an eof-in-doctype parse error
 =>  append_to ( eof-in-doctype_parse_error [_] , eof-in-doctype_parse_error [_] ) 
Set the DOCTYPE token 's [0] force-quirks flag to on
 =>  set_to ( DOCTYPE_token [0] . force-quirks_flag , on [_] ) 
Emit the DOCTYPE token 's [0]
 =>  emit ( DOCTYPE_token [0] . DOCTYPE_state ) 
Emit an end-of-file token
 =>  emit ( end-of-file_token [_] ) 
char:Anything else
Append the current input character to the current DOCTYPE token 's name
 =>  append_to ( current_input_character [_] , current_tag_token [_] . name ) 

name:After_DOCTYPE_name_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
trans:
char:U+0009 CHARACTER TABULATION (tab)
Ignore the character
 =>  ignore_the_character 
char:U+000A LINE FEED (LF)
Ignore the character
 =>  ignore_the_character 
char:U+000C FORM FEED (FF)
Ignore the character
 =>  ignore_the_character 
char:U+0020 SPACE
Ignore the character
 =>  ignore_the_character 
char:U+003E GREATER-THAN SIGN (&gt;)
Switch to the Data_state
 =>  switch_to ( Data_state [_] ) 
Emit the current DOCTYPE token
 =>  emit ( current_tag_token [_] ) 
char:EOF
This is an eof-in-doctype parse error
 =>  append_to ( eof-in-doctype_parse_error [_] , eof-in-doctype_parse_error [_] ) 
Set the DOCTYPE token 's [0] force-quirks flag to on
 =>  set_to ( DOCTYPE_token [0] . force-quirks_flag , on [_] ) 
Emit the DOCTYPE token 's [0]
 =>  emit ( DOCTYPE_token [0] . DOCTYPE_state ) 
Emit an end-of-file token
 =>  emit ( end-of-file_token [_] ) 
char:Anything else
If the six characters starting from the current input character [0] are an ASCII case-insensitive match for the word PUBLIC , then consume the six characters starting from the current input character [0] and switch to the After_DOCTYPE_public_keyword_state
 =>  if_then ( the_current_end_tag_token_is_an_appropriate_end_tag_token , append_to ( RCDATA_end_tag_open_state [0] , current_input_character [0] ) , consume ( current_input_character [0] ) | consume ( After_DOCTYPE_public_keyword_state [_] ) ) 
Otherwise , if the six characters starting from the current input character [2] are an ASCII case-insensitive match for the word SYSTEM , then consume the six characters starting from the current input character [2] and switch to the After_DOCTYPE_system_keyword_state
 =>  otherwise ( the_character_reference_was_consumed_as_part_of_an_attribute , append_to ( RCDATA_end_tag_open_state [2] , After_DOCTYPE_system_keyword_state [_] ) , consume ( Script_data_end_tag_name_state [2] ) | consume ( After_DOCTYPE_system_keyword_state [_] ) ) 
Otherwise , this is an invalid-character-sequence-after-doctype-name parse error
 =>  otherwise ( set_to ( invalid-character-sequence-after-doctype-name_parse_error [_] , invalid-character-sequence-after-doctype-name_parse_error [_] ) ) 
Set the DOCTYPE token 's force-quirks flag to on
 =>  set_to ( DOCTYPE_token [_] . force-quirks_flag , on [_] ) 
Reconsume in the Bogus_DOCTYPE_state
 =>  reconsume_in ( Bogus_DOCTYPE_state [_] ) 

name:After_DOCTYPE_public_keyword_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
trans:
char:U+0009 CHARACTER TABULATION (tab)
Switch to the Before_DOCTYPE_public_identifier_state
 =>  switch_to ( Before_DOCTYPE_public_identifier_state [_] ) 
char:U+000A LINE FEED (LF)
Switch to the Before_DOCTYPE_public_identifier_state
 =>  switch_to ( Before_DOCTYPE_public_identifier_state [_] ) 
char:U+000C FORM FEED (FF)
Switch to the Before_DOCTYPE_public_identifier_state
 =>  switch_to ( Before_DOCTYPE_public_identifier_state [_] ) 
char:U+0020 SPACE
Switch to the Before_DOCTYPE_public_identifier_state
 =>  switch_to ( Before_DOCTYPE_public_identifier_state [_] ) 
char:U+0022 QUOTATION MARK (")
This is a missing-whitespace-after-doctype-public-keyword parse error
 =>  this_is_parse_error ( missing-whitespace-after-doctype-public-keyword_parse_error [_] ) 
Set the DOCTYPE token 's public identifier to the empty string ( not missing ) , then switch to the DOCTYPE_public_identifier_double_quoted_state
 =>  set_to ( DOCTYPE_token [_] . public_identifier , empty_string [_] ) | switch_to ( DOCTYPE_public_identifier_double_quoted_state [_] ) 
char:U+0027 APOSTROPHE (')
This is a missing-whitespace-after-doctype-public-keyword parse error
 =>  this_is_parse_error ( missing-whitespace-after-doctype-public-keyword_parse_error [_] ) 
Set the DOCTYPE token 's public identifier to the empty string ( not missing ) , then switch to the DOCTYPE_public_identifier_single_quoted_state
 =>  set_to ( DOCTYPE_token [_] . public_identifier , empty_string [_] ) | switch_to ( DOCTYPE_public_identifier_single_quoted_state [_] ) 
char:U+003E GREATER-THAN SIGN (&gt;)
This is a missing-doctype-public-identifier parse error
 =>  this_is_parse_error ( missing-doctype-public-identifier_parse_error [_] ) 
Set the DOCTYPE token 's [0] force-quirks flag to on
 =>  set_to ( DOCTYPE_token [0] . force-quirks_flag , on [_] ) 
Switch to the Data_state
 =>  switch_to ( Data_state [_] ) 
Emit the DOCTYPE token 's [0]
 =>  emit ( DOCTYPE_token [0] . DOCTYPE_state ) 
char:EOF
This is an eof-in-doctype parse error
 =>  append_to ( eof-in-doctype_parse_error [_] , eof-in-doctype_parse_error [_] ) 
Set the DOCTYPE token 's [0] force-quirks flag to on
 =>  set_to ( DOCTYPE_token [0] . force-quirks_flag , on [_] ) 
Emit the DOCTYPE token 's [0]
 =>  emit ( DOCTYPE_token [0] . DOCTYPE_state ) 
Emit an end-of-file token
 =>  emit ( end-of-file_token [_] ) 
char:Anything else
This is a missing-quote-before-doctype-public-identifier parse error
 =>  this_is_parse_error ( missing-quote-before-doctype-public-identifier_parse_error [_] ) 
Set the DOCTYPE token 's force-quirks flag to on
 =>  set_to ( DOCTYPE_token [_] . force-quirks_flag , on [_] ) 
Reconsume in the Bogus_DOCTYPE_state
 =>  reconsume_in ( Bogus_DOCTYPE_state [_] ) 

name:Before_DOCTYPE_public_identifier_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
trans:
char:U+0009 CHARACTER TABULATION (tab)
Ignore the character
 =>  ignore_the_character 
char:U+000A LINE FEED (LF)
Ignore the character
 =>  ignore_the_character 
char:U+000C FORM FEED (FF)
Ignore the character
 =>  ignore_the_character 
char:U+0020 SPACE
Ignore the character
 =>  ignore_the_character 
char:U+0022 QUOTATION MARK (")
Set the DOCTYPE token 's public identifier to the empty string ( not missing ) , then switch to the DOCTYPE_public_identifier_double_quoted_state
 =>  set_to ( DOCTYPE_token [_] . public_identifier , empty_string [_] ) | switch_to ( DOCTYPE_public_identifier_double_quoted_state [_] ) 
char:U+0027 APOSTROPHE (')
Set the DOCTYPE token 's public identifier to the empty string ( not missing ) , then switch to the DOCTYPE_public_identifier_single_quoted_state
 =>  set_to ( DOCTYPE_token [_] . public_identifier , empty_string [_] ) | switch_to ( DOCTYPE_public_identifier_single_quoted_state [_] ) 
char:U+003E GREATER-THAN SIGN (&gt;)
This is a missing-doctype-public-identifier parse error
 =>  this_is_parse_error ( missing-doctype-public-identifier_parse_error [_] ) 
Set the DOCTYPE token 's [0] force-quirks flag to on
 =>  set_to ( DOCTYPE_token [0] . force-quirks_flag , on [_] ) 
Switch to the Data_state
 =>  switch_to ( Data_state [_] ) 
Emit the DOCTYPE token 's [0]
 =>  emit ( DOCTYPE_token [0] . DOCTYPE_state ) 
char:EOF
This is an eof-in-doctype parse error
 =>  append_to ( eof-in-doctype_parse_error [_] , eof-in-doctype_parse_error [_] ) 
Set the DOCTYPE token 's [0] force-quirks flag to on
 =>  set_to ( DOCTYPE_token [0] . force-quirks_flag , on [_] ) 
Emit the DOCTYPE token 's [0]
 =>  emit ( DOCTYPE_token [0] . DOCTYPE_state ) 
Emit an end-of-file token
 =>  emit ( end-of-file_token [_] ) 
char:Anything else
This is a missing-quote-before-doctype-public-identifier parse error
 =>  this_is_parse_error ( missing-quote-before-doctype-public-identifier_parse_error [_] ) 
Set the DOCTYPE token 's force-quirks flag to on
 =>  set_to ( DOCTYPE_token [_] . force-quirks_flag , on [_] ) 
Reconsume in the Bogus_DOCTYPE_state
 =>  reconsume_in ( Bogus_DOCTYPE_state [_] ) 

name:DOCTYPE_public_identifier_double_quoted_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
trans:
char:U+0022 QUOTATION MARK (")
Switch to the After_DOCTYPE_public_identifier_state
 =>  switch_to ( After_DOCTYPE_public_identifier_state [_] ) 
char:U+0000 NULL
This is an unexpected-null-character parse error
 =>  append_to ( unexpected-null-character_parse_error [_] , unexpected-null-character_parse_error [_] ) 
Append a U+FFFD REPLACEMENT CHARACTER character to the current DOCTYPE token 's public identifier
 =>  append_to ( U+FFFD_REPLACEMENT_CHARACTER_character_token [_] , current_tag_token [_] . public_identifier ) 
char:U+003E GREATER-THAN SIGN (&gt;)
This is an abrupt-doctype-public-identifier parse error
 =>  append_to ( abrupt-doctype-public-identifier_parse_error [_] , abrupt-doctype-public-identifier_parse_error [_] ) 
Set the DOCTYPE token 's [0] force-quirks flag to on
 =>  set_to ( DOCTYPE_token [0] . force-quirks_flag , on [_] ) 
Switch to the Data_state
 =>  switch_to ( Data_state [_] ) 
Emit the DOCTYPE token 's [0]
 =>  emit ( DOCTYPE_token [0] . DOCTYPE_state ) 
char:EOF
This is an eof-in-doctype parse error
 =>  append_to ( eof-in-doctype_parse_error [_] , eof-in-doctype_parse_error [_] ) 
Set the DOCTYPE token 's [0] force-quirks flag to on
 =>  set_to ( DOCTYPE_token [0] . force-quirks_flag , on [_] ) 
Emit the DOCTYPE token 's [0]
 =>  emit ( DOCTYPE_token [0] . DOCTYPE_state ) 
Emit an end-of-file token
 =>  emit ( end-of-file_token [_] ) 
char:Anything else
Append the current input character to the current DOCTYPE token 's public identifier
 =>  append_to ( current_input_character [_] , current_tag_token [_] . public_identifier ) 

name:DOCTYPE_public_identifier_single_quoted_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
trans:
char:U+0027 APOSTROPHE (')
Switch to the After_DOCTYPE_public_identifier_state
 =>  switch_to ( After_DOCTYPE_public_identifier_state [_] ) 
char:U+0000 NULL
This is an unexpected-null-character parse error
 =>  append_to ( unexpected-null-character_parse_error [_] , unexpected-null-character_parse_error [_] ) 
Append a U+FFFD REPLACEMENT CHARACTER character to the current DOCTYPE token 's public identifier
 =>  append_to ( U+FFFD_REPLACEMENT_CHARACTER_character_token [_] , current_tag_token [_] . public_identifier ) 
char:U+003E GREATER-THAN SIGN (&gt;)
This is an abrupt-doctype-public-identifier parse error
 =>  append_to ( abrupt-doctype-public-identifier_parse_error [_] , abrupt-doctype-public-identifier_parse_error [_] ) 
Set the DOCTYPE token 's [0] force-quirks flag to on
 =>  set_to ( DOCTYPE_token [0] . force-quirks_flag , on [_] ) 
Switch to the Data_state
 =>  switch_to ( Data_state [_] ) 
Emit the DOCTYPE token 's [0]
 =>  emit ( DOCTYPE_token [0] . DOCTYPE_state ) 
char:EOF
This is an eof-in-doctype parse error
 =>  append_to ( eof-in-doctype_parse_error [_] , eof-in-doctype_parse_error [_] ) 
Set the DOCTYPE token 's [0] force-quirks flag to on
 =>  set_to ( DOCTYPE_token [0] . force-quirks_flag , on [_] ) 
Emit the DOCTYPE token 's [0]
 =>  emit ( DOCTYPE_token [0] . DOCTYPE_state ) 
Emit an end-of-file token
 =>  emit ( end-of-file_token [_] ) 
char:Anything else
Append the current input character to the current DOCTYPE token 's public identifier
 =>  append_to ( current_input_character [_] , current_tag_token [_] . public_identifier ) 

name:After_DOCTYPE_public_identifier_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
trans:
char:U+0009 CHARACTER TABULATION (tab)
Switch to the Between_DOCTYPE_public_and_system_identifiers_state
 =>  switch_to ( Between_DOCTYPE_public_and_system_identifiers_state [_] ) 
char:U+000A LINE FEED (LF)
Switch to the Between_DOCTYPE_public_and_system_identifiers_state
 =>  switch_to ( Between_DOCTYPE_public_and_system_identifiers_state [_] ) 
char:U+000C FORM FEED (FF)
Switch to the Between_DOCTYPE_public_and_system_identifiers_state
 =>  switch_to ( Between_DOCTYPE_public_and_system_identifiers_state [_] ) 
char:U+0020 SPACE
Switch to the Between_DOCTYPE_public_and_system_identifiers_state
 =>  switch_to ( Between_DOCTYPE_public_and_system_identifiers_state [_] ) 
char:U+003E GREATER-THAN SIGN (&gt;)
Switch to the Data_state
 =>  switch_to ( Data_state [_] ) 
Emit the current DOCTYPE token
 =>  emit ( current_tag_token [_] ) 
char:U+0022 QUOTATION MARK (")
This is a missing-whitespace-between-doctype-public-and-system-identifiers parse error
 =>  this_is_parse_error ( missing-whitespace-between-doctype-public-and-system-identifiers_parse_error [_] ) 
Set the DOCTYPE token 's system identifier to the empty string ( not missing ) , then switch to the DOCTYPE_system_identifier_double_quoted_state
 =>  set_to ( DOCTYPE_token [_] . system_identifier , empty_string [_] ) | switch_to ( DOCTYPE_system_identifier_double_quoted_state [_] ) 
char:U+0027 APOSTROPHE (')
This is a missing-whitespace-between-doctype-public-and-system-identifiers parse error
 =>  this_is_parse_error ( missing-whitespace-between-doctype-public-and-system-identifiers_parse_error [_] ) 
Set the DOCTYPE token 's system identifier to the empty string ( not missing ) , then switch to the DOCTYPE_system_identifier_single_quoted_state
 =>  set_to ( DOCTYPE_token [_] . system_identifier , empty_string [_] ) | switch_to ( DOCTYPE_system_identifier_single_quoted_state [_] ) 
char:EOF
This is an eof-in-doctype parse error
 =>  append_to ( eof-in-doctype_parse_error [_] , eof-in-doctype_parse_error [_] ) 
Set the DOCTYPE token 's [0] force-quirks flag to on
 =>  set_to ( DOCTYPE_token [0] . force-quirks_flag , on [_] ) 
Emit the DOCTYPE token 's [0]
 =>  emit ( DOCTYPE_token [0] . DOCTYPE_state ) 
Emit an end-of-file token
 =>  emit ( end-of-file_token [_] ) 
char:Anything else
This is a missing-quote-before-doctype-system-identifier parse error
 =>  this_is_parse_error ( missing-quote-before-doctype-system-identifier_parse_error [_] ) 
Set the DOCTYPE token 's force-quirks flag to on
 =>  set_to ( DOCTYPE_token [_] . force-quirks_flag , on [_] ) 
Reconsume in the Bogus_DOCTYPE_state
 =>  reconsume_in ( Bogus_DOCTYPE_state [_] ) 

name:Between_DOCTYPE_public_and_system_identifiers_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
trans:
char:U+0009 CHARACTER TABULATION (tab)
Ignore the character
 =>  ignore_the_character 
char:U+000A LINE FEED (LF)
Ignore the character
 =>  ignore_the_character 
char:U+000C FORM FEED (FF)
Ignore the character
 =>  ignore_the_character 
char:U+0020 SPACE
Ignore the character
 =>  ignore_the_character 
char:U+003E GREATER-THAN SIGN (&gt;)
Switch to the Data_state
 =>  switch_to ( Data_state [_] ) 
Emit the current DOCTYPE token
 =>  emit ( current_tag_token [_] ) 
char:U+0022 QUOTATION MARK (")
Set the DOCTYPE token 's system identifier to the empty string ( not missing ) , then switch to the DOCTYPE_system_identifier_double_quoted_state
 =>  set_to ( DOCTYPE_token [_] . system_identifier , empty_string [_] ) | switch_to ( DOCTYPE_system_identifier_double_quoted_state [_] ) 
char:U+0027 APOSTROPHE (')
Set the DOCTYPE token 's system identifier to the empty string ( not missing ) , then switch to the DOCTYPE_system_identifier_single_quoted_state
 =>  set_to ( DOCTYPE_token [_] . system_identifier , empty_string [_] ) | switch_to ( DOCTYPE_system_identifier_single_quoted_state [_] ) 
char:EOF
This is an eof-in-doctype parse error
 =>  append_to ( eof-in-doctype_parse_error [_] , eof-in-doctype_parse_error [_] ) 
Set the DOCTYPE token 's [0] force-quirks flag to on
 =>  set_to ( DOCTYPE_token [0] . force-quirks_flag , on [_] ) 
Emit the DOCTYPE token 's [0]
 =>  emit ( DOCTYPE_token [0] . DOCTYPE_state ) 
Emit an end-of-file token
 =>  emit ( end-of-file_token [_] ) 
char:Anything else
This is a missing-quote-before-doctype-system-identifier parse error
 =>  this_is_parse_error ( missing-quote-before-doctype-system-identifier_parse_error [_] ) 
Set the DOCTYPE token 's force-quirks flag to on
 =>  set_to ( DOCTYPE_token [_] . force-quirks_flag , on [_] ) 
Reconsume in the Bogus_DOCTYPE_state
 =>  reconsume_in ( Bogus_DOCTYPE_state [_] ) 

name:After_DOCTYPE_system_keyword_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
trans:
char:U+0009 CHARACTER TABULATION (tab)
Switch to the Before_DOCTYPE_system_identifier_state
 =>  switch_to ( Before_DOCTYPE_system_identifier_state [_] ) 
char:U+000A LINE FEED (LF)
Switch to the Before_DOCTYPE_system_identifier_state
 =>  switch_to ( Before_DOCTYPE_system_identifier_state [_] ) 
char:U+000C FORM FEED (FF)
Switch to the Before_DOCTYPE_system_identifier_state
 =>  switch_to ( Before_DOCTYPE_system_identifier_state [_] ) 
char:U+0020 SPACE
Switch to the Before_DOCTYPE_system_identifier_state
 =>  switch_to ( Before_DOCTYPE_system_identifier_state [_] ) 
char:U+0022 QUOTATION MARK (")
This is a missing-whitespace-after-doctype-system-keyword parse error
 =>  append_to ( missing-whitespace-after-doctype-system-keyword_parse_error [_] , missing-whitespace-after-doctype-system-keyword_parse_error [_] ) 
Set the DOCTYPE token 's system identifier to the empty string ( not missing ) , then switch to the DOCTYPE_system_identifier_double_quoted_state
 =>  set_to ( DOCTYPE_token [_] . system_identifier , empty_string [_] ) | switch_to ( DOCTYPE_system_identifier_double_quoted_state [_] ) 
char:U+0027 APOSTROPHE (')
This is a missing-whitespace-after-doctype-system-keyword parse error
 =>  append_to ( missing-whitespace-after-doctype-system-keyword_parse_error [_] , missing-whitespace-after-doctype-system-keyword_parse_error [_] ) 
Set the DOCTYPE token 's system identifier to the empty string ( not missing ) , then switch to the DOCTYPE_system_identifier_single_quoted_state
 =>  set_to ( DOCTYPE_token [_] . system_identifier , empty_string [_] ) | switch_to ( DOCTYPE_system_identifier_single_quoted_state [_] ) 
char:U+003E GREATER-THAN SIGN (&gt;)
This is a missing-doctype-system-identifier parse error
 =>  append_to ( missing-doctype-system-identifier_parse_error [_] , missing-doctype-system-identifier_parse_error [_] ) 
Set the DOCTYPE token 's [0] force-quirks flag to on
 =>  set_to ( DOCTYPE_token [0] . force-quirks_flag , on [_] ) 
Switch to the Data_state
 =>  switch_to ( Data_state [_] ) 
Emit the DOCTYPE token 's [0]
 =>  emit ( DOCTYPE_token [0] . DOCTYPE_state ) 
char:EOF
This is an eof-in-doctype parse error
 =>  append_to ( eof-in-doctype_parse_error [_] , eof-in-doctype_parse_error [_] ) 
Set the DOCTYPE token 's [0] force-quirks flag to on
 =>  set_to ( DOCTYPE_token [0] . force-quirks_flag , on [_] ) 
Emit the DOCTYPE token 's [0]
 =>  emit ( DOCTYPE_token [0] . DOCTYPE_state ) 
Emit an end-of-file token
 =>  emit ( end-of-file_token [_] ) 
char:Anything else
This is a missing-quote-before-doctype-system-identifier parse error
 =>  this_is_parse_error ( missing-quote-before-doctype-system-identifier_parse_error [_] ) 
Set the DOCTYPE token 's force-quirks flag to on
 =>  set_to ( DOCTYPE_token [_] . force-quirks_flag , on [_] ) 
Reconsume in the Bogus_DOCTYPE_state
 =>  reconsume_in ( Bogus_DOCTYPE_state [_] ) 

name:Before_DOCTYPE_system_identifier_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
trans:
char:U+0009 CHARACTER TABULATION (tab)
Ignore the character
 =>  ignore_the_character 
char:U+000A LINE FEED (LF)
Ignore the character
 =>  ignore_the_character 
char:U+000C FORM FEED (FF)
Ignore the character
 =>  ignore_the_character 
char:U+0020 SPACE
Ignore the character
 =>  ignore_the_character 
char:U+0022 QUOTATION MARK (")
Set the DOCTYPE token 's system identifier to the empty string ( not missing ) , then switch to the DOCTYPE_system_identifier_double_quoted_state
 =>  set_to ( DOCTYPE_token [_] . system_identifier , empty_string [_] ) | switch_to ( DOCTYPE_system_identifier_double_quoted_state [_] ) 
char:U+0027 APOSTROPHE (')
Set the DOCTYPE token 's system identifier to the empty string ( not missing ) , then switch to the DOCTYPE_system_identifier_single_quoted_state
 =>  set_to ( DOCTYPE_token [_] . system_identifier , empty_string [_] ) | switch_to ( DOCTYPE_system_identifier_single_quoted_state [_] ) 
char:U+003E GREATER-THAN SIGN (&gt;)
This is a missing-doctype-system-identifier parse error
 =>  append_to ( missing-doctype-system-identifier_parse_error [_] , missing-doctype-system-identifier_parse_error [_] ) 
Set the DOCTYPE token 's [0] force-quirks flag to on
 =>  set_to ( DOCTYPE_token [0] . force-quirks_flag , on [_] ) 
Switch to the Data_state
 =>  switch_to ( Data_state [_] ) 
Emit the DOCTYPE token 's [0]
 =>  emit ( DOCTYPE_token [0] . DOCTYPE_state ) 
char:EOF
This is an eof-in-doctype parse error
 =>  append_to ( eof-in-doctype_parse_error [_] , eof-in-doctype_parse_error [_] ) 
Set the DOCTYPE token 's [0] force-quirks flag to on
 =>  set_to ( DOCTYPE_token [0] . force-quirks_flag , on [_] ) 
Emit the DOCTYPE token 's [0]
 =>  emit ( DOCTYPE_token [0] . DOCTYPE_state ) 
Emit an end-of-file token
 =>  emit ( end-of-file_token [_] ) 
char:Anything else
This is a missing-quote-before-doctype-system-identifier parse error
 =>  this_is_parse_error ( missing-quote-before-doctype-system-identifier_parse_error [_] ) 
Set the DOCTYPE token 's force-quirks flag to on
 =>  set_to ( DOCTYPE_token [_] . force-quirks_flag , on [_] ) 
Reconsume in the Bogus_DOCTYPE_state
 =>  reconsume_in ( Bogus_DOCTYPE_state [_] ) 

name:DOCTYPE_system_identifier_double_quoted_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
trans:
char:U+0022 QUOTATION MARK (")
Switch to the After_DOCTYPE_system_identifier_state
 =>  switch_to ( After_DOCTYPE_system_identifier_state [_] ) 
char:U+0000 NULL
This is an unexpected-null-character parse error
 =>  append_to ( unexpected-null-character_parse_error [_] , unexpected-null-character_parse_error [_] ) 
Append a U+FFFD REPLACEMENT CHARACTER character to the current DOCTYPE token 's system identifier
 =>  append_to ( U+FFFD_REPLACEMENT_CHARACTER_character_token [_] , current_tag_token [_] . system_identifier ) 
char:U+003E GREATER-THAN SIGN (&gt;)
This is an abrupt-doctype-system-identifier parse error
 =>  append_to ( abrupt-doctype-system-identifier_parse_error [_] , abrupt-doctype-system-identifier_parse_error [_] ) 
Set the DOCTYPE token 's [0] force-quirks flag to on
 =>  set_to ( DOCTYPE_token [0] . force-quirks_flag , on [_] ) 
Switch to the Data_state
 =>  switch_to ( Data_state [_] ) 
Emit the DOCTYPE token 's [0]
 =>  emit ( DOCTYPE_token [0] . DOCTYPE_state ) 
char:EOF
This is an eof-in-doctype parse error
 =>  append_to ( eof-in-doctype_parse_error [_] , eof-in-doctype_parse_error [_] ) 
Set the DOCTYPE token 's [0] force-quirks flag to on
 =>  set_to ( DOCTYPE_token [0] . force-quirks_flag , on [_] ) 
Emit the DOCTYPE token 's [0]
 =>  emit ( DOCTYPE_token [0] . DOCTYPE_state ) 
Emit an end-of-file token
 =>  emit ( end-of-file_token [_] ) 
char:Anything else
Append the current input character to the current DOCTYPE token 's system identifier
 =>  append_to ( current_input_character [_] , current_tag_token [_] . system_identifier ) 

name:DOCTYPE_system_identifier_single_quoted_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
trans:
char:U+0027 APOSTROPHE (')
Switch to the After_DOCTYPE_system_identifier_state
 =>  switch_to ( After_DOCTYPE_system_identifier_state [_] ) 
char:U+0000 NULL
This is an unexpected-null-character parse error
 =>  append_to ( unexpected-null-character_parse_error [_] , unexpected-null-character_parse_error [_] ) 
Append a U+FFFD REPLACEMENT CHARACTER character to the current DOCTYPE token 's system identifier
 =>  append_to ( U+FFFD_REPLACEMENT_CHARACTER_character_token [_] , current_tag_token [_] . system_identifier ) 
char:U+003E GREATER-THAN SIGN (&gt;)
This is an abrupt-doctype-system-identifier parse error
 =>  append_to ( abrupt-doctype-system-identifier_parse_error [_] , abrupt-doctype-system-identifier_parse_error [_] ) 
Set the DOCTYPE token 's [0] force-quirks flag to on
 =>  set_to ( DOCTYPE_token [0] . force-quirks_flag , on [_] ) 
Switch to the Data_state
 =>  switch_to ( Data_state [_] ) 
Emit the DOCTYPE token 's [0]
 =>  emit ( DOCTYPE_token [0] . DOCTYPE_state ) 
char:EOF
This is an eof-in-doctype parse error
 =>  append_to ( eof-in-doctype_parse_error [_] , eof-in-doctype_parse_error [_] ) 
Set the DOCTYPE token 's [0] force-quirks flag to on
 =>  set_to ( DOCTYPE_token [0] . force-quirks_flag , on [_] ) 
Emit the DOCTYPE token 's [0]
 =>  emit ( DOCTYPE_token [0] . DOCTYPE_state ) 
Emit an end-of-file token
 =>  emit ( end-of-file_token [_] ) 
char:Anything else
Append the current input character to the current DOCTYPE token 's system identifier
 =>  append_to ( current_input_character [_] , current_tag_token [_] . system_identifier ) 

name:After_DOCTYPE_system_identifier_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
trans:
char:U+0009 CHARACTER TABULATION (tab)
Ignore the character
 =>  ignore_the_character 
char:U+000A LINE FEED (LF)
Ignore the character
 =>  ignore_the_character 
char:U+000C FORM FEED (FF)
Ignore the character
 =>  ignore_the_character 
char:U+0020 SPACE
Ignore the character
 =>  ignore_the_character 
char:U+003E GREATER-THAN SIGN (&gt;)
Switch to the Data_state
 =>  switch_to ( Data_state [_] ) 
Emit the current DOCTYPE token
 =>  emit ( current_tag_token [_] ) 
char:EOF
This is an eof-in-doctype parse error
 =>  append_to ( eof-in-doctype_parse_error [_] , eof-in-doctype_parse_error [_] ) 
Set the DOCTYPE token 's [0] force-quirks flag to on
 =>  set_to ( DOCTYPE_token [0] . force-quirks_flag , on [_] ) 
Emit the DOCTYPE token 's [0]
 =>  emit ( DOCTYPE_token [0] . DOCTYPE_state ) 
Emit an end-of-file token
 =>  emit ( end-of-file_token [_] ) 
char:Anything else
This is an unexpected-character-after-doctype-system-identifier parse error
 =>  append_to ( unexpected-character-after-doctype-system-identifier_parse_error [_] , unexpected-character-after-doctype-system-identifier_parse_error [_] ) 
Reconsume [0] in the Bogus_DOCTYPE_state
 =>  reconsume_in ( Bogus_DOCTYPE_state [0] ) 

 =>  ignore_the_character 

name:Bogus_DOCTYPE_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
trans:
char:U+003E GREATER-THAN SIGN (&gt;)
Switch to the Data_state
 =>  switch_to ( Data_state [_] ) 
Emit the DOCTYPE token
 =>  emit ( DOCTYPE_token [_] ) 
char:U+0000 NULL
This [0] is an unexpected-null-character parse error
 =>  append_to ( unexpected-null-character_parse_error [0] , unexpected-null-character_parse_error [_] ) 
Ignore This [0]
 =>  this_is_parse_error ( state [0] ) 
char:EOF
Emit the DOCTYPE token
 =>  emit ( DOCTYPE_token [_] ) 
Emit an end-of-file token
 =>  emit ( end-of-file_token [_] ) 
char:Anything else
Ignore the character
 =>  ignore_the_character 

name:CDATA_section_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
trans:
char:U+005D RIGHT SQUARE BRACKET (])
Switch to the CDATA_section_bracket_state
 =>  switch_to ( CDATA_section_bracket_state [_] ) 
char:EOF
This is an eof-in-cdata parse error
 =>  append_to ( eof-in-cdata_parse_error [_] , eof-in-cdata_parse_error [_] ) 
Emit an end-of-file token
 =>  emit ( end-of-file_token [_] ) 
char:Anything else
Emit the current input character as a character token
 =>  emit ( current_input_character [_] ) 

name:CDATA_section_bracket_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
trans:
char:U+005D RIGHT SQUARE BRACKET (])
Switch to the CDATA_section_end_state
 =>  switch_to ( CDATA_section_end_state [_] ) 
char:Anything else
Emit a U+005D RIGHT SQUARE BRACKET character token
 =>  emit ( U+005D_RIGHT_SQUARE_BRACKET_character_token [_] ) 
Reconsume in the CDATA_section_state
 =>  reconsume_in ( CDATA_section_state [_] ) 

name:CDATA_section_end_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
trans:
char:U+005D RIGHT SQUARE BRACKET (])
Emit a U+005D RIGHT SQUARE BRACKET character token
 =>  emit ( U+005D_RIGHT_SQUARE_BRACKET_character_token [_] ) 
char:U+003E GREATER-THAN SIGN character
Switch to the Data_state
 =>  switch_to ( Data_state [_] ) 
char:Anything else
Emit two U+005D RIGHT SQUARE BRACKET character tokens
 =>  emit ( U+005D_RIGHT_SQUARE_BRACKET_character_token [_] ) 
Reconsume in the CDATA_section_state
 =>  reconsume_in ( CDATA_section_state [_] ) 

name:Character_reference_state
prev:
Set the temporary buffer [0] to the empty string
 =>  set_to ( temporary_buffer [0] , empty_string [_] ) 
Append a U+0026 AMPERSAND ( & amp ;) character to the temporary buffer [0]
 =>  append_to ( RCDATA_end_tag_open_state [_] , temporary_buffer [0] ) 
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
trans:
char:ASCII alphanumeric
Reconsume in the Named_character_reference_state
 =>  reconsume_in ( state [_] ) 
char:U+0023 NUMBER SIGN (#)
Append the current input character to the temporary buffer
 =>  append_to ( current_input_character [_] , temporary_buffer [_] ) 
Switch to the Numeric_character_reference_state
 =>  switch_to ( Numeric_character_reference_state [_] ) 
char:Anything else
Flush code points consumed as a character reference
 =>  flush_code_points_consumed_as_a_character_reference 
Reconsume in the return state
 =>  reconsume_in ( return_state [_] ) 

name:Named_character_reference_state
prev:
Consume the maximum number of characters possible , where the consumed characters are one of the identifiers in the first column of the named character references table
 =>  consume ( self-closing_flag [_] ) | emit ( RCDATA_end_tag_open_state [_] ) | reconsume_in ( U+002D_HYPHEN-MINUS_character_token [_] ) 
Append each character [0] to the temporary buffer when each character [0] 's consumed
 =>  append_to ( Numeric_character_reference_end_state [0] , Numeric_character_reference_end_state [0] ) 
trans:
char:If there is a match
If the character reference was consumed as part of an attribute , and the last character matched [0] is not a U+003B SEMICOLON character ( ;) , and the next input character is either a U+003D EQUALS SIGN character ( =) or an ASCII alphanumeric , then , for historical reasons , flush code points consumed as a character reference and switch to the return state [2]
 =>  if_then ( the_character_reference_was_consumed_as_part_of_an_attribute , emit ( RCDATA_end_tag_open_state [0] ) | emit ( RCDATA_end_tag_open_state [_] ) | emit ( next_input_character [_] ) , emit ( on [_] ) | emit ( Before_DOCTYPE_system_identifier_state [2] ) | switch_to ( return_state [_] ) ) 
Otherwise : If the last character matched [0] is not a U+003B SEMICOLON character ( ;) , then this is a missing-semicolon-after-character-reference parse error
 =>  otherwise ( set_to ( Numeric_character_reference_end_state [0] , missing-semicolon-after-character-reference_parse_error [_] ) | set_to ( missing-semicolon-after-character-reference_parse_error [_] , missing-semicolon-after-character-reference_parse_error [_] ) ) 
Set the temporary buffer [1] to the empty string
 =>  set_to ( temporary_buffer [1] , empty_string [_] ) 
Append one or two characters corresponding to the character reference name ( as given by the second column of the named character references table ) to the temporary buffer [1]
 =>  append_to ( Numeric_character_reference_end_state [_] , name [1] ) 
Flush code points consumed as a character reference
 =>  flush_code_points_consumed_as_a_character_reference 
Switch to the return state [2]
 =>  switch_to ( return_state [2] ) 
char:Otherwise
Flush code points consumed as a character reference
 =>  flush_code_points_consumed_as_a_character_reference 
Switch to the Ambiguous_ampersand_state
 =>  switch_to ( Ambiguous_ampersand_state [_] ) 

name:Ambiguous_ampersand_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
trans:
char:ASCII alphanumeric
If the character reference was consumed as part of an attribute [0] , then append the current input character [1] to an attribute [0] value
 =>  if_then ( the_character_reference_was_consumed_as_part_of_an_attribute , append_to ( current_input_character [1] , attribute [0] . value ) ) 
Otherwise , emit the current input character [1] as a character token
 =>  otherwise ( emit ( current_input_character [1] ) ) 
char:U+003B SEMICOLON (;)
This is an unknown-named-character-reference parse error
 =>  append_to ( unknown-named-character-reference_parse_error [_] , unknown-named-character-reference_parse_error [_] ) 
Reconsume in the return state
 =>  reconsume_in ( return_state [_] ) 
char:Anything else
Reconsume in the return state
 =>  reconsume_in ( return_state [_] ) 

name:Numeric_character_reference_state
prev:
Set the character reference code to zero ( 0).Consume the next input character 
 =>  set_to ( Numeric_character_reference_end_state [_] , next_input_character [_] ) 
trans:
char:U+0078 LATIN SMALL LETTER X
Append the current input character to the temporary buffer
 =>  append_to ( current_input_character [_] , temporary_buffer [_] ) 
Switch to the Hexadecimal_character_reference_start_state
 =>  switch_to ( Hexadecimal_character_reference_start_state [_] ) 
char:U+0058 LATIN CAPITAL LETTER X
Append the current input character to the temporary buffer
 =>  append_to ( current_input_character [_] , temporary_buffer [_] ) 
Switch to the Hexadecimal_character_reference_start_state
 =>  switch_to ( Hexadecimal_character_reference_start_state [_] ) 
char:Anything else
Reconsume in the Decimal_character_reference_start_state
 =>  reconsume_in ( Decimal_character_reference_start_state [_] ) 

name:Hexadecimal_character_reference_start_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
trans:
char:ASCII hex digit
Reconsume in the Hexadecimal_character_reference_state
 =>  reconsume_in ( Hexadecimal_character_reference_state [_] ) 
char:Anything else
This is an absence-of-digits-in-numeric-character-reference parse error
 =>  append_to ( absence-of-digits-in-numeric-character-reference_parse_error [_] , absence-of-digits-in-numeric-character-reference_parse_error [_] ) 
Flush code points consumed as a character reference
 =>  flush_code_points_consumed_as_a_character_reference 
Reconsume in the return state
 =>  reconsume_in ( return_state [_] ) 

name:Decimal_character_reference_start_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
trans:
char:ASCII digit
Reconsume in the Decimal_character_reference_state
 =>  reconsume_in ( Decimal_character_reference_state [_] ) 
char:Anything else
This is an absence-of-digits-in-numeric-character-reference parse error
 =>  append_to ( absence-of-digits-in-numeric-character-reference_parse_error [_] , absence-of-digits-in-numeric-character-reference_parse_error [_] ) 
Flush code points consumed as a character reference
 =>  flush_code_points_consumed_as_a_character_reference 
Reconsume in the return state
 =>  reconsume_in ( return_state [_] ) 

name:Hexadecimal_character_reference_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
trans:
char:ASCII digit
Multiply the character reference code [1] by 16
 =>  multiply_the_character_reference_code_by ( data [1] ) 
Add a numeric version of the current input character [0] ( subtract 0x0030 from the current input character [0] code point ) to the character reference code [1]
 =>  add_to_the_character_reference_code ( current_input_character [0] . numeric_version ) 
char:ASCII upper hex digit
Multiply the character reference code [1] by 16
 =>  multiply_the_character_reference_code_by ( data [1] ) 
Add a numeric version of the current input character [0] as a hexadecimal digit ( subtract 0x0037 from the current input character [0] code point ) to the character reference code [1]
 =>  add_to_the_character_reference_code ( current_input_character [0] . numeric_version ) 
char:ASCII lower hex digit
Multiply the character reference code [1] by 16
 =>  multiply_the_character_reference_code_by ( data [1] ) 
Add a numeric version of the current input character [0] as a hexadecimal digit ( subtract 0x0057 from the current input character [0] code point ) to the character reference code [1]
 =>  add_to_the_character_reference_code ( current_input_character [0] . numeric_version ) 
char:U+003B SEMICOLON
Switch to the Numeric_character_reference_end_state
 =>  switch_to ( Numeric_character_reference_end_state [_] ) 
char:Anything else
This is a missing-semicolon-after-character-reference parse error
 =>  append_to ( missing-semicolon-after-character-reference_parse_error [_] , missing-semicolon-after-character-reference_parse_error [_] ) 
Reconsume in the Numeric_character_reference_end_state
 =>  reconsume_in ( Numeric_character_reference_end_state [_] ) 

name:Decimal_character_reference_state
prev:
Consume the next input character 
 =>  consume ( next_input_character [_] ) 
trans:
char:ASCII digit
Multiply the character reference code [1] by 10
 =>  multiply_the_character_reference_code_by ( 10 [1] ) 
Add a numeric version of the current input character [0] ( subtract 0x0030 from the current input character [0] code point ) to the character reference code [1]
 =>  add_to_the_character_reference_code ( current_input_character [0] . numeric_version ) 
char:U+003B SEMICOLON
Switch to the Numeric_character_reference_end_state
 =>  switch_to ( Numeric_character_reference_end_state [_] ) 
char:Anything else
This is a missing-semicolon-after-character-reference parse error
 =>  append_to ( missing-semicolon-after-character-reference_parse_error [_] , missing-semicolon-after-character-reference_parse_error [_] ) 
Reconsume in the Numeric_character_reference_end_state
 =>  reconsume_in ( Numeric_character_reference_end_state [_] ) 
